{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/model.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst Aggregate = require('./aggregate');\nconst ChangeStream = require('./cursor/changeStream');\nconst Document = require('./document');\nconst DocumentNotFoundError = require('./error/notFound');\nconst EventEmitter = require('events').EventEmitter;\nconst Kareem = require('kareem');\nconst MongooseBulkWriteError = require('./error/bulkWriteError');\nconst MongooseError = require('./error/index');\nconst ObjectParameterError = require('./error/objectParameter');\nconst OverwriteModelError = require('./error/overwriteModel');\nconst Query = require('./query');\nconst SaveOptions = require('./options/saveOptions');\nconst Schema = require('./schema');\nconst ValidationError = require('./error/validation');\nconst VersionError = require('./error/version');\nconst ParallelSaveError = require('./error/parallelSave');\nconst applyDefaultsHelper = require('./helpers/document/applyDefaults');\nconst applyDefaultsToPOJO = require('./helpers/model/applyDefaultsToPOJO');\nconst applyEmbeddedDiscriminators = require('./helpers/discriminator/applyEmbeddedDiscriminators');\nconst applyHooks = require('./helpers/model/applyHooks');\nconst applyMethods = require('./helpers/model/applyMethods');\nconst applyProjection = require('./helpers/projection/applyProjection');\nconst applyReadConcern = require('./helpers/schema/applyReadConcern');\nconst applySchemaCollation = require('./helpers/indexes/applySchemaCollation');\nconst applyStaticHooks = require('./helpers/model/applyStaticHooks');\nconst applyStatics = require('./helpers/model/applyStatics');\nconst applyTimestampsHelper = require('./helpers/document/applyTimestamps');\nconst applyWriteConcern = require('./helpers/schema/applyWriteConcern');\nconst applyVirtualsHelper = require('./helpers/document/applyVirtuals');\nconst assignVals = require('./helpers/populate/assignVals');\nconst castBulkWrite = require('./helpers/model/castBulkWrite');\nconst clone = require('./helpers/clone');\nconst createPopulateQueryFilter = require('./helpers/populate/createPopulateQueryFilter');\nconst decorateUpdateWithVersionKey = require('./helpers/update/decorateUpdateWithVersionKey');\nconst getDefaultBulkwriteResult = require('./helpers/getDefaultBulkwriteResult');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst discriminator = require('./helpers/model/discriminator');\nconst each = require('./helpers/each');\nconst get = require('./helpers/get');\nconst getConstructorName = require('./helpers/getConstructorName');\nconst getDiscriminatorByValue = require('./helpers/discriminator/getDiscriminatorByValue');\nconst getModelsMapForPopulate = require('./helpers/populate/getModelsMapForPopulate');\nconst immediate = require('./helpers/immediate');\nconst internalToObjectOptions = require('./options').internalToObjectOptions;\nconst isDefaultIdIndex = require('./helpers/indexes/isDefaultIdIndex');\nconst isIndexEqual = require('./helpers/indexes/isIndexEqual');\nconst isTimeseriesIndex = require('./helpers/indexes/isTimeseriesIndex');\nconst {\n  getRelatedDBIndexes,\n  getRelatedSchemaIndexes\n} = require('./helpers/indexes/getRelatedIndexes');\nconst decorateDiscriminatorIndexOptions = require('./helpers/indexes/decorateDiscriminatorIndexOptions');\nconst isPathSelectedInclusive = require('./helpers/projection/isPathSelectedInclusive');\nconst leanPopulateMap = require('./helpers/populate/leanPopulateMap');\nconst parallelLimit = require('./helpers/parallelLimit');\nconst prepareDiscriminatorPipeline = require('./helpers/aggregate/prepareDiscriminatorPipeline');\nconst pushNestedArrayPaths = require('./helpers/model/pushNestedArrayPaths');\nconst removeDeselectedForeignField = require('./helpers/populate/removeDeselectedForeignField');\nconst setDottedPath = require('./helpers/path/setDottedPath');\nconst util = require('util');\nconst utils = require('./utils');\nconst minimize = require('./helpers/minimize');\nconst MongooseBulkSaveIncompleteError = require('./error/bulkSaveIncompleteError');\nconst ObjectExpectedError = require('./error/objectExpected');\nconst decorateBulkWriteResult = require('./helpers/model/decorateBulkWriteResult');\nconst modelCollectionSymbol = Symbol('mongoose#Model#collection');\nconst modelDbSymbol = Symbol('mongoose#Model#db');\nconst modelSymbol = require('./helpers/symbols').modelSymbol;\nconst subclassedSymbol = Symbol('mongoose#Model#subclassed');\n\nconst { VERSION_INC, VERSION_WHERE, VERSION_ALL } = Document;\n\nconst saveToObjectOptions = Object.assign({}, internalToObjectOptions, {\n  bson: true\n});\n\n/**\n * A Model is a class that's your primary tool for interacting with MongoDB.\n * An instance of a Model is called a [Document](https://mongoosejs.com/docs/api/document.html#Document).\n *\n * In Mongoose, the term \"Model\" refers to subclasses of the `mongoose.Model`\n * class. You should not use the `mongoose.Model` class directly. The\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) and\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()) functions\n * create subclasses of `mongoose.Model` as shown below.\n *\n * #### Example:\n *\n *     // `UserModel` is a \"Model\", a subclass of `mongoose.Model`.\n *     const UserModel = mongoose.model('User', new Schema({ name: String }));\n *\n *     // You can use a Model to create new documents using `new`:\n *     const userDoc = new UserModel({ name: 'Foo' });\n *     await userDoc.save();\n *\n *     // You also use a model to create queries:\n *     const userFromDb = await UserModel.findOne({ name: 'Foo' });\n *\n * @param {Object} doc values for initial set\n * @param {Object} [fields] optional object containing the fields that were selected in the query which returned this document. You do **not** need to set this parameter to ensure Mongoose handles your [query projection](https://mongoosejs.com/docs/api/query.html#Query.prototype.select()).\n * @param {Boolean} [skipId=false] optional boolean. If true, mongoose doesn't add an `_id` field to the document.\n * @inherits Document https://mongoosejs.com/docs/api/document.html\n * @event `error`: If listening to this event, 'error' is emitted when a document was saved and an `error` occurred. If not listening, the event bubbles to the connection used to create this Model.\n * @event `index`: Emitted after `Model#ensureIndexes` completes. If an error occurred it is passed with the event.\n * @event `index-single-start`: Emitted when an individual index starts within `Model#ensureIndexes`. The fields and options being used to build the index are also passed with the event.\n * @event `index-single-done`: Emitted when an individual index finishes within `Model#ensureIndexes`. If an error occurred it is passed with the event. The fields, options, and index name are also passed.\n * @api public\n */\n\nfunction Model(doc, fields, skipId) {\n  if (fields instanceof Schema) {\n    throw new TypeError('2nd argument to `Model` constructor must be a POJO or string, ' +\n      '**not** a schema. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  if (typeof doc === 'string') {\n    throw new TypeError('First argument to `Model` constructor must be an object, ' +\n      '**not** a string. Make sure you\\'re calling `mongoose.model()`, not ' +\n      '`mongoose.Model()`.');\n  }\n  Document.call(this, doc, fields, skipId);\n}\n\n/**\n * Inherits from Document.\n *\n * All Model.prototype features are available on\n * top level (non-sub) documents.\n * @api private\n */\n\nObject.setPrototypeOf(Model.prototype, Document.prototype);\nModel.prototype.$isMongooseModelPrototype = true;\n\n/**\n * Connection the model uses.\n *\n * @api public\n * @property db\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.db;\n\n/**\n * Changes the Connection instance this model uses to make requests to MongoDB.\n * This function is most useful for changing the Connection that a Model defined using `mongoose.model()` uses\n * after initialization.\n *\n * #### Example:\n *\n *     await mongoose.connect('mongodb://127.0.0.1:27017/db1');\n *     const UserModel = mongoose.model('User', mongoose.Schema({ name: String }));\n *     UserModel.connection === mongoose.connection; // true\n *\n *     const conn2 = await mongoose.createConnection('mongodb://127.0.0.1:27017/db2').asPromise();\n *     UserModel.useConnection(conn2); // `UserModel` now stores documents in `db2`, not `db1`\n *\n *     UserModel.connection === mongoose.connection; // false\n *     UserModel.connection === conn2; // true\n *\n *     conn2.model('User') === UserModel; // true\n *     mongoose.model('User'); // Throws 'MissingSchemaError'\n *\n * Note: `useConnection()` does **not** apply any [connection-level plugins](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.plugin()) from the new connection.\n * If you use `useConnection()` to switch a model's connection, the model will still have the old connection's plugins.\n *\n * @function useConnection\n * @param [Connection] connection The new connection to use\n * @return [Model] this\n * @api public\n */\n\nModel.useConnection = function useConnection(connection) {\n  if (!connection) {\n    throw new Error('Please provide a connection.');\n  }\n  if (this.db) {\n    delete this.db.models[this.modelName];\n    delete this.prototype.db;\n    delete this.prototype[modelDbSymbol];\n    delete this.prototype.collection;\n    delete this.prototype.$collection;\n    delete this.prototype[modelCollectionSymbol];\n  }\n\n  this.db = connection;\n  const collection = connection.collection(this.collection.collectionName, connection.options);\n  this.prototype.collection = collection;\n  this.prototype.$collection = collection;\n  this.prototype[modelCollectionSymbol] = collection;\n  this.prototype.db = connection;\n  this.prototype[modelDbSymbol] = connection;\n  this.collection = collection;\n  this.$__collection = collection;\n  connection.models[this.modelName] = this;\n\n  return this;\n};\n\n/**\n * The collection instance this model uses.\n * A Mongoose collection is a thin wrapper around a [MongoDB Node.js driver collection]([MongoDB Node.js driver collection](https://mongodb.github.io/node-mongodb-native/Next/classes/Collection.html)).\n * Using `Model.collection` means you bypass Mongoose middleware, validation, and casting.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api public\n * @property collection\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.collection;\n\n/**\n * Internal collection the model uses.\n *\n * This property is read-only. Modifying this property is a no-op.\n *\n * @api private\n * @property collection\n * @memberOf Model\n * @instance\n */\n\n\nModel.prototype.$__collection;\n\n/**\n * The name of the model\n *\n * @api public\n * @property modelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.modelName;\n\n/**\n * Additional properties to attach to the query when calling `save()` and\n * `isNew` is false.\n *\n * @api public\n * @property $where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$where;\n\n/**\n * If this is a discriminator model, `baseModelName` is the name of\n * the base model.\n *\n * @api public\n * @property baseModelName\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.baseModelName;\n\n/**\n * Event emitter that reports any errors that occurred. Useful for global error\n * handling.\n *\n * #### Example:\n *\n *     MyModel.events.on('error', err => console.log(err.message));\n *\n *     // Prints a 'CastError' because of the above handler\n *     await MyModel.findOne({ _id: 'Not a valid ObjectId' }).catch(noop);\n *\n * @api public\n * @property events\n * @fires error whenever any query or model function errors\n * @memberOf Model\n * @static\n */\n\nModel.events;\n\n/**\n * Compiled middleware for this model. Set in `applyHooks()`.\n *\n * @api private\n * @property _middleware\n * @memberOf Model\n * @static\n */\n\nModel._middleware;\n\n/*!\n * ignore\n */\n\nfunction _applyCustomWhere(doc, where) {\n  if (doc.$where == null) {\n    return;\n  }\n  for (const key of Object.keys(doc.$where)) {\n    where[key] = doc.$where[key];\n  }\n}\n\n/*!\n * ignore\n */\n\nModel.prototype.$__handleSave = function(options, callback) {\n  const saveOptions = {};\n\n  applyWriteConcern(this.$__schema, options);\n  if (typeof options.writeConcern !== 'undefined') {\n    saveOptions.writeConcern = {};\n    if ('w' in options.writeConcern) {\n      saveOptions.writeConcern.w = options.writeConcern.w;\n    }\n    if ('j' in options.writeConcern) {\n      saveOptions.writeConcern.j = options.writeConcern.j;\n    }\n    if ('wtimeout' in options.writeConcern) {\n      saveOptions.writeConcern.wtimeout = options.writeConcern.wtimeout;\n    }\n  } else {\n    if ('w' in options) {\n      saveOptions.w = options.w;\n    }\n    if ('j' in options) {\n      saveOptions.j = options.j;\n    }\n    if ('wtimeout' in options) {\n      saveOptions.wtimeout = options.wtimeout;\n    }\n  }\n  if ('checkKeys' in options) {\n    saveOptions.checkKeys = options.checkKeys;\n  }\n\n  const session = this.$session();\n  const asyncLocalStorage = this[modelDbSymbol].base.transactionAsyncLocalStorage?.getStore();\n  if (session != null) {\n    saveOptions.session = session;\n  } else if (!options.hasOwnProperty('session') && asyncLocalStorage?.session != null) {\n    // Only set session from asyncLocalStorage if `session` option wasn't originally passed in options\n    saveOptions.session = asyncLocalStorage.session;\n  }\n  if (this.$isNew) {\n    // send entire doc\n    const obj = this.toObject(saveToObjectOptions);\n    if ((obj || {})._id === void 0) {\n      // documents must have an _id else mongoose won't know\n      // what to update later if more changes are made. the user\n      // wouldn't know what _id was generated by mongodb either\n      // nor would the ObjectId generated by mongodb necessarily\n      // match the schema definition.\n      immediate(function() {\n        callback(new MongooseError('document must have an _id before saving'));\n      });\n      return;\n    }\n\n    this.$__version(true, obj);\n    this[modelCollectionSymbol].insertOne(obj, saveOptions).then(\n      ret => callback(null, ret),\n      err => {\n        _setIsNew(this, true);\n\n        callback(err, null);\n      }\n    );\n\n    this.$__reset();\n    _setIsNew(this, false);\n    // Make it possible to retry the insert\n    this.$__.inserting = true;\n    return;\n  }\n\n  // Make sure we don't treat it as a new object on error,\n  // since it already exists\n  this.$__.inserting = false;\n  const delta = this.$__delta();\n\n  if (options.pathsToSave) {\n    for (const key in delta[1]['$set']) {\n      if (options.pathsToSave.includes(key)) {\n        continue;\n      } else if (options.pathsToSave.some(pathToSave => key.slice(0, pathToSave.length) === pathToSave && key.charAt(pathToSave.length) === '.')) {\n        continue;\n      } else {\n        delete delta[1]['$set'][key];\n      }\n    }\n  }\n  if (delta) {\n    if (delta instanceof MongooseError) {\n      callback(delta);\n      return;\n    }\n\n    const where = this.$__where(delta[0]);\n    if (where instanceof MongooseError) {\n      callback(where);\n      return;\n    }\n\n    _applyCustomWhere(this, where);\n\n    const update = delta[1];\n    if (this.$__schema.options.minimize) {\n      for (const updateOp of Object.values(update)) {\n        if (updateOp == null) {\n          continue;\n        }\n        for (const key of Object.keys(updateOp)) {\n          if (updateOp[key] == null || typeof updateOp[key] !== 'object') {\n            continue;\n          }\n          if (!utils.isPOJO(updateOp[key])) {\n            continue;\n          }\n          minimize(updateOp[key]);\n          if (Object.keys(updateOp[key]).length === 0) {\n            delete updateOp[key];\n            update.$unset = update.$unset || {};\n            update.$unset[key] = 1;\n          }\n        }\n      }\n    }\n\n    this[modelCollectionSymbol].updateOne(where, update, saveOptions).then(\n      ret => {\n        if (ret == null) {\n          ret = { $where: where };\n        } else {\n          ret.$where = where;\n        }\n        callback(null, ret);\n      },\n      err => {\n        this.$__undoReset();\n\n        callback(err);\n      }\n    );\n  } else {\n    handleEmptyUpdate.call(this);\n    return;\n  }\n\n  // store the modified paths before the document is reset in case we need to generate version error.\n  this.$__.modifiedPaths = this.modifiedPaths().concat(Object.keys(this.$__.activePaths.getStatePaths('default')));\n  this.$__reset();\n\n  _setIsNew(this, false);\n\n  function handleEmptyUpdate() {\n    const optionsWithCustomValues = Object.assign({}, options, saveOptions);\n    const where = this.$__where();\n    const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;\n    if (optimisticConcurrency && !Array.isArray(optimisticConcurrency)) {\n      const key = this.$__schema.options.versionKey;\n      const val = this.$__getValue(key);\n      if (val != null) {\n        where[key] = val;\n      }\n    }\n\n    applyReadConcern(this.$__schema, optionsWithCustomValues);\n    this.constructor.collection.findOne(where, optionsWithCustomValues)\n      .then(documentExists => {\n        const matchedCount = !documentExists ? 0 : 1;\n        callback(null, { $where: where, matchedCount });\n      })\n      .catch(callback);\n  }\n};\n\n/*!\n * ignore\n */\n\nModel.prototype.$__save = function(options, callback) {\n  this.$__handleSave(options, (error, result) => {\n    if (error) {\n      error = this.$__schema._transformDuplicateKeyError(error);\n      const hooks = this.$__schema.s.hooks;\n      return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n        callback(error, this);\n      });\n    }\n    let numAffected = 0;\n    const writeConcern = options != null ?\n      options.writeConcern != null ?\n        options.writeConcern.w :\n        options.w :\n      0;\n    if (writeConcern !== 0) {\n      // Skip checking if write succeeded if writeConcern is set to\n      // unacknowledged writes, because otherwise `numAffected` will always be 0\n      if (result != null) {\n        if (Array.isArray(result)) {\n          numAffected = result.length;\n        } else if (result.matchedCount != null) {\n          numAffected = result.matchedCount;\n        } else {\n          numAffected = result;\n        }\n      }\n\n      const versionBump = this.$__.version;\n      // was this an update that required a version bump?\n      if (versionBump && !this.$__.inserting) {\n        const doIncrement = VERSION_INC === (VERSION_INC & this.$__.version);\n        this.$__.version = undefined;\n        const key = this.$__schema.options.versionKey;\n        const version = this.$__getValue(key) || 0;\n        if (numAffected <= 0) {\n          // the update failed. pass an error back\n          this.$__undoReset();\n          const err = this.$__.$versionError ||\n            new VersionError(this, version, this.$__.modifiedPaths);\n          return callback(err, this);\n        }\n\n        // increment version if was successful\n        if (doIncrement) {\n          this.$__setValue(key, version + 1);\n        }\n      }\n      if (result != null && numAffected <= 0) {\n        this.$__undoReset();\n        error = new DocumentNotFoundError(result.$where,\n          this.constructor.modelName, numAffected, result);\n        const hooks = this.$__schema.s.hooks;\n        return hooks.execPost('save:error', this, [this], { error: error }, (error) => {\n          callback(error, this);\n        });\n      }\n    }\n    this.$__.saving = undefined;\n    this.$__.savedState = {};\n    this.$emit('save', this, numAffected);\n    this.constructor.emit('save', this, numAffected);\n    callback(null, this);\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction generateVersionError(doc, modifiedPaths, defaultPaths) {\n  const key = doc.$__schema.options.versionKey;\n  if (!key) {\n    return null;\n  }\n  const version = doc.$__getValue(key) || 0;\n  return new VersionError(doc, version, modifiedPaths.concat(defaultPaths));\n}\n\n/**\n * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) is `true`,\n * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation with just the modified paths if `isNew` is `false`.\n *\n * #### Example:\n *\n *     product.sold = Date.now();\n *     product = await product.save();\n *\n * If save is successful, the returned promise will fulfill with the document\n * saved.\n *\n * #### Example:\n *\n *     const newProduct = await product.save();\n *     newProduct === product; // true\n *\n * @param {Object} [options] options optional options\n * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.session()).\n * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.\n * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.\n * @param {Boolean} [options.validateModifiedOnly=false] if `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.\n * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).\n * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#mongodb-limit-Restrictions-on-Field-Names)\n * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.\n * @param {Array} [options.pathsToSave] An array of paths that tell mongoose to only validate and save the paths in `pathsToSave`.\n * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).\n * @return {Promise}\n * @api public\n * @see middleware https://mongoosejs.com/docs/middleware.html\n */\n\nModel.prototype.save = async function save(options) {\n  if (typeof options === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.save() no longer accepts a callback');\n  }\n\n  let parallelSave;\n  this.$op = 'save';\n\n  if (this.$__.saving) {\n    parallelSave = new ParallelSaveError(this);\n  } else {\n    this.$__.saving = new ParallelSaveError(this);\n  }\n\n  options = new SaveOptions(options);\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n  if (this.$__.timestamps != null) {\n    options.timestamps = this.$__.timestamps;\n  }\n  this.$__.$versionError = generateVersionError(\n    this,\n    this.modifiedPaths(),\n    Object.keys(this.$__.activePaths.getStatePaths('default'))\n  );\n\n  if (parallelSave) {\n    this.$__handleReject(parallelSave);\n    throw parallelSave;\n  }\n\n  this.$__.saveOptions = options;\n\n  await new Promise((resolve, reject) => {\n    this.$__save(options, error => {\n      this.$__.saving = null;\n      this.$__.saveOptions = null;\n      this.$__.$versionError = null;\n      this.$op = null;\n      if (error != null) {\n        this.$__handleReject(error);\n        return reject(error);\n      }\n\n      resolve();\n    });\n  });\n\n  return this;\n};\n\nModel.prototype.$save = Model.prototype.save;\n\n/**\n * Appends versioning to the where and update clauses.\n *\n * @api private\n * @method $__version\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__version = function(where, delta) {\n  const key = this.$__schema.options.versionKey;\n  if (where === true) {\n    // this is an insert\n    if (key) {\n      setDottedPath(delta, key, 0);\n      this.$__setValue(key, 0);\n    }\n    return;\n  }\n\n  if (key === false) {\n    return;\n  }\n\n  // updates\n\n  // only apply versioning if our versionKey was selected. else\n  // there is no way to select the correct version. we could fail\n  // fast here and force them to include the versionKey but\n  // thats a bit intrusive. can we do this automatically?\n\n  if (!this.$__isSelected(key)) {\n    return;\n  }\n\n  // $push $addToSet don't need the where clause set\n  if (VERSION_WHERE === (VERSION_WHERE & this.$__.version)) {\n    const value = this.$__getValue(key);\n    if (value != null) where[key] = value;\n  }\n\n  if (VERSION_INC === (VERSION_INC & this.$__.version)) {\n    if (get(delta.$set, key, null) != null) {\n      // Version key is getting set, means we'll increment the doc's version\n      // after a successful save, so we should set the incremented version so\n      // future saves don't fail (gh-5779)\n      ++delta.$set[key];\n    } else {\n      delta.$inc = delta.$inc || {};\n      delta.$inc[key] = 1;\n    }\n  }\n};\n\n/**\n * Signal that we desire an increment of this documents version.\n *\n * #### Example:\n *\n *     const doc = await Model.findById(id);\n *     doc.increment();\n *     await doc.save();\n *\n * @see versionKeys https://mongoosejs.com/docs/guide.html#versionKey\n * @memberOf Model\n * @method increment\n * @api public\n */\n\nModel.prototype.increment = function increment() {\n  this.$__.version = VERSION_ALL;\n  return this;\n};\n\n/**\n * Returns a query object\n *\n * @api private\n * @method $__where\n * @memberOf Model\n * @instance\n */\n\nModel.prototype.$__where = function _where(where) {\n  where || (where = {});\n\n  if (!where._id) {\n    where._id = this._doc._id;\n  }\n\n  if (this._doc._id === void 0) {\n    return new MongooseError('No _id found on document!');\n  }\n\n  return where;\n};\n\n/**\n * Delete this document from the db. Returns a Query instance containing a `deleteOne` operation by this document's `_id`.\n *\n * #### Example:\n *\n *     await product.deleteOne();\n *     await Product.findById(product._id); // null\n *\n * Since `deleteOne()` returns a Query, the `deleteOne()` will **not** execute unless you use either `await`, `.then()`, `.catch()`, or [`.exec()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.exec())\n *\n * #### Example:\n *\n *     product.deleteOne(); // Doesn't do anything\n *     product.deleteOne().exec(); // Deletes the document, returns a promise\n *\n * @return {Query} Query\n * @api public\n */\n\nModel.prototype.deleteOne = function deleteOne(options) {\n  if (typeof options === 'function' ||\n      typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (options.hasOwnProperty('session')) {\n    this.$session(options.session);\n  }\n\n  const self = this;\n  const where = this.$__where();\n  if (where instanceof Error) {\n    throw where;\n  }\n  const query = self.constructor.deleteOne(where, options);\n\n  if (this.$session() != null) {\n    if (!('session' in query.options)) {\n      query.options.session = this.$session();\n    }\n  }\n\n  query.pre(async function queryPreDeleteOne() {\n    await new Promise((resolve, reject) => {\n      self.constructor._middleware.execPre('deleteOne', self, [self], err => {\n        if (err) reject(err);\n        else resolve();\n      });\n    });\n    // Apply custom where conditions _after_ document deleteOne middleware for\n    // consistency with save() - sharding plugin needs to set $where\n    if (self.$where != null) {\n      this.where(self.$where);\n    }\n  });\n  query.pre(function callSubdocPreHooks(cb) {\n    each(self.$getAllSubdocs(), (subdoc, cb) => {\n      subdoc.constructor._middleware.execPre('deleteOne', subdoc, [subdoc], cb);\n    }, cb);\n  });\n  query.pre(function skipIfAlreadyDeleted(cb) {\n    if (self.$__.isDeleted) {\n      return cb(Kareem.skipWrappedFunction());\n    }\n    return cb();\n  });\n  query.post(function callSubdocPostHooks(cb) {\n    each(self.$getAllSubdocs(), (subdoc, cb) => {\n      subdoc.constructor._middleware.execPost('deleteOne', subdoc, [subdoc], {}, cb);\n    }, cb);\n  });\n  query.post(function queryPostDeleteOne(cb) {\n    self.constructor._middleware.execPost('deleteOne', self, [self], {}, cb);\n  });\n\n  return query;\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method $model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.$model = function $model(name) {\n  if (arguments.length === 0) {\n    return this.constructor;\n  }\n  return this[modelDbSymbol].model(name);\n};\n\n/**\n * Returns the model instance used to create this document if no `name` specified.\n * If `name` specified, returns the model with the given `name`.\n *\n * #### Example:\n *\n *     const doc = new Tank({});\n *     doc.$model() === Tank; // true\n *     await doc.$model('User').findById(id);\n *\n * @param {String} [name] model name\n * @method model\n * @api public\n * @return {Model}\n */\n\nModel.prototype.model = Model.prototype.$model;\n\n/**\n * Returns a document with `_id` only if at least one document exists in the database that matches\n * the given `filter`, and `null` otherwise.\n *\n * Under the hood, `MyModel.exists({ answer: 42 })` is equivalent to\n * `MyModel.findOne({ answer: 42 }).select({ _id: 1 }).lean()`\n *\n * #### Example:\n *\n *     await Character.deleteMany({});\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     await Character.exists({ name: /picard/i }); // { _id: ... }\n *     await Character.exists({ name: /riker/i }); // null\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * @param {Object} filter\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n */\n\nModel.exists = function exists(filter, options) {\n  _checkContext(this, 'exists');\n  if (typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.exists() no longer accepts a callback');\n  }\n\n  const query = this.findOne(filter).\n    select({ _id: 1 }).\n    lean().\n    setOptions(options);\n\n  return query;\n};\n\n/**\n * Adds a discriminator type.\n *\n * #### Example:\n *\n *     function BaseSchema() {\n *       Schema.apply(this, arguments);\n *\n *       this.add({\n *         name: String,\n *         createdAt: Date\n *       });\n *     }\n *     util.inherits(BaseSchema, Schema);\n *\n *     const PersonSchema = new BaseSchema();\n *     const BossSchema = new BaseSchema({ department: String });\n *\n *     const Person = mongoose.model('Person', PersonSchema);\n *     const Boss = Person.discriminator('Boss', BossSchema);\n *     new Boss().__t; // \"Boss\". `__t` is the default `discriminatorKey`\n *\n *     const employeeSchema = new Schema({ boss: ObjectId });\n *     const Employee = Person.discriminator('Employee', employeeSchema, 'staff');\n *     new Employee().__t; // \"staff\" because of 3rd argument above\n *\n * @param {String} name discriminator model name\n * @param {Schema} schema discriminator model schema\n * @param {Object|String} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @param {Boolean} [options.overwriteModels=false] by default, Mongoose does not allow you to define a discriminator with the same name as another discriminator. Set this to allow overwriting discriminators with the same name.\n * @param {Boolean} [options.mergeHooks=true] By default, Mongoose merges the base schema's hooks with the discriminator schema's hooks. Set this option to `false` to make Mongoose use the discriminator schema's hooks instead.\n * @param {Boolean} [options.mergePlugins=true] By default, Mongoose merges the base schema's plugins with the discriminator schema's plugins. Set this option to `false` to make Mongoose use the discriminator schema's plugins instead.\n * @return {Model} The newly created discriminator model\n * @api public\n */\n\nModel.discriminator = function(name, schema, options) {\n  let model;\n  if (typeof name === 'function') {\n    model = name;\n    name = utils.getFunctionName(model);\n    if (!(model.prototype instanceof Model)) {\n      throw new MongooseError('The provided class ' + name + ' must extend Model');\n    }\n  }\n\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n  const mergePlugins = typeof options.mergePlugins === 'boolean' ? options.mergePlugins : true;\n  const overwriteModels = typeof options.overwriteModels === 'boolean' ? options.overwriteModels : false;\n\n  _checkContext(this, 'discriminator');\n\n  if (utils.isObject(schema) && !schema.instanceOfSchema) {\n    schema = new Schema(schema);\n  }\n  if (schema instanceof Schema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this, name, schema, value, mergePlugins, options.mergeHooks, overwriteModels);\n  if (this.db.models[name] && !schema.options.overwriteModels && !overwriteModels) {\n    throw new OverwriteModelError(name);\n  }\n\n  schema.$isRootDiscriminator = true;\n  schema.$globalPluginsApplied = true;\n\n  model = this.db.model(model || name, schema, this.$__collection.name);\n  this.discriminators[name] = model;\n  const d = this.discriminators[name];\n  Object.setPrototypeOf(d.prototype, this.prototype);\n  Object.defineProperty(d, 'baseModelName', {\n    value: this.modelName,\n    configurable: true,\n    writable: false\n  });\n\n  // apply methods and statics\n  applyMethods(d, schema);\n  applyStatics(d, schema);\n\n  if (this[subclassedSymbol] != null) {\n    for (const submodel of this[subclassedSymbol]) {\n      submodel.discriminators = submodel.discriminators || {};\n      submodel.discriminators[name] =\n        model.__subclass(model.db, schema, submodel.collection.name);\n    }\n  }\n\n  return d;\n};\n\n/**\n * Make sure `this` is a model\n * @api private\n */\n\nfunction _checkContext(ctx, fnName) {\n  // Check context, because it is easy to mistakenly type\n  // `new Model.discriminator()` and get an incomprehensible error\n  if (ctx == null || ctx === global) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are calling `MyModel.' + fnName + '()` ' +\n      'where `MyModel` is a Mongoose model.');\n  } else if (ctx[modelSymbol] == null) {\n    throw new MongooseError('`Model.' + fnName + '()` cannot run without a ' +\n      'model as `this`. Make sure you are not calling ' +\n      '`new Model.' + fnName + '()`');\n  }\n}\n\n// Model (class) features\n\n/*!\n * Give the constructor the ability to emit events.\n */\n\nfor (const i in EventEmitter.prototype) {\n  Model[i] = EventEmitter.prototype[i];\n}\n\n/**\n * This function is responsible for initializing the underlying connection in MongoDB based on schema options.\n * This function performs the following operations:\n *\n * - `createCollection()` unless [`autoCreate`](https://mongoosejs.com/docs/guide.html#autoCreate) option is turned off\n * - `ensureIndexes()` unless [`autoIndex`](https://mongoosejs.com/docs/guide.html#autoIndex) option is turned off\n * - `createSearchIndex()` on all schema search indexes if `autoSearchIndex` is enabled.\n *\n * Mongoose calls this function automatically when a model is a created using\n * [`mongoose.model()`](https://mongoosejs.com/docs/api/mongoose.html#Mongoose.prototype.model()) or\n * [`connection.model()`](https://mongoosejs.com/docs/api/connection.html#Connection.prototype.model()), so you\n * don't need to call `init()` to trigger index builds.\n *\n * However, you _may_ need to call `init()`  to get back a promise that will resolve when your indexes are finished.\n * Calling `await Model.init()` is helpful if you need to wait for indexes to build before continuing.\n * For example, if you want to wait for unique indexes to build before continuing with a test case.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     // This calls `Event.init()` implicitly, so you don't need to call\n *     // `Event.init()` on your own.\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     await Event.init();\n *     console.log('Indexes are done building!');\n *\n * @api public\n * @returns {Promise}\n */\n\nModel.init = function init() {\n  _checkContext(this, 'init');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.init() no longer accepts a callback');\n  }\n\n  this.schema.emit('init', this);\n\n  if (this.$init != null) {\n    return this.$init;\n  }\n\n  const conn = this.db;\n  const _ensureIndexes = async() => {\n    const autoIndex = utils.getOption(\n      'autoIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoIndex) {\n      return;\n    }\n    return await this.ensureIndexes({ _automatic: true });\n  };\n  const _createSearchIndexes = async() => {\n    const autoSearchIndex = utils.getOption(\n      'autoSearchIndex',\n      this.schema.options,\n      conn.config,\n      conn.base.options\n    );\n    if (!autoSearchIndex) {\n      return;\n    }\n\n    return await this.createSearchIndexes();\n  };\n  const _createCollection = async() => {\n    let autoCreate = utils.getOption(\n      'autoCreate',\n      this.schema.options,\n      conn.config\n      // No base.options here because we don't want to take the base value if the connection hasn't\n      // set it yet\n    );\n    if (autoCreate == null) {\n      // `autoCreate` may later be set when the connection is opened, so wait for connect before checking\n      await conn._waitForConnect(true);\n      autoCreate = utils.getOption(\n        'autoCreate',\n        this.schema.options,\n        conn.config,\n        conn.base.options\n      );\n    }\n\n    if (!autoCreate) {\n      return;\n    }\n\n    return await this.createCollection();\n  };\n\n  this.$init = _createCollection().\n    then(() => _ensureIndexes()).\n    then(() => _createSearchIndexes());\n\n  const _catch = this.$init.catch;\n  const _this = this;\n  this.$init.catch = function() {\n    _this.$caught = true;\n    return _catch.apply(_this.$init, arguments);\n  };\n\n  return this.$init;\n};\n\n\n/**\n * Create the collection for this model. By default, if no indexes are specified,\n * mongoose will not create the collection for the model until any documents are\n * created. Use this method to create the collection explicitly.\n *\n * Note 1: You may need to call this before starting a transaction\n * See https://www.mongodb.com/docs/manual/core/transactions/#transactions-and-operations\n *\n * Note 2: You don't have to call this if your schema contains index or unique field.\n * In that case, just use `Model.init()`\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String })\n *     const User = mongoose.model('User', userSchema);\n *\n *     User.createCollection().then(function(collection) {\n *       console.log('Collection is created!');\n *     });\n *\n * @api public\n * @param {Object} [options] see [MongoDB driver docs](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createCollection)\n * @returns {Promise}\n */\n\nModel.createCollection = async function createCollection(options) {\n  _checkContext(this, 'createCollection');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createCollection() no longer accepts a callback');\n  }\n\n  const shouldSkip = await new Promise((resolve, reject) => {\n    this.hooks.execPre('createCollection', this, [options], (err) => {\n      if (err != null) {\n        if (err instanceof Kareem.skipWrappedFunction) {\n          return resolve(true);\n        }\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  const collectionOptions = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collectionOptions;\n  if (collectionOptions != null) {\n    options = Object.assign({}, collectionOptions, options);\n  }\n\n  const schemaCollation = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.collation;\n  if (schemaCollation != null) {\n    options = Object.assign({ collation: schemaCollation }, options);\n  }\n  const capped = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.capped;\n  if (capped != null) {\n    if (typeof capped === 'number') {\n      options = Object.assign({ capped: true, size: capped }, options);\n    } else if (typeof capped === 'object') {\n      options = Object.assign({ capped: true }, capped, options);\n    }\n  }\n  const timeseries = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.timeseries;\n  if (timeseries != null) {\n    options = Object.assign({ timeseries }, options);\n    if (options.expireAfterSeconds != null) {\n      // do nothing\n    } else if (options.expires != null) {\n      utils.expires(options);\n    } else if (this.schema.options.expireAfterSeconds != null) {\n      options.expireAfterSeconds = this.schema.options.expireAfterSeconds;\n    } else if (this.schema.options.expires != null) {\n      options.expires = this.schema.options.expires;\n      utils.expires(options);\n    }\n  }\n\n  const clusteredIndex = this &&\n    this.schema &&\n    this.schema.options &&\n    this.schema.options.clusteredIndex;\n  if (clusteredIndex != null) {\n    options = Object.assign({ clusteredIndex: { ...clusteredIndex, unique: true } }, options);\n  }\n\n  try {\n    if (!shouldSkip) {\n      await this.db.createCollection(this.$__collection.collectionName, options);\n    }\n  } catch (err) {\n    if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n      await new Promise((resolve, reject) => {\n        const _opts = { error: err };\n        this.hooks.execPost('createCollection', this, [null], _opts, (err) => {\n          if (err != null) {\n            return reject(err);\n          }\n          resolve();\n        });\n      });\n    }\n  }\n\n  await new Promise((resolve, reject) => {\n    this.hooks.execPost('createCollection', this, [this.$__collection], (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  return this.$__collection;\n};\n\n/**\n * Makes the indexes in MongoDB match the indexes defined in this model's\n * schema. This function will drop any indexes that are not defined in\n * the model's schema except the `_id` index, and build any indexes that\n * are in your schema but not in MongoDB.\n *\n * See the [introductory blog post](https://thecodebarbarian.com/whats-new-in-mongoose-5-2-syncindexes)\n * for more information.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.collection.createIndex({ age: 1 }); // Index is not in schema\n *     // Will drop the 'age' index and create an index on `name`\n *     await Customer.syncIndexes();\n *\n * You should be careful about running `syncIndexes()` on production applications under heavy load,\n * because index builds are expensive operations, and unexpected index drops can lead to degraded\n * performance. Before running `syncIndexes()`, you can use the [`diffIndexes()` function](#Model.diffIndexes())\n * to check what indexes `syncIndexes()` will drop and create.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of strings containing names of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options] options to pass to `ensureIndexes()`\n * @param {Boolean} [options.background=null] if specified, overrides each index's `background` property\n * @param {Boolean} [options.hideIndexes=false] set to `true` to hide indexes instead of dropping. Requires MongoDB server 4.4 or higher\n * @return {Promise}\n * @api public\n */\n\nModel.syncIndexes = async function syncIndexes(options) {\n  _checkContext(this, 'syncIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const autoCreate = options?.autoCreate ?? this.schema.options?.autoCreate ?? this.db.config.autoCreate ?? true;\n\n  if (autoCreate) {\n    try {\n      await this.createCollection();\n    } catch (err) {\n      if (err != null && (err.name !== 'MongoServerError' || err.code !== 48)) {\n        throw err;\n      }\n    }\n  }\n\n  const diffIndexesResult = await this.diffIndexes({ indexOptionsToCreate: true });\n  const dropped = await this.cleanIndexes({ ...options, toDrop: diffIndexesResult.toDrop });\n  await this.createIndexes({ ...options, toCreate: diffIndexesResult.toCreate });\n\n  return dropped;\n};\n\n/**\n * Create an [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.createSearchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *\n * @param {Object} description index options, including `name` and `definition`\n * @param {String} description.name\n * @param {Object} description.definition\n * @return {Promise}\n * @api public\n */\n\nModel.createSearchIndex = async function createSearchIndex(description) {\n  _checkContext(this, 'createSearchIndex');\n\n  return await this.$__collection.createSearchIndex(description);\n};\n\n/**\n * Update an existing [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/).\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.updateSearchIndex('test', { mappings: { dynamic: true } });\n *\n * @param {String} name\n * @param {Object} definition\n * @return {Promise}\n * @api public\n */\n\nModel.updateSearchIndex = async function updateSearchIndex(name, definition) {\n  _checkContext(this, 'updateSearchIndex');\n\n  return await this.$__collection.updateSearchIndex(name, definition);\n};\n\n/**\n * Delete an existing [Atlas search index](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) by name.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *     await Customer.dropSearchIndex('test');\n *\n * @param {String} name\n * @return {Promise}\n * @api public\n */\n\nModel.dropSearchIndex = async function dropSearchIndex(name) {\n  _checkContext(this, 'dropSearchIndex');\n\n  return await this.$__collection.dropSearchIndex(name);\n};\n\n/**\n * List all [Atlas search indexes](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) on this model's collection.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({ name: { type: String, unique: true } });\n *     const Customer = mongoose.model('Customer', schema);\n *\n *     await Customer.createSearchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *     const res = await Customer.listSearchIndexes(); // Includes `[{ name: 'test' }]`\n *\n * @param {Object} [options]\n * @return {Promise<Array>}\n * @api public\n */\n\nModel.listSearchIndexes = async function listSearchIndexes(options) {\n  _checkContext(this, 'listSearchIndexes');\n\n  const cursor = await this.$__collection.listSearchIndexes(options);\n\n  return await cursor.toArray();\n};\n\n/**\n * Does a dry-run of `Model.syncIndexes()`, returning the indexes that `syncIndexes()` would drop and create if you were to run `syncIndexes()`.\n *\n * #### Example:\n *\n *     const { toDrop, toCreate } = await Model.diffIndexes();\n *     toDrop; // Array of strings containing names of indexes that `syncIndexes()` will drop\n *     toCreate; // Array of index specs containing the keys of indexes that `syncIndexes()` will create\n *\n * @param {Object} [options]\n * @param {Boolean} [options.indexOptionsToCreate=false] If true, `toCreate` will include both the index spec and the index options, not just the index spec\n * @return {Promise<Object>} contains the indexes that would be dropped in MongoDB and indexes that would be created in MongoDB as `{ toDrop: string[], toCreate: string[] }`.\n */\n\nModel.diffIndexes = async function diffIndexes(options) {\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.syncIndexes() no longer accepts a callback');\n  }\n\n  const model = this;\n\n  let dbIndexes = await model.listIndexes().catch(err => {\n    if (err.codeName == 'NamespaceNotFound') {\n      return undefined;\n    }\n    throw err;\n  });\n  if (dbIndexes === undefined) {\n    dbIndexes = [];\n  }\n  dbIndexes = getRelatedDBIndexes(model, dbIndexes);\n\n  const schema = model.schema;\n  const schemaIndexes = getRelatedSchemaIndexes(model, schema.indexes());\n\n  const toDrop = getIndexesToDrop(schema, schemaIndexes, dbIndexes);\n  const toCreate = getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options);\n\n  return { toDrop, toCreate };\n};\n\nfunction getIndexesToCreate(schema, schemaIndexes, dbIndexes, toDrop, options) {\n  const toCreate = [];\n  const indexOptionsToCreate = options?.indexOptionsToCreate ?? false;\n\n  for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n    let found = false;\n\n    const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n\n    for (const index of dbIndexes) {\n      if (isDefaultIdIndex(index)) {\n        continue;\n      }\n      if (\n        isIndexEqual(schemaIndexKeysObject, options, index) &&\n        !toDrop.includes(index.name)\n      ) {\n        found = true;\n        break;\n      }\n    }\n\n    if (!found) {\n      if (indexOptionsToCreate) {\n        toCreate.push([schemaIndexKeysObject, schemaIndexOptions]);\n      } else {\n        toCreate.push(schemaIndexKeysObject);\n      }\n    }\n  }\n\n  return toCreate;\n}\n\nfunction getIndexesToDrop(schema, schemaIndexes, dbIndexes) {\n  const toDrop = [];\n\n  for (const dbIndex of dbIndexes) {\n    let found = false;\n    // Never try to drop `_id` index, MongoDB server doesn't allow it\n    if (isDefaultIdIndex(dbIndex)) {\n      continue;\n    }\n    // Timeseries collections have a default index on { timeField: 1, metaField: 1 }.\n    if (isTimeseriesIndex(dbIndex, schema.options)) {\n      continue;\n    }\n\n    for (const [schemaIndexKeysObject, schemaIndexOptions] of schemaIndexes) {\n      const options = decorateDiscriminatorIndexOptions(schema, clone(schemaIndexOptions));\n      applySchemaCollation(schemaIndexKeysObject, options, schema.options);\n\n      if (isIndexEqual(schemaIndexKeysObject, options, dbIndex)) {\n        found = true;\n        break;\n      }\n    }\n\n    if (found) {\n      continue;\n    }\n\n    toDrop.push(dbIndex.name);\n  }\n\n  return toDrop;\n}\n/**\n * Deletes all indexes that aren't defined in this model's schema. Used by\n * `syncIndexes()`.\n *\n * The returned promise resolves to a list of the dropped indexes' names as an array\n *\n * @param {Object} [options]\n * @param {Array<String>} [options.toDrop] if specified, contains a list of index names to drop\n * @param {Boolean} [options.hideIndexes=false] set to `true` to hide indexes instead of dropping. Requires MongoDB server 4.4 or higher\n * @return {Promise<Array<String>>} list of dropped or hidden index names\n * @api public\n */\n\nModel.cleanIndexes = async function cleanIndexes(options) {\n  _checkContext(this, 'cleanIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.cleanIndexes() no longer accepts a callback');\n  }\n  const model = this;\n\n  if (Array.isArray(options && options.toDrop)) {\n    const res = await _dropIndexes(options.toDrop, model, options);\n    return res;\n  }\n\n  const res = await model.diffIndexes();\n  return await _dropIndexes(res.toDrop, model, options);\n};\n\nasync function _dropIndexes(toDrop, model, options) {\n  if (toDrop.length === 0) {\n    return [];\n  }\n\n  const collection = model.$__collection;\n  if (options && options.hideIndexes) {\n    await Promise.all(toDrop.map(indexName => {\n      return model.db.db.command({\n        collMod: collection.collectionName,\n        index: { name: indexName, hidden: true }\n      });\n    }));\n  } else {\n    await Promise.all(toDrop.map(indexName => collection.dropIndex(indexName)));\n  }\n\n  return toDrop;\n}\n\n/**\n * Lists the indexes currently defined in MongoDB. This may or may not be\n * the same as the indexes defined in your schema depending on whether you\n * use the [`autoIndex` option](https://mongoosejs.com/docs/guide.html#autoIndex) and if you\n * build indexes manually.\n *\n * @return {Promise}\n * @api public\n */\n\nModel.listIndexes = async function listIndexes() {\n  _checkContext(this, 'listIndexes');\n  if (typeof arguments[0] === 'function') {\n    throw new MongooseError('Model.listIndexes() no longer accepts a callback');\n  }\n\n  if (this.$__collection.buffer) {\n    await new Promise(resolve => {\n      this.$__collection.addQueue(resolve);\n    });\n  }\n\n  return this.$__collection.listIndexes().toArray();\n};\n\n/**\n * Sends `createIndex` commands to mongo for each index declared in the schema.\n * The `createIndex` commands are sent in series.\n *\n * #### Example:\n *\n *     await Event.ensureIndexes();\n *\n * After completion, an `index` event is emitted on this `Model` passing an error if one occurred.\n *\n * #### Example:\n *\n *     const eventSchema = new Schema({ thing: { type: 'string', unique: true } })\n *     const Event = mongoose.model('Event', eventSchema);\n *\n *     Event.on('index', function (err) {\n *       if (err) console.error(err); // error occurred during index creation\n *     });\n *\n * _NOTE: It is not recommended that you run this in production. Index creation may impact database performance depending on your load. Use with caution._\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.ensureIndexes = async function ensureIndexes(options) {\n  _checkContext(this, 'ensureIndexes');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.ensureIndexes() no longer accepts a callback');\n  }\n\n  await new Promise((resolve, reject) => {\n    _ensureIndexes(this, options, (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n};\n\n/**\n * Similar to `ensureIndexes()`, except for it uses the [`createIndex`](https://mongodb.github.io/node-mongodb-native/4.9/classes/Db.html#createIndex)\n * function.\n *\n * @param {Object} [options] internal options\n * @return {Promise}\n * @api public\n */\n\nModel.createIndexes = async function createIndexes(options) {\n  _checkContext(this, 'createIndexes');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function') {\n    throw new MongooseError('Model.createIndexes() no longer accepts a callback');\n  }\n\n  return this.ensureIndexes(options);\n};\n\n\n/*!\n * ignore\n */\n\nfunction _ensureIndexes(model, options, callback) {\n  const indexes = Array.isArray(options?.toCreate) ? options.toCreate : model.schema.indexes();\n  let indexError;\n\n  options = options || {};\n  const done = function(err) {\n    if (err && !model.$caught) {\n      model.emit('error', err);\n    }\n    model.emit('index', err || indexError);\n    callback && callback(err || indexError);\n  };\n\n  for (const index of indexes) {\n    if (isDefaultIdIndex(index)) {\n      utils.warn('mongoose: Cannot specify a custom index on `_id` for ' +\n        'model name \"' + model.modelName + '\", ' +\n        'MongoDB does not allow overwriting the default `_id` index. See ' +\n        'https://bit.ly/mongodb-id-index');\n    }\n  }\n\n  if (!indexes.length) {\n    immediate(function() {\n      done();\n    });\n    return;\n  }\n  // Indexes are created one-by-one to support how MongoDB < 2.4 deals\n  // with background indexes.\n\n  const indexSingleDone = function(err, fields, options, name) {\n    model.emit('index-single-done', err, fields, options, name);\n  };\n  const indexSingleStart = function(fields, options) {\n    model.emit('index-single-start', fields, options);\n  };\n\n  const baseSchema = model.schema._baseSchema;\n  const baseSchemaIndexes = baseSchema ? baseSchema.indexes() : [];\n\n  immediate(function() {\n    // If buffering is off, do this manually.\n    if (options._automatic && !model.collection.collection) {\n      model.collection.addQueue(create, []);\n    } else {\n      create();\n    }\n  });\n\n\n  function create() {\n    if (options._automatic) {\n      if (model.schema.options.autoIndex === false ||\n          (model.schema.options.autoIndex == null && model.db.config.autoIndex === false)) {\n        return done();\n      }\n    }\n\n    const index = indexes.shift();\n    if (!index) {\n      return done();\n    }\n    if (options._automatic && index[1]._autoIndex === false) {\n      return create();\n    }\n\n    if (baseSchemaIndexes.find(i => utils.deepEqual(i, index))) {\n      return create();\n    }\n\n    const indexFields = clone(index[0]);\n    const indexOptions = clone(index[1]);\n\n    delete indexOptions._autoIndex;\n    decorateDiscriminatorIndexOptions(model.schema, indexOptions);\n    applyWriteConcern(model.schema, indexOptions);\n    applySchemaCollation(indexFields, indexOptions, model.schema.options);\n\n    indexSingleStart(indexFields, options);\n\n    if ('background' in options) {\n      indexOptions.background = options.background;\n    }\n\n    // Just in case `createIndex()` throws a sync error\n    let promise = null;\n    try {\n      promise = model.collection.createIndex(indexFields, indexOptions);\n    } catch (err) {\n      if (!indexError) {\n        indexError = err;\n      }\n      if (!model.$caught) {\n        model.emit('error', err);\n      }\n\n      indexSingleDone(err, indexFields, indexOptions);\n      create();\n      return;\n    }\n\n    promise.then(\n      name => {\n        indexSingleDone(null, indexFields, indexOptions, name);\n        create();\n      },\n      err => {\n        if (!indexError) {\n          indexError = err;\n        }\n        if (!model.$caught) {\n          model.emit('error', err);\n        }\n\n        indexSingleDone(err, indexFields, indexOptions);\n        create();\n      }\n    );\n  }\n}\n\n/**\n * Creates all [Atlas search indexes](https://www.mongodb.com/docs/atlas/atlas-search/create-index/) defined in this model's schema.\n * This function only works when connected to MongoDB Atlas.\n *\n * #### Example:\n *\n *     const schema = new Schema({\n *       name: String,\n *       description: String\n *     });\n *     schema.searchIndex({ name: 'test', definition: { mappings: { dynamic: true } } });\n *     const Product = mongoose.model('Product', schema);\n *\n *     // Creates the search index defined in the schema\n *     await Product.createSearchIndexes();\n *\n * @api public\n * @return {Promise} resolves to the results of creating the search indexes\n */\n\nModel.createSearchIndexes = async function createSearchIndexes() {\n  _checkContext(this, 'createSearchIndexes');\n  const results = [];\n  for (const searchIndex of this.schema._searchIndexes) {\n    results.push(await this.createSearchIndex(searchIndex));\n  }\n  return results;\n};\n\n/**\n * Schema the model uses.\n *\n * @property schema\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.schema;\n\n/**\n * Connection instance the model uses.\n *\n * @property db\n * @static\n * @api public\n * @memberOf Model\n */\n\nModel.db;\n\n/**\n * Collection the model uses.\n *\n * @property collection\n * @api public\n * @memberOf Model\n */\n\nModel.collection;\n\n/**\n * Internal collection the model uses.\n *\n * @property collection\n * @api private\n * @memberOf Model\n */\nModel.$__collection;\n\n/**\n * Base Mongoose instance the model uses.\n *\n * @property base\n * @api public\n * @memberOf Model\n */\n\nModel.base;\n\n/**\n * Registered discriminators for this model.\n *\n * @property discriminators\n * @api public\n * @memberOf Model\n */\n\nModel.discriminators;\n\n/**\n * Translate any aliases fields/conditions so the final query or document object is pure\n *\n * #### Example:\n *\n *     await Character.find(Character.translateAliases({\n *        '': 'Eddard Stark' // Alias for 'name'\n *     });\n *\n * By default, `translateAliases()` overwrites raw fields with aliased fields.\n * So if `n` is an alias for `name`, `{ n: 'alias', name: 'raw' }` will resolve to `{ name: 'alias' }`.\n * However, you can set the `errorOnDuplicates` option to throw an error if there are potentially conflicting paths.\n * The `translateAliases` option for queries uses `errorOnDuplicates`.\n *\n * #### Note:\n *\n * Only translate arguments of object type anything else is returned raw\n *\n * @param {Object} fields fields/conditions that may contain aliased keys\n * @param {Boolean} [errorOnDuplicates] if true, throw an error if there's both a key and an alias for that key in `fields`\n * @return {Object} the translated 'pure' fields/conditions\n */\nModel.translateAliases = function translateAliases(fields, errorOnDuplicates) {\n  _checkContext(this, 'translateAliases');\n\n  const translate = (key, value) => {\n    let alias;\n    const translated = [];\n    const fieldKeys = key.split('.');\n    let currentSchema = this.schema;\n    for (const i in fieldKeys) {\n      const name = fieldKeys[i];\n      if (currentSchema && currentSchema.aliases[name]) {\n        alias = currentSchema.aliases[name];\n        if (errorOnDuplicates && alias in fields) {\n          throw new MongooseError(`Provided object has both field \"${name}\" and its alias \"${alias}\"`);\n        }\n        // Alias found,\n        translated.push(alias);\n      } else {\n        alias = name;\n        // Alias not found, so treat as un-aliased key\n        translated.push(name);\n      }\n\n      // Check if aliased path is a schema\n      if (currentSchema && currentSchema.paths[alias]) {\n        currentSchema = currentSchema.paths[alias].schema;\n      }\n      else\n        currentSchema = null;\n    }\n\n    const translatedKey = translated.join('.');\n    if (fields instanceof Map)\n      fields.set(translatedKey, value);\n    else\n      fields[translatedKey] = value;\n\n    if (translatedKey !== key) {\n      // We'll be using the translated key instead\n      if (fields instanceof Map) {\n        // Delete from map\n        fields.delete(key);\n      } else {\n        // Delete from object\n        delete fields[key]; // We'll be using the translated key instead\n      }\n    }\n    return fields;\n  };\n\n  if (typeof fields === 'object') {\n    // Fields is an object (query conditions or document fields)\n    if (fields instanceof Map) {\n      // A Map was supplied\n      for (const field of new Map(fields)) {\n        fields = translate(field[0], field[1]);\n      }\n    } else {\n      // Infer a regular object was supplied\n      for (const key of Object.keys(fields)) {\n        fields = translate(key, fields[key]);\n        if (key[0] === '$') {\n          if (Array.isArray(fields[key])) {\n            for (const i in fields[key]) {\n              // Recursively translate nested queries\n              fields[key][i] = this.translateAliases(fields[key][i]);\n            }\n          } else {\n            this.translateAliases(fields[key]);\n          }\n        }\n      }\n    }\n\n    return fields;\n  } else {\n    // Don't know typeof fields\n    return fields;\n  }\n};\n\n/**\n * Deletes the first document that matches `conditions` from the collection.\n * It returns an object with the property `deletedCount` indicating how many documents were deleted.\n *\n * #### Example:\n *\n *     await Character.deleteOne({ name: 'Eddard Stark' }); // returns {deletedCount: 1}\n *\n * #### Note:\n *\n * This function triggers `deleteOne` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteOne = function deleteOne(conditions, options) {\n  _checkContext(this, 'deleteOne');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.prototype.deleteOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteOne(conditions);\n};\n\n/**\n * Deletes all of the documents that match `conditions` from the collection.\n * It returns an object with the property `deletedCount` containing the number of documents deleted.\n *\n * #### Example:\n *\n *     await Character.deleteMany({ name: /Stark/, age: { $gte: 18 } }); // returns {deletedCount: x} where x is the number of documents deleted.\n *\n * #### Note:\n *\n * This function triggers `deleteMany` query hooks. Read the\n * [middleware docs](https://mongoosejs.com/docs/middleware.html#naming) to learn more.\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.deleteMany = function deleteMany(conditions, options) {\n  _checkContext(this, 'deleteMany');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.deleteMany() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.setOptions(options);\n\n  return mq.deleteMany(conditions);\n};\n\n/**\n * Finds documents.\n *\n * Mongoose casts the `filter` to match the model's schema before the command is sent.\n * See our [query casting tutorial](https://mongoosejs.com/docs/tutorials/query_casting.html) for\n * more information on how Mongoose casts `filter`.\n *\n * #### Example:\n *\n *     // find all documents\n *     await MyModel.find({});\n *\n *     // find all documents named john and at least 18\n *     await MyModel.find({ name: 'john', age: { $gte: 18 } }).exec();\n *\n *     // executes, name LIKE john and only selecting the \"name\" and \"friends\" fields\n *     await MyModel.find({ name: /john/i }, 'name friends').exec();\n *\n *     // passing options\n *     await MyModel.find({ name: /john/i }, null, { skip: 10 }).exec();\n *\n * @param {Object|ObjectId} filter\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see query casting https://mongoosejs.com/docs/tutorials/query_casting.html\n * @api public\n */\n\nModel.find = function find(conditions, projection, options) {\n  _checkContext(this, 'find');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.find() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.find(conditions);\n};\n\n/**\n * Finds a single document by its _id field. `findById(id)` is equivalent to `findOne({ _id: id })`.\n *\n * The `id` is cast based on the Schema before sending the command.\n *\n * This function triggers the following middleware.\n *\n * - `findOne()`\n *\n * #### Example:\n *\n *     // Find the adventure with the given `id`, or `null` if not found\n *     await Adventure.findById(id).exec();\n *\n *     // select only the adventures name and length\n *     await Adventure.findById(id, 'name length').exec();\n *\n * @param {Any} id value of `_id` to query by\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @see findById in Mongoose https://masteringjs.io/tutorials/mongoose/find-by-id\n * @api public\n */\n\nModel.findById = function findById(id, projection, options) {\n  _checkContext(this, 'findById');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findById() no longer accepts a callback');\n  }\n\n  return this.findOne({ _id: id }, projection, options);\n};\n\n/**\n * Finds one document.\n *\n * The `conditions` are cast to their respective SchemaTypes before the command is sent.\n *\n * *Note:* `conditions` is optional, and if `conditions` is null or undefined,\n * mongoose will send an empty `findOne` command to MongoDB, which will return\n * an arbitrary document. If you're querying by `_id`, use `findById()` instead.\n *\n * #### Example:\n *\n *     // Find one adventure whose `country` is 'Croatia', otherwise `null`\n *     await Adventure.findOne({ country: 'Croatia' }).exec();\n *\n *     // Model.findOne() no longer accepts a callback\n *\n *     // Select only the adventures name and length\n *     await Adventure.findOne({ country: 'Croatia' }, 'name length').exec();\n *\n * @param {Object} [conditions]\n * @param {Object|String|String[]} [projection] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see field selection https://mongoosejs.com/docs/api/query.html#Query.prototype.select()\n * @see lean queries https://mongoosejs.com/docs/tutorials/lean.html\n * @api public\n */\n\nModel.findOne = function findOne(conditions, projection, options) {\n  _checkContext(this, 'findOne');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOne() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(projection);\n  mq.setOptions(options);\n\n  return mq.findOne(conditions);\n};\n\n/**\n * Estimates the number of documents in the MongoDB collection. Faster than\n * using `countDocuments()` for large collections because\n * `estimatedDocumentCount()` uses collection metadata rather than scanning\n * the entire collection.\n *\n * #### Example:\n *\n *     const numAdventures = await Adventure.estimatedDocumentCount();\n *\n * @param {Object} [options]\n * @return {Query}\n * @api public\n */\n\nModel.estimatedDocumentCount = function estimatedDocumentCount(options) {\n  _checkContext(this, 'estimatedDocumentCount');\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n\n  return mq.estimatedDocumentCount(options);\n};\n\n/**\n * Counts number of documents matching `filter` in a database collection.\n *\n * #### Example:\n *\n *     const count = await Adventure.countDocuments({ type: 'jungle' });\n *     console.log('there are %d jungle adventures', count);\n *\n * If you want to count all documents in a large collection,\n * use the [`estimatedDocumentCount()` function](https://mongoosejs.com/docs/api/model.html#Model.estimatedDocumentCount())\n * instead. If you call `countDocuments({})`, MongoDB will always execute\n * a full collection scan and **not** use any indexes.\n *\n * The `countDocuments()` function is similar to `count()`, but there are a\n * [few operators that `countDocuments()` does not support](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#countDocuments).\n * Below are the operators that `count()` supports but `countDocuments()` does not,\n * and the suggested replacement:\n *\n * - `$where`: [`$expr`](https://www.mongodb.com/docs/manual/reference/operator/query/expr/)\n * - `$near`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$center`](https://www.mongodb.com/docs/manual/reference/operator/query/center/#op._S_center)\n * - `$nearSphere`: [`$geoWithin`](https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/) with [`$centerSphere`](https://www.mongodb.com/docs/manual/reference/operator/query/centerSphere/#op._S_centerSphere)\n *\n * @param {Object} filter\n * @return {Query}\n * @api public\n */\n\nModel.countDocuments = function countDocuments(conditions, options) {\n  _checkContext(this, 'countDocuments');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.countDocuments() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n\n  return mq.countDocuments(conditions);\n};\n\n\n/**\n * Creates a Query for a `distinct` operation.\n *\n * #### Example:\n *\n *     const query = Link.distinct('url');\n *     query.exec();\n *\n * @param {String} field\n * @param {Object} [conditions] optional\n * @param {Object} [options] optional\n * @return {Query}\n * @api public\n */\n\nModel.distinct = function distinct(field, conditions, options) {\n  _checkContext(this, 'distinct');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.distinct() no longer accepts a callback');\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  if (options != null) {\n    mq.setOptions(options);\n  }\n\n  return mq.distinct(field, conditions);\n};\n\n/**\n * Creates a Query, applies the passed conditions, and returns the Query.\n *\n * For example, instead of writing:\n *\n *     User.find({ age: { $gte: 21, $lte: 65 } });\n *\n * we can instead write:\n *\n *     User.where('age').gte(21).lte(65).exec();\n *\n * Since the Query class also supports `where` you can continue chaining\n *\n *     User\n *     .where('age').gte(21).lte(65)\n *     .where('name', /^b/i)\n *     ... etc\n *\n * @param {String} path\n * @param {Object} [val] optional value\n * @return {Query}\n * @api public\n */\n\nModel.where = function where(path, val) {\n  _checkContext(this, 'where');\n\n  void val; // eslint\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.where.apply(mq, arguments);\n};\n\n/**\n * Creates a `Query` and specifies a `$where` condition.\n *\n * Sometimes you need to query for things in mongodb using a JavaScript expression. You can do so via `find({ $where: javascript })`, or you can use the mongoose shortcut method $where via a Query chain or from your mongoose Model.\n *\n *     Blog.$where('this.username.indexOf(\"val\") !== -1').exec(function (err, docs) {});\n *\n * @param {String|Function} argument is a javascript string or anonymous function\n * @method $where\n * @memberOf Model\n * @return {Query}\n * @see Query.$where https://mongoosejs.com/docs/api/query.html#Query.prototype.$where\n * @api public\n */\n\nModel.$where = function $where() {\n  _checkContext(this, '$where');\n\n  const mq = new this.Query({}, {}, this, this.$__collection).find({});\n  return mq.$where.apply(mq, arguments);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command.\n *\n * Finds a matching document, updates it according to the `update` arg, passing any `options`. A Query object is returned.\n *\n * #### Example:\n *\n *     A.findOneAndUpdate(filter, update, options);  // returns Query\n *     A.findOneAndUpdate(filter, update);           // returns Query\n *     A.findOneAndUpdate(filter);                   // returns Query\n *     A.findOneAndUpdate();                         // returns Query\n *\n *     // Other supported syntaxes\n *     // Note that calling `Query#findOneAndUpdate()` with 1 arg will treat the arg as `update`, NOT `filter`\n *     A.find(filter).findOneAndUpdate(update);\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     const query = { name: 'borne' };\n *     Model.findOneAndUpdate(query, { name: 'jason bourne' }, options);\n *\n *     // is sent as\n *     Model.findOneAndUpdate(query, { $set: { name: 'jason bourne' }}, options);\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation that\n * you can enable by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id);\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} [conditions]\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.fields] Field selection. Equivalent to `.select(fields).findOneAndUpdate()`\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Tutorial https://mongoosejs.com/docs/tutorials/findoneandupdate.html\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findOneAndUpdate = function(conditions, update, options) {\n  _checkContext(this, 'findOneAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndUpdate() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.fields || options.projection;\n  }\n\n  update = clone(update, {\n    depopulate: true,\n    _isNested: true\n  });\n\n  decorateUpdateWithVersionKey(update, options, this.schema.options.versionKey);\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndUpdate(conditions, update, options);\n};\n\n/**\n * Issues a mongodb findOneAndUpdate command by a document's _id field.\n * `findByIdAndUpdate(id, ...)` is equivalent to `findOneAndUpdate({ _id: id }, ...)`.\n *\n * Finds a matching document, updates it according to the `update` arg,\n * passing any `options`, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndUpdate()`\n *\n * #### Example:\n *\n *     A.findByIdAndUpdate(id, update, options)  // returns Query\n *     A.findByIdAndUpdate(id, update)           // returns Query\n *     A.findByIdAndUpdate()                     // returns Query\n *\n * #### Note:\n *\n * All top level update keys which are not `atomic` operation names are treated as set operations:\n *\n * #### Example:\n *\n *     Model.findByIdAndUpdate(id, { name: 'jason bourne' }, options)\n *\n *     // is sent as\n *     Model.findByIdAndUpdate(id, { $set: { name: 'jason bourne' }}, options)\n *\n * #### Note:\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [update]\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.runValidators] if true, runs [update validators](https://mongoosejs.com/docs/validation.html#update-validators) on this command. Update validators validate the update operation against the model's schema\n * @param {Boolean} [options.setDefaultsOnInsert=true] If `setDefaultsOnInsert` and `upsert` are true, mongoose will apply the [defaults](https://mongoosejs.com/docs/defaults.html) specified in the model's schema if a new document is created\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Boolean} [options.new=false] if true, return the modified document rather than the original\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Model.findOneAndUpdate https://mongoosejs.com/docs/api/model.html#Model.findOneAndUpdate()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n * @api public\n */\n\nModel.findByIdAndUpdate = function(id, update, options) {\n  _checkContext(this, 'findByIdAndUpdate');\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findByIdAndUpdate() no longer accepts a callback');\n  }\n\n  // if a model is passed in instead of an id\n  if (id instanceof Document) {\n    id = id._doc._id;\n  }\n\n  return this.findOneAndUpdate.call(this, { _id: id }, update, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command.\n *\n * Finds a matching document, removes it, and returns the found document (if any).\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * #### Example:\n *\n *     A.findOneAndDelete(conditions, options)  // return Query\n *     A.findOneAndDelete(conditions) // returns Query\n *     A.findOneAndDelete()           // returns Query\n *\n * `findOneAndX` and `findByIdAndX` functions support limited validation. You can\n * enable validation by setting the `runValidators` option.\n *\n * If you need full-fledged validation, use the traditional approach of first\n * retrieving the document.\n *\n *     const doc = await Model.findById(id)\n *     doc.name = 'jason bourne';\n *     await doc.save();\n *\n * @param {Object} conditions\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndDelete = function(conditions, options) {\n  _checkContext(this, 'findOneAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findOneAndDelete() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndDelete(conditions, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndDelete()` command by a document's _id field.\n * In other words, `findByIdAndDelete(id)` is a shorthand for\n * `findOneAndDelete({ _id: id })`.\n *\n * This function triggers the following middleware.\n *\n * - `findOneAndDelete()`\n *\n * @param {Object|Number|String} id value of `_id` to query by\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Model.findOneAndDelete https://mongoosejs.com/docs/api/model.html#Model.findOneAndDelete()\n * @see mongodb https://www.mongodb.com/docs/manual/reference/command/findAndModify/\n */\n\nModel.findByIdAndDelete = function(id, options) {\n  _checkContext(this, 'findByIdAndDelete');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.findByIdAndDelete() no longer accepts a callback');\n  }\n\n  return this.findOneAndDelete({ _id: id }, options);\n};\n\n/**\n * Issue a MongoDB `findOneAndReplace()` command.\n *\n * Finds a matching document, replaces it with the provided doc, and returns the document.\n *\n * This function triggers the following query middleware.\n *\n * - `findOneAndReplace()`\n *\n * #### Example:\n *\n *     A.findOneAndReplace(filter, replacement, options)  // return Query\n *     A.findOneAndReplace(filter, replacement) // returns Query\n *     A.findOneAndReplace()                    // returns Query\n *\n * @param {Object} filter Replace the first document that matches this filter\n * @param {Object} [replacement] Replace with this document\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {String} [options.returnDocument='before'] Has two possible values, `'before'` and `'after'`. By default, it will return the document before the update was applied.\n * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and [the Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).\n * @param {ClientSession} [options.session=null] The session associated with this query. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Object|String|String[]} [options.projection=null] optional fields to return, see [`Query.prototype.select()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.select())\n * @param {Object|String} [options.sort] if multiple docs are found by the conditions, sets the sort order to choose which doc to update.\n * @param {Boolean} [options.includeResultMetadata] if true, returns the full [ModifyResult from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/ModifyResult.html) rather than just the document\n * @param {Object|String} [options.select] sets the document fields to return.\n * @param {Number} [options.maxTimeMS] puts a time limit on the query - requires mongodb >= 2.6.0\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @api public\n */\n\nModel.findOneAndReplace = function(filter, replacement, options) {\n  _checkContext(this, 'findOneAndReplace');\n\n  if (typeof arguments[0] === 'function' || typeof arguments[1] === 'function' || typeof arguments[2] === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.findOneAndReplace() no longer accepts a callback');\n  }\n\n  let fields;\n  if (options) {\n    fields = options.select;\n    options.select = undefined;\n  }\n\n  const mq = new this.Query({}, {}, this, this.$__collection);\n  mq.select(fields);\n\n  return mq.findOneAndReplace(filter, replacement, options);\n};\n\n/**\n * Shortcut for saving one or more documents to the database.\n * `MyModel.create(docs)` does `new MyModel(doc).save()` for every doc in\n * docs.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     await Character.create({ name: 'Jean-Luc Picard' });\n *\n *     // Insert multiple new `Character` documents\n *     await Character.create([{ name: 'Will Riker' }, { name: 'Geordi LaForge' }]);\n *\n *     // Create a new character within a transaction. Note that you **must**\n *     // pass an array as the first parameter to `create()` if you want to\n *     // specify options.\n *     await Character.create([{ name: 'Jean-Luc Picard' }], { session });\n *\n * @param {Array|Object} docs Documents to insert, as a spread or array\n * @param {Object} [options] Options passed down to `save()`. To specify `options`, `docs` **must** be an array, not a spread. See [Model.save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) for available options.\n * @param {Boolean} [options.ordered] saves the docs in series rather than parallel.\n * @param {Boolean} [options.aggregateErrors] Aggregate Errors instead of throwing the first one that occurs. Default: false\n * @return {Promise}\n * @api public\n */\n\nModel.create = async function create(doc, options) {\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.create() no longer accepts a callback');\n  }\n\n  _checkContext(this, 'create');\n\n  let args;\n  const discriminatorKey = this.schema.options.discriminatorKey;\n\n  if (Array.isArray(doc)) {\n    args = doc;\n    options = options != null && typeof options === 'object' ? options : {};\n  } else {\n    const last = arguments[arguments.length - 1];\n    options = {};\n    const hasCallback = typeof last === 'function' ||\n      typeof options === 'function' ||\n      typeof arguments[2] === 'function';\n    if (hasCallback) {\n      throw new MongooseError('Model.create() no longer accepts a callback');\n    } else {\n      args = [...arguments];\n      // For backwards compatibility with 6.x, because of gh-5061 Mongoose 6.x and\n      // older would treat a falsy last arg as a callback. We don't want to throw\n      // an error here, because it would look strange if `Test.create({}, void 0)`\n      // threw a callback error. But we also don't want to create an unnecessary document.\n      if (args.length > 1 && !last) {\n        args.pop();\n      }\n    }\n\n    if (args.length === 2 &&\n        args[0] != null &&\n        args[1] != null &&\n        args[0].session == null &&\n        last &&\n        getConstructorName(last.session) === 'ClientSession' &&\n        !this.schema.path('session')) {\n      // Probably means the user is running into the common mistake of trying\n      // to use a spread to specify options, see gh-7535\n      utils.warn('WARNING: to pass a `session` to `Model.create()` in ' +\n        'Mongoose, you **must** pass an array as the first argument. See: ' +\n        'https://mongoosejs.com/docs/api/model.html#Model.create()');\n    }\n  }\n\n  if (args.length === 0) {\n    return Array.isArray(doc) ? [] : null;\n  }\n  let res = [];\n  const immediateError = typeof options.aggregateErrors === 'boolean' ? !options.aggregateErrors : true;\n\n  delete options.aggregateErrors; // dont pass on the option to \"$save\"\n\n  if (options.session && !options.ordered && args.length > 1) {\n    throw new MongooseError('Cannot call `create()` with a session and multiple documents unless `ordered: true` is set');\n  }\n\n  if (options.ordered) {\n    for (let i = 0; i < args.length; i++) {\n      try {\n        const doc = args[i];\n        const Model = this.discriminators && doc[discriminatorKey] != null ?\n          this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n          this;\n        if (Model == null) {\n          throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n          `found for model \"${this.modelName}\"`);\n        }\n        let toSave = doc;\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n        res.push(toSave);\n      } catch (err) {\n        if (!immediateError) {\n          res.push(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n    return res;\n  } else if (!immediateError) {\n    res = await Promise.allSettled(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n      }\n      let toSave = doc;\n\n      if (!(toSave instanceof Model)) {\n        toSave = new Model(toSave);\n      }\n\n      await toSave.$save(options);\n\n      return toSave;\n    }));\n    res = res.map(result => result.status === 'fulfilled' ? result.value : result.reason);\n  } else {\n    let firstError = null;\n    res = await Promise.all(args.map(async doc => {\n      const Model = this.discriminators && doc[discriminatorKey] != null ?\n        this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n        this;\n      if (Model == null) {\n        throw new MongooseError(`Discriminator \"${doc[discriminatorKey]}\" not ` +\n            `found for model \"${this.modelName}\"`);\n      }\n      try {\n        let toSave = doc;\n\n        if (!(toSave instanceof Model)) {\n          toSave = new Model(toSave);\n        }\n\n        await toSave.$save(options);\n\n        return toSave;\n      } catch (err) {\n        if (!firstError) {\n          firstError = err;\n        }\n      }\n    }));\n    if (firstError) {\n      throw firstError;\n    }\n  }\n\n\n  if (!Array.isArray(doc) && args.length === 1) {\n    return res[0];\n  }\n\n  return res;\n};\n\n/**\n * Shortcut for saving one document to the database.\n * `MyModel.insertOne(obj, options)` is almost equivalent to `new MyModel(obj).save(options)`.\n * The difference is that `insertOne()` checks if `obj` is already a document, and checks for discriminators.\n *\n * This function triggers the following middleware.\n *\n * - `save()`\n *\n * #### Example:\n *\n *     // Insert one new `Character` document\n *     const character = await Character.insertOne({ name: 'Jean-Luc Picard' });\n *     character.name; // 'Jean-Luc Picard'\n *\n *     // Create a new character within a transaction.\n *     await Character.insertOne({ name: 'Jean-Luc Picard' }, { session });\n *\n * @param {Object|Document} doc Document to insert, as a POJO or Mongoose document\n * @param {Object} [options] Options passed down to `save()`.\n * @return {Promise<Document>} resolves to the saved document\n * @api public\n */\n\nModel.insertOne = async function insertOne(doc, options) {\n  _checkContext(this, 'insertOne');\n\n  const discriminatorKey = this.schema.options.discriminatorKey;\n  const Model = this.discriminators && doc[discriminatorKey] != null ?\n    this.discriminators[doc[discriminatorKey]] || getDiscriminatorByValue(this.discriminators, doc[discriminatorKey]) :\n    this;\n  if (Model == null) {\n    throw new MongooseError(\n      `Discriminator \"${doc[discriminatorKey]}\" not found for model \"${this.modelName}\"`\n    );\n  }\n  if (!(doc instanceof Model)) {\n    doc = new Model(doc);\n  }\n\n  return await doc.$save(options);\n};\n\n/**\n * _Requires a replica set running MongoDB >= 3.6.0._ Watches the\n * underlying collection for changes using\n * [MongoDB change streams](https://www.mongodb.com/docs/manual/changeStreams/).\n *\n * This function does **not** trigger any middleware. In particular, it\n * does **not** trigger aggregate middleware.\n *\n * The ChangeStream object is an event emitter that emits the following events:\n *\n * - 'change': A change occurred, see below example\n * - 'error': An unrecoverable error occurred. In particular, change streams currently error out if they lose connection to the replica set primary. Follow [this GitHub issue](https://github.com/Automattic/mongoose/issues/6799) for updates.\n * - 'end': Emitted if the underlying stream is closed\n * - 'close': Emitted if the underlying stream is closed\n *\n * #### Example:\n *\n *     const doc = await Person.create({ name: 'Ned Stark' });\n *     const changeStream = Person.watch().on('change', change => console.log(change));\n *     // Will print from the above `console.log()`:\n *     // { _id: { _data: ... },\n *     //   operationType: 'delete',\n *     //   ns: { db: 'mydb', coll: 'Person' },\n *     //   documentKey: { _id: 5a51b125c5500f5aa094c7bd } }\n *     await doc.deleteOne();\n *\n * @param {Array} [pipeline]\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#watch)\n * @param {Boolean} [options.hydrate=false] if true and `fullDocument: 'updateLookup'` is set, Mongoose will automatically hydrate `fullDocument` into a fully fledged Mongoose document\n * @return {ChangeStream} mongoose-specific change stream wrapper, inherits from EventEmitter\n * @api public\n */\n\nModel.watch = function(pipeline, options) {\n  _checkContext(this, 'watch');\n\n  const changeStreamThunk = cb => {\n    pipeline = pipeline || [];\n    prepareDiscriminatorPipeline(pipeline, this.schema, 'fullDocument');\n    if (this.$__collection.buffer) {\n      this.$__collection.addQueue(() => {\n        if (this.closed) {\n          return;\n        }\n        const driverChangeStream = this.$__collection.watch(pipeline, options);\n        cb(null, driverChangeStream);\n      });\n    } else {\n      const driverChangeStream = this.$__collection.watch(pipeline, options);\n      cb(null, driverChangeStream);\n    }\n  };\n\n  options = options || {};\n  options.model = this;\n\n  return new ChangeStream(changeStreamThunk, pipeline, options);\n};\n\n/**\n * _Requires MongoDB >= 3.6.0._ Starts a [MongoDB session](https://www.mongodb.com/docs/manual/release-notes/3.6/#client-sessions)\n * for benefits like causal consistency, [retryable writes](https://www.mongodb.com/docs/manual/core/retryable-writes/),\n * and [transactions](https://thecodebarbarian.com/a-node-js-perspective-on-mongodb-4-transactions.html).\n *\n * Calling `MyModel.startSession()` is equivalent to calling `MyModel.db.startSession()`.\n *\n * This function does not trigger any middleware.\n *\n * #### Example:\n *\n *     const session = await Person.startSession();\n *     let doc = await Person.findOne({ name: 'Ned Stark' }, null, { session });\n *     await doc.deleteOne();\n *     // `doc` will always be null, even if reading from a replica set\n *     // secondary. Without causal consistency, it is possible to\n *     // get a doc back from the below query if the query reads from a\n *     // secondary that is experiencing replication lag.\n *     doc = await Person.findOne({ name: 'Ned Stark' }, null, { session, readPreference: 'secondary' });\n *\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/MongoClient.html#startSession)\n * @param {Boolean} [options.causalConsistency=true] set to false to disable causal consistency\n * @return {Promise<ClientSession>} promise that resolves to a MongoDB driver `ClientSession`\n * @api public\n */\n\nModel.startSession = function() {\n  _checkContext(this, 'startSession');\n\n  return this.db.startSession.apply(this.db, arguments);\n};\n\n/**\n * Shortcut for validating an array of documents and inserting them into\n * MongoDB if they're all valid. This function is faster than `.create()`\n * because it only sends one operation to the server, rather than one for each\n * document.\n *\n * Mongoose always validates each document **before** sending `insertMany`\n * to MongoDB. So if one document has a validation error, no documents will\n * be saved, unless you set\n * [the `ordered` option to false](https://www.mongodb.com/docs/manual/reference/method/db.collection.insertMany/#error-handling).\n *\n * This function does **not** trigger save middleware.\n *\n * This function triggers the following middleware.\n *\n * - `insertMany()`\n *\n * #### Example:\n *\n *     const docs = await Movies.insertMany([\n *       { name: 'Star Wars' },\n *       { name: 'The Empire Strikes Back' }\n *     ]);\n *     docs[0].name; // 'Star Wars'\n *\n *     // Return raw result from MongoDB\n *     const result = await Movies.insertMany([\n *       { name: 'Star Wars' },\n *       { name: 'The Empire Strikes Back' }\n *     ], { rawResult: true });\n *\n * @param {Array|Object|*} doc(s)\n * @param {Object} [options] see the [mongodb driver options](https://mongodb.github.io/node-mongodb-native/4.9/classes/Collection.html#insertMany)\n * @param {Boolean} [options.ordered=true] if true, will fail fast on the first error encountered. If false, will insert all the documents it can and report errors later. An `insertMany()` with `ordered = false` is called an \"unordered\" `insertMany()`.\n * @param {Boolean} [options.rawResult=false] if false, the returned promise resolves to the documents that passed mongoose document validation. If `true`, will return the [raw result from the MongoDB driver](https://mongodb.github.io/node-mongodb-native/4.9/interfaces/InsertManyResult.html) with a `mongoose` property that contains `validationErrors` and `results` if this is an unordered `insertMany`.\n * @param {Boolean} [options.lean=false] if `true`, skips hydrating the documents. This means Mongoose will **not** cast, validate, or apply defaults to any of the documents passed to `insertMany()`. This option is useful if you need the extra performance, but comes with data integrity risk. Consider using with [`castObject()`](https://mongoosejs.com/docs/api/model.html#Model.castObject()) and [`applyDefaults()`](https://mongoosejs.com/docs/api/model.html#Model.applyDefaults()).\n * @param {Number} [options.limit=null] this limits the number of documents being processed (validation/casting) by mongoose in parallel, this does **NOT** send the documents in batches to MongoDB. Use this option if you're processing a large number of documents and your app is running out of memory.\n * @param {String|Object|Array} [options.populate=null] populates the result documents. This option is a no-op if `rawResult` is set.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully.\n * @return {Promise} resolving to the raw result from the MongoDB driver if `options.rawResult` was `true`, or the documents that passed validation, otherwise\n * @api public\n */\n\nModel.insertMany = async function insertMany(arr, options) {\n  _checkContext(this, 'insertMany');\n  if (typeof options === 'function' ||\n    typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.insertMany() no longer accepts a callback');\n  }\n\n  return new Promise((resolve, reject) => {\n    this.$__insertMany(arr, options, (err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n};\n\n/**\n * ignore\n *\n * @param {Array} arr\n * @param {Object} options\n * @param {Function} callback\n * @api private\n * @memberOf Model\n * @method $__insertMany\n * @static\n */\n\nModel.$__insertMany = function(arr, options, callback) {\n  const _this = this;\n  if (typeof options === 'function') {\n    callback = options;\n    options = null;\n  }\n\n  callback = callback || utils.noop;\n  options = options || {};\n  const limit = options.limit || 1000;\n  const rawResult = !!options.rawResult;\n  const ordered = typeof options.ordered === 'boolean' ? options.ordered : true;\n  const throwOnValidationError = typeof options.throwOnValidationError === 'boolean' ? options.throwOnValidationError : false;\n  const lean = !!options.lean;\n\n  const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();\n  if ((!options || !options.hasOwnProperty('session')) && asyncLocalStorage?.session != null) {\n    options = { ...options, session: asyncLocalStorage.session };\n  }\n\n  if (!Array.isArray(arr)) {\n    arr = [arr];\n  }\n\n  const validationErrors = [];\n  const validationErrorsToOriginalOrder = new Map();\n  const results = ordered ? null : new Array(arr.length);\n  const toExecute = arr.map((doc, index) =>\n    callback => {\n      // If option `lean` is set to true bypass validation and hydration\n      if (lean) {\n        // we have to execute callback at the nextTick to be compatible\n        // with parallelLimit, as `results` variable has TDZ issue if we\n        // execute the callback synchronously\n        return immediate(() => callback(null, doc));\n      }\n      let createdNewDoc = false;\n      if (!(doc instanceof _this)) {\n        if (doc != null && typeof doc !== 'object') {\n          return callback(new ObjectParameterError(doc, 'arr.' + index, 'insertMany'));\n        }\n        try {\n          doc = new _this(doc);\n          createdNewDoc = true;\n        } catch (err) {\n          return callback(err);\n        }\n      }\n\n      if (options.session != null) {\n        doc.$session(options.session);\n      }\n      // If option `lean` is set to true bypass validation\n      if (lean) {\n        // we have to execute callback at the nextTick to be compatible\n        // with parallelLimit, as `results` variable has TDZ issue if we\n        // execute the callback synchronously\n        return immediate(() => callback(null, doc));\n      }\n      doc.$validate(createdNewDoc ? { _skipParallelValidateCheck: true } : null).then(\n        () => { callback(null, doc); },\n        error => {\n          if (ordered === false) {\n            validationErrors.push(error);\n            validationErrorsToOriginalOrder.set(error, index);\n            results[index] = error;\n            return callback(null, null);\n          }\n          callback(error);\n        }\n      );\n    });\n\n  parallelLimit(toExecute, limit, function(error, docs) {\n    if (error) {\n      callback(error, null);\n      return;\n    }\n\n    const originalDocIndex = new Map();\n    const validDocIndexToOriginalIndex = new Map();\n    for (let i = 0; i < docs.length; ++i) {\n      originalDocIndex.set(docs[i], i);\n    }\n\n    // We filter all failed pre-validations by removing nulls\n    const docAttributes = docs.filter(function(doc) {\n      return doc != null;\n    });\n    for (let i = 0; i < docAttributes.length; ++i) {\n      validDocIndexToOriginalIndex.set(i, originalDocIndex.get(docAttributes[i]));\n    }\n\n    // Make sure validation errors are in the same order as the\n    // original documents, so if both doc1 and doc2 both fail validation,\n    // `Model.insertMany([doc1, doc2])` will always have doc1's validation\n    // error before doc2's. Re: gh-12791.\n    if (validationErrors.length > 0) {\n      validationErrors.sort((err1, err2) => {\n        return validationErrorsToOriginalOrder.get(err1) - validationErrorsToOriginalOrder.get(err2);\n      });\n    }\n\n    // Quickly escape while there aren't any valid docAttributes\n    if (docAttributes.length === 0) {\n      if (throwOnValidationError) {\n        return callback(new MongooseBulkWriteError(\n          validationErrors,\n          results,\n          null,\n          'insertMany'\n        ));\n      }\n      if (rawResult) {\n        const res = {\n          acknowledged: true,\n          insertedCount: 0,\n          insertedIds: {}\n        };\n        decorateBulkWriteResult(res, validationErrors, validationErrors);\n        return callback(null, res);\n      }\n      callback(null, []);\n      return;\n    }\n    const docObjects = lean ? docAttributes : docAttributes.map(function(doc) {\n      if (doc.$__schema.options.versionKey) {\n        doc[doc.$__schema.options.versionKey] = 0;\n      }\n      const shouldSetTimestamps = (!options || options.timestamps !== false) && doc.initializeTimestamps && (!doc.$__ || doc.$__.timestamps !== false);\n      if (shouldSetTimestamps) {\n        doc.initializeTimestamps();\n      }\n      if (doc.$__hasOnlyPrimitiveValues()) {\n        return doc.$__toObjectShallow();\n      }\n      return doc.toObject(internalToObjectOptions);\n    });\n\n    _this.$__collection.insertMany(docObjects, options).then(\n      res => {\n        if (!lean) {\n          for (const attribute of docAttributes) {\n            attribute.$__reset();\n            _setIsNew(attribute, false);\n          }\n        }\n\n        if (ordered === false && throwOnValidationError && validationErrors.length > 0) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n          return callback(new MongooseBulkWriteError(\n            validationErrors,\n            results,\n            res,\n            'insertMany'\n          ));\n        }\n\n        if (rawResult) {\n          if (ordered === false) {\n            for (let i = 0; i < results.length; ++i) {\n              if (results[i] === void 0) {\n                results[i] = docs[i];\n              }\n            }\n\n            // Decorate with mongoose validation errors in case of unordered,\n            // because then still do `insertMany()`\n            decorateBulkWriteResult(res, validationErrors, results);\n          }\n          return callback(null, res);\n        }\n\n        if (options.populate != null) {\n          return _this.populate(docAttributes, options.populate).then(\n            docs => { callback(null, docs); },\n            err => {\n              if (err != null) {\n                err.insertedDocs = docAttributes;\n              }\n              throw err;\n            }\n          );\n        }\n\n        callback(null, docAttributes);\n      },\n      error => {\n        // `writeErrors` is a property reported by the MongoDB driver,\n        // just not if there's only 1 error.\n        if (error.writeErrors == null &&\n            (error.result && error.result.result && error.result.result.writeErrors) != null) {\n          error.writeErrors = error.result.result.writeErrors;\n        }\n\n        // `insertedDocs` is a Mongoose-specific property\n        const hasWriteErrors = error && error.writeErrors;\n        const erroredIndexes = new Set((error && error.writeErrors || []).map(err => err.index));\n\n        if (error.writeErrors != null) {\n          for (let i = 0; i < error.writeErrors.length; ++i) {\n            const originalIndex = validDocIndexToOriginalIndex.get(error.writeErrors[i].index);\n            error.writeErrors[i] = { ...error.writeErrors[i], index: originalIndex };\n            if (!ordered) {\n              results[originalIndex] = error.writeErrors[i];\n            }\n          }\n        }\n\n        if (!ordered) {\n          for (let i = 0; i < results.length; ++i) {\n            if (results[i] === void 0) {\n              results[i] = docs[i];\n            }\n          }\n\n          error.results = results;\n        }\n\n        let firstErroredIndex = -1;\n        error.insertedDocs = docAttributes.\n          filter((doc, i) => {\n            const isErrored = !hasWriteErrors || erroredIndexes.has(i);\n\n            if (ordered) {\n              if (firstErroredIndex > -1) {\n                return i < firstErroredIndex;\n              }\n\n              if (isErrored) {\n                firstErroredIndex = i;\n              }\n            }\n\n            return !isErrored;\n          }).\n          map(function setIsNewForInsertedDoc(doc) {\n            if (lean) {\n              return doc;\n            }\n            doc.$__reset();\n            _setIsNew(doc, false);\n            return doc;\n          });\n\n        if (rawResult && ordered === false) {\n          decorateBulkWriteResult(error, validationErrors, results);\n        }\n\n        callback(error, null);\n      }\n    );\n  });\n};\n\n/*!\n * ignore\n */\n\nfunction _setIsNew(doc, val) {\n  doc.$isNew = val;\n  doc.$emit('isNew', val);\n  doc.constructor.emit('isNew', val);\n\n  const subdocs = doc.$getAllSubdocs({ useCache: true });\n  for (const subdoc of subdocs) {\n    subdoc.$isNew = val;\n    subdoc.$emit('isNew', val);\n  }\n}\n\n/**\n * Sends multiple `insertOne`, `updateOne`, `updateMany`, `replaceOne`,\n * `deleteOne`, and/or `deleteMany` operations to the MongoDB server in one\n * command. This is faster than sending multiple independent operations (e.g.\n * if you use `create()`) because with `bulkWrite()` there is only one round\n * trip to MongoDB.\n *\n * Mongoose will perform casting on all operations you provide.\n * The only exception is [setting the `update` operator for `updateOne` or `updateMany` to a pipeline](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#updateone-and-updatemany): Mongoose does **not** cast update pipelines.\n *\n * This function does **not** trigger any middleware, neither `save()`, nor `update()`.\n * If you need to trigger\n * `save()` middleware for every document use [`create()`](https://mongoosejs.com/docs/api/model.html#Model.create()) instead.\n *\n * #### Example:\n *\n *     Character.bulkWrite([\n *       {\n *         insertOne: {\n *           document: {\n *             name: 'Eddard Stark',\n *             title: 'Warden of the North'\n *           }\n *         }\n *       },\n *       {\n *         updateOne: {\n *           filter: { name: 'Eddard Stark' },\n *           // If you were using the MongoDB driver directly, you'd need to do\n *           // `update: { $set: { title: ... } }` but mongoose adds $set for\n *           // you.\n *           update: { title: 'Hand of the King' }\n *         }\n *       },\n *       {\n *         deleteOne: {\n *           filter: { name: 'Eddard Stark' }\n *         }\n *       }\n *     ]).then(res => {\n *      // Prints \"1 1 1\"\n *      console.log(res.insertedCount, res.modifiedCount, res.deletedCount);\n *     });\n *\n *     // Mongoose does **not** cast update pipelines, so no casting for the `update` option below.\n *     // Mongoose does still cast `filter`\n *     await Character.bulkWrite([{\n *       updateOne: {\n *         filter: { name: 'Annika Hansen' },\n *         update: [{ $set: { name: 7 } }] // Array means update pipeline, so Mongoose skips casting\n *       }\n *     }]);\n *\n * The [supported operations](https://www.mongodb.com/docs/manual/reference/method/db.collection.bulkWrite/#db.collection.bulkWrite) are:\n *\n * - `insertOne`\n * - `updateOne`\n * - `updateMany`\n * - `deleteOne`\n * - `deleteMany`\n * - `replaceOne`\n *\n * @param {Array} ops\n * @param {Object} [ops.insertOne.document] The document to insert\n * @param {Object} [ops.insertOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateOne.filter] Update the first document that matches this filter\n * @param {Object} [ops.updateOne.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateOne.upsert=false] If true, insert a doc if none match\n * @param {Boolean} [ops.updateOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateOne.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateOne.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.updateMany.filter] Update all the documents that match this filter\n * @param {Object} [ops.updateMany.update] An object containing [update operators](https://www.mongodb.com/docs/manual/reference/operator/update/)\n * @param {Boolean} [ops.updateMany.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Boolean} [ops.updateMany.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [ops.updateMany.collation] The [MongoDB collation](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-34-collations) to use\n * @param {Array} [ops.updateMany.arrayFilters] The [array filters](https://thecodebarbarian.com/a-nodejs-perspective-on-mongodb-36-array-filters.html) used in `update`\n * @param {Object} [ops.deleteOne.filter] Delete the first document that matches this filter\n * @param {Object} [ops.deleteMany.filter] Delete all documents that match this filter\n * @param {Object} [ops.replaceOne.filter] Replace the first document that matches this filter\n * @param {Object} [ops.replaceOne.replacement] The replacement document\n * @param {Boolean} [ops.replaceOne.upsert=false] If true, insert a doc if no documents match `filter`\n * @param {Object} [ops.replaceOne.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to the operation\n * @param {Object} [options]\n * @param {Boolean} [options.ordered=true] If true, execute writes in order and stop at the first error. If false, execute writes in parallel and continue until all writes have either succeeded or errored.\n * @param {Boolean} [options.timestamps=true] If false, do not apply [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) to any operations. Can be overridden at the operation-level.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.skipValidation=false] Set to true to skip Mongoose schema validation on bulk write operations. Mongoose currently runs validation on `insertOne` and `replaceOne` operations by default.\n * @param {Boolean} [options.bypassDocumentValidation=false] If true, disable [MongoDB server-side schema validation](https://www.mongodb.com/docs/manual/core/schema-validation/) for all writes in this bulk.\n * @param {Boolean} [options.throwOnValidationError=false] If true and `ordered: false`, throw an error if one of the operations failed validation, but all valid operations completed successfully. Note that Mongoose will still send all valid operations to the MongoDB server.\n * @param {Boolean|\"throw\"} [options.strict=null] Overwrites the [`strict` option](https://mongoosejs.com/docs/guide.html#strict) on schema. If false, allows filtering and writing fields not defined in the schema for all writes in this bulk.\n * @return {Promise} resolves to a [`BulkWriteOpResult`](https://mongodb.github.io/node-mongodb-native/4.9/classes/BulkWriteResult.html) if the operation succeeds\n * @api public\n */\n\nModel.bulkWrite = async function bulkWrite(ops, options) {\n  _checkContext(this, 'bulkWrite');\n\n  if (typeof options === 'function' ||\n      typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.bulkWrite() no longer accepts a callback');\n  }\n  options = options || {};\n\n  const shouldSkip = await new Promise((resolve, reject) => {\n    this.hooks.execPre('bulkWrite', this, [ops, options], (err) => {\n      if (err != null) {\n        if (err instanceof Kareem.skipWrappedFunction) {\n          return resolve(err);\n        }\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  if (shouldSkip) {\n    return shouldSkip.args[0];\n  }\n\n  const ordered = options.ordered == null ? true : options.ordered;\n\n  if (ops.length === 0) {\n    const BulkWriteResult = this.base.driver.get().BulkWriteResult;\n    const bulkWriteResult = new BulkWriteResult(getDefaultBulkwriteResult(), false);\n    bulkWriteResult.n = 0;\n    decorateBulkWriteResult(bulkWriteResult, [], []);\n    return bulkWriteResult;\n  }\n\n  const validations = options?._skipCastBulkWrite ? [] : ops.map(op => castBulkWrite(this, op, options));\n  const asyncLocalStorage = this.db.base.transactionAsyncLocalStorage?.getStore();\n  if ((!options || !options.hasOwnProperty('session')) && asyncLocalStorage?.session != null) {\n    options = { ...options, session: asyncLocalStorage.session };\n  }\n\n  let res = null;\n  if (ordered) {\n    await new Promise((resolve, reject) => {\n      each(validations, (fn, cb) => fn(cb), error => {\n        if (error) {\n          return reject(error);\n        }\n\n        resolve();\n      });\n    });\n\n    try {\n      res = await this.$__collection.bulkWrite(ops, options);\n    } catch (error) {\n      await new Promise((resolve, reject) => {\n        const _opts = { error: error };\n        this.hooks.execPost('bulkWrite', this, [null], _opts, (err) => {\n          if (err != null) {\n            return reject(err);\n          }\n          resolve();\n        });\n      });\n    }\n  } else {\n    let validOpIndexes = [];\n    let validationErrors = [];\n    const results = [];\n    if (validations.length > 0) {\n      validOpIndexes = await Promise.all(ops.map((op, i) => {\n        if (i >= validations.length) {\n          return i;\n        }\n        return new Promise((resolve) => {\n          validations[i]((err) => {\n            if (err == null) {\n              resolve(i);\n            } else {\n              validationErrors.push({ index: i, error: err });\n              results[i] = err;\n            }\n            resolve();\n          });\n        });\n      }));\n      validOpIndexes = validOpIndexes.filter(index => index != null);\n    } else {\n      validOpIndexes = ops.map((op, i) => i);\n    }\n\n    validationErrors = validationErrors.\n      sort((v1, v2) => v1.index - v2.index).\n      map(v => v.error);\n\n    const validOps = validOpIndexes.sort().map(index => ops[index]);\n\n    if (validOps.length === 0) {\n      if (options.throwOnValidationError && validationErrors.length) {\n        throw new MongooseBulkWriteError(\n          validationErrors,\n          results,\n          res,\n          'bulkWrite'\n        );\n      }\n      const BulkWriteResult = this.base.driver.get().BulkWriteResult;\n      const bulkWriteResult = new BulkWriteResult(getDefaultBulkwriteResult(), false);\n      bulkWriteResult.result = getDefaultBulkwriteResult();\n      decorateBulkWriteResult(bulkWriteResult, validationErrors, results);\n      return bulkWriteResult;\n    }\n\n    let error;\n    [res, error] = await this.$__collection.bulkWrite(validOps, options).\n      then(res => ([res, null])).\n      catch(error => ([null, error]));\n\n    const writeErrorsByIndex = {};\n    if (error?.writeErrors) {\n      for (const writeError of error.writeErrors) {\n        writeErrorsByIndex[writeError.err.index] = writeError;\n      }\n    }\n    for (let i = 0; i < validOpIndexes.length; ++i) {\n      results[validOpIndexes[i]] = writeErrorsByIndex[i] ?? null;\n    }\n    if (error) {\n      if (validationErrors.length > 0) {\n        decorateBulkWriteResult(error, validationErrors, results);\n      }\n\n      await new Promise((resolve, reject) => {\n        const _opts = { error: error };\n        this.hooks.execPost('bulkWrite', this, [null], _opts, (err) => {\n          if (err != null) {\n            return reject(err);\n          }\n          resolve();\n        });\n      });\n    }\n\n    if (validationErrors.length > 0) {\n      if (options.throwOnValidationError) {\n        throw new MongooseBulkWriteError(\n          validationErrors,\n          results,\n          res,\n          'bulkWrite'\n        );\n      } else {\n        decorateBulkWriteResult(res, validationErrors, results);\n      }\n    }\n  }\n\n  await new Promise((resolve, reject) => {\n    this.hooks.execPost('bulkWrite', this, [res], (err) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve();\n    });\n  });\n\n  return res;\n};\n\n/**\n * Takes an array of documents, gets the changes and inserts/updates documents in the database\n * according to whether or not the document is new, or whether it has changes or not.\n *\n * `bulkSave` uses `bulkWrite` under the hood, so it's mostly useful when dealing with many documents (10K+)\n *\n * `bulkSave()` throws errors under the following conditions:\n *\n * - one of the provided documents fails validation. In this case, `bulkSave()` does not send a `bulkWrite()`, and throws the first validation error.\n * - `bulkWrite()` fails (for example, due to being unable to connect to MongoDB or due to duplicate key error)\n * - `bulkWrite()` did not insert or update **any** documents. In this case, `bulkSave()` will throw a DocumentNotFound error.\n *\n * Note that `bulkSave()` will **not** throw an error if only some of the `save()` calls succeeded.\n *\n * @param {Array<Document>} documents\n * @param {Object} [options] options passed to the underlying `bulkWrite()`\n * @param {Boolean} [options.timestamps] defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @param {ClientSession} [options.session=null] The session associated with this bulk write. See [transactions docs](https://mongoosejs.com/docs/transactions.html).\n * @param {String|number} [options.w=1] The [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/). See [`Query#w()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.w()) for more information.\n * @param {number} [options.wtimeout=null] The [write concern timeout](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout).\n * @param {Boolean} [options.j=true] If false, disable [journal acknowledgement](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option)\n * @param {Boolean} [options.validateBeforeSave=true] set to `false` to skip Mongoose validation on all documents\n * @return {BulkWriteResult} the return value from `bulkWrite()`\n */\nModel.bulkSave = async function bulkSave(documents, options) {\n  options = options || {};\n\n  if (options.timestamps != null) {\n    for (const document of documents) {\n      document.$__.saveOptions = document.$__.saveOptions || {};\n      document.$__.saveOptions.timestamps = options.timestamps;\n    }\n  } else {\n    for (const document of documents) {\n      if (document.$__.timestamps != null) {\n        document.$__.saveOptions = document.$__.saveOptions || {};\n        document.$__.saveOptions.timestamps = document.$__.timestamps;\n      }\n    }\n  }\n\n  await Promise.all(documents.map(doc => buildPreSavePromise(doc, options)));\n\n  const writeOperations = this.buildBulkWriteOperations(documents, options);\n  const opts = { skipValidation: true, _skipCastBulkWrite: true, ...options };\n  const { bulkWriteResult, bulkWriteError } = await this.bulkWrite(writeOperations, opts).then(\n    (res) => ({ bulkWriteResult: res, bulkWriteError: null }),\n    (err) => ({ bulkWriteResult: null, bulkWriteError: err })\n  );\n  // If not a MongoBulkWriteError, treat this as all documents failed to save.\n  if (bulkWriteError != null && bulkWriteError.name !== 'MongoBulkWriteError') {\n    throw bulkWriteError;\n  }\n\n  const matchedCount = bulkWriteResult?.matchedCount ?? 0;\n  const insertedCount = bulkWriteResult?.insertedCount ?? 0;\n  if (writeOperations.length > 0 && matchedCount + insertedCount < writeOperations.length && !bulkWriteError) {\n    throw new MongooseBulkSaveIncompleteError(\n      this.modelName,\n      documents,\n      bulkWriteResult\n    );\n  }\n\n  const successfulDocuments = [];\n  for (let i = 0; i < documents.length; i++) {\n    const document = documents[i];\n    const documentError = bulkWriteError && bulkWriteError.writeErrors.find(writeError => {\n      const writeErrorDocumentId = writeError.err.op._id || writeError.err.op.q._id;\n      return writeErrorDocumentId.toString() === document._doc._id.toString();\n    });\n\n    if (documentError == null) {\n      successfulDocuments.push(document);\n    }\n  }\n  await Promise.all(successfulDocuments.map(document => handleSuccessfulWrite(document)));\n\n  if (bulkWriteError != null) {\n    throw bulkWriteError;\n  }\n\n  return bulkWriteResult;\n};\n\nfunction buildPreSavePromise(document, options) {\n  return new Promise((resolve, reject) => {\n    document.schema.s.hooks.execPre('save', document, [options], (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n  });\n}\n\nfunction handleSuccessfulWrite(document) {\n  return new Promise((resolve, reject) => {\n    if (document.$isNew) {\n      _setIsNew(document, false);\n    }\n\n    document.$__reset();\n    document.schema.s.hooks.execPost('save', document, [document], {}, (err) => {\n      if (err) {\n        reject(err);\n        return;\n      }\n      resolve();\n    });\n\n  });\n}\n\n/**\n * Apply defaults to the given document or POJO.\n *\n * @param {Object|Document} obj object or document to apply defaults on\n * @returns {Object|Document}\n * @api public\n */\n\nModel.applyDefaults = function applyDefaults(doc) {\n  if (doc == null) {\n    return doc;\n  }\n  if (doc.$__ != null) {\n    applyDefaultsHelper(doc, doc.$__.fields, doc.$__.exclude);\n\n    for (const subdoc of doc.$getAllSubdocs()) {\n      applyDefaults(subdoc, subdoc.$__.fields, subdoc.$__.exclude);\n    }\n\n    return doc;\n  }\n\n  applyDefaultsToPOJO(doc, this.schema);\n\n  return doc;\n};\n\n/**\n * Apply this model's virtuals to a given POJO. Virtuals execute with the POJO as the context `this`.\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String });\n *     userSchema.virtual('upper').get(function() { return this.name.toUpperCase(); });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const obj = { name: 'John' };\n *     User.applyVirtuals(obj);\n *     obj.name; // 'John'\n *     obj.upper; // 'JOHN', Mongoose applied the return value of the virtual to the given object\n *\n * @param {Object} obj object or document to apply virtuals on\n * @param {Array<string>} [virtualsToApply] optional whitelist of virtuals to apply\n * @returns {Object} obj\n * @api public\n */\n\nModel.applyVirtuals = function applyVirtuals(obj, virtualsToApply) {\n  if (obj == null) {\n    return obj;\n  }\n  // Nothing to do if this is already a hydrated document - it should already have virtuals\n  if (obj.$__ != null) {\n    return obj;\n  }\n\n  applyVirtualsHelper(this.schema, obj, virtualsToApply);\n\n  return obj;\n};\n\n/**\n * Apply this model's timestamps to a given POJO, including subdocument timestamps\n *\n * #### Example:\n *\n *     const userSchema = new Schema({ name: String }, { timestamps: true });\n *     const User = mongoose.model('User', userSchema);\n *\n *     const obj = { name: 'John' };\n *     User.applyTimestamps(obj);\n *     obj.createdAt; // 2024-06-01T18:00:00.000Z\n *     obj.updatedAt; // 2024-06-01T18:00:00.000Z\n *\n * @param {Object} obj object or document to apply virtuals on\n * @param {Object} [options]\n * @param {Boolean} [options.isUpdate=false] if true, treat this as an update: just set updatedAt, skip setting createdAt. If false, set both createdAt and updatedAt\n * @param {Function} [options.currentTime] if set, Mongoose will call this function to get the current time.\n * @returns {Object} obj\n * @api public\n */\n\nModel.applyTimestamps = function applyTimestamps(obj, options) {\n  if (obj == null) {\n    return obj;\n  }\n  // Nothing to do if this is already a hydrated document - it should already have timestamps\n  if (obj.$__ != null) {\n    return obj;\n  }\n\n  applyTimestampsHelper(this.schema, obj, options);\n\n  return obj;\n};\n\n/**\n * Cast the given POJO to the model's schema\n *\n * #### Example:\n *\n *     const Test = mongoose.model('Test', Schema({ num: Number }));\n *\n *     const obj = Test.castObject({ num: '42' });\n *     obj.num; // 42 as a number\n *\n *     Test.castObject({ num: 'not a number' }); // Throws a ValidationError\n *\n * @param {Object} obj object or document to cast\n * @param {Object} options options passed to castObject\n * @param {Boolean} options.ignoreCastErrors If set to `true` will not throw a ValidationError and only return values that were successfully cast.\n * @returns {Object} POJO casted to the model's schema\n * @throws {ValidationError} if casting failed for at least one path\n * @api public\n */\n\nModel.castObject = function castObject(obj, options) {\n  options = options || {};\n  const ret = {};\n\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  const paths = Object.keys(schema.paths);\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (schemaType == null) {\n      continue;\n    }\n\n    let val = get(obj, path, void 0);\n\n    if (val == null) {\n      continue;\n    }\n\n    const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n    let cur = ret;\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      if (cur[pieces[i]] == null) {\n        cur[pieces[i]] = isNaN(pieces[i + 1]) ? {} : [];\n      }\n      cur = cur[pieces[i]];\n    }\n\n    if (schemaType.$isMongooseDocumentArray) {\n      const castNonArraysOption = schemaType.options?.castNonArrays ?? schemaType.constructor.options.castNonArrays;\n      if (!Array.isArray(val)) {\n        if (!castNonArraysOption) {\n          if (!options.ignoreCastErrors) {\n            error = error || new ValidationError();\n            error.addError(path, new ObjectExpectedError(path, val));\n          }\n        } else {\n          cur[pieces[pieces.length - 1]] = [\n            Model.castObject.call(schemaType.caster, val)\n          ];\n        }\n\n        continue;\n      }\n    }\n    if (schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) {\n      try {\n        val = Model.castObject.call(schemaType.caster, val);\n      } catch (err) {\n        if (!options.ignoreCastErrors) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        continue;\n      }\n\n      cur[pieces[pieces.length - 1]] = val;\n      continue;\n    }\n\n    try {\n      val = schemaType.cast(val);\n      cur[pieces[pieces.length - 1]] = val;\n    } catch (err) {\n      if (!options.ignoreCastErrors) {\n        error = error || new ValidationError();\n        error.addError(path, err);\n      }\n\n      continue;\n    }\n  }\n\n  if (error != null) {\n    throw error;\n  }\n\n  return ret;\n};\n\n/**\n * Build bulk write operations for `bulkSave()`.\n *\n * @param {Array<Document>} documents The array of documents to build write operations of\n * @param {Object} options\n * @param {Boolean} options.skipValidation defaults to `false`, when set to true, building the write operations will bypass validating the documents.\n * @param {Boolean} options.timestamps defaults to `null`, when set to false, mongoose will not add/update timestamps to the documents.\n * @return {Array<Promise>} Returns a array of all Promises the function executes to be awaited.\n * @api private\n */\n\nModel.buildBulkWriteOperations = function buildBulkWriteOperations(documents, options) {\n  if (!Array.isArray(documents)) {\n    throw new Error(`bulkSave expects an array of documents to be passed, received \\`${documents}\\` instead`);\n  }\n\n  setDefaultOptions();\n\n  const writeOperations = documents.map((document, i) => {\n    if (!options.skipValidation) {\n      if (!(document instanceof Document)) {\n        throw new Error(`documents.${i} was not a mongoose document, documents must be an array of mongoose documents (instanceof mongoose.Document).`);\n      }\n      if (options.validateBeforeSave == null || options.validateBeforeSave) {\n        const err = document.validateSync();\n        if (err != null) {\n          throw err;\n        }\n      }\n    }\n\n    const isANewDocument = document.isNew;\n    if (isANewDocument) {\n      const writeOperation = { insertOne: { document } };\n      utils.injectTimestampsOption(writeOperation.insertOne, options.timestamps);\n      return writeOperation;\n    }\n\n    const delta = document.$__delta();\n    const isDocumentWithChanges = delta != null && !utils.isEmptyObject(delta[0]);\n\n    if (isDocumentWithChanges) {\n      const where = document.$__where(delta[0]);\n      const changes = delta[1];\n\n      _applyCustomWhere(document, where);\n\n      // If shard key is set, add shard keys to _filter_ condition to right shard is targeted\n      const shardKey = this.schema.options.shardKey;\n      if (shardKey) {\n        const paths = Object.keys(shardKey);\n        const len = paths.length;\n\n        for (let i = 0; i < len; ++i) {\n          where[paths[i]] = document[paths[i]];\n        }\n      }\n\n      document.$__version(where, delta);\n      const writeOperation = { updateOne: { filter: where, update: changes } };\n      utils.injectTimestampsOption(writeOperation.updateOne, options.timestamps);\n      return writeOperation;\n    }\n\n    return null;\n  }).filter(op => op !== null);\n\n  return writeOperations;\n\n\n  function setDefaultOptions() {\n    options = options || {};\n    if (options.skipValidation == null) {\n      options.skipValidation = false;\n    }\n  }\n};\n\n\n/**\n * Shortcut for creating a new Document from existing raw data, pre-saved in the DB.\n * The document returned has no paths marked as modified initially.\n *\n * #### Example:\n *\n *     // hydrate previous data into a Mongoose document\n *     const mongooseCandy = Candy.hydrate({ _id: '54108337212ffb6d459f854c', type: 'jelly bean' });\n *\n * @param {Object} obj\n * @param {Object|String|String[]} [projection] optional projection containing which fields should be selected for this document\n * @param {Object} [options] optional options\n * @param {Boolean} [options.setters=false] if true, apply schema setters when hydrating\n * @param {Boolean} [options.hydratedPopulatedDocs=false] if true, populates the docs if passing pre-populated data\n * @param {Boolean} [options.virtuals=false] if true, sets any virtuals present on `obj`\n * @return {Document} document instance\n * @api public\n */\n\nModel.hydrate = function(obj, projection, options) {\n  _checkContext(this, 'hydrate');\n\n  if (options?.virtuals && options?.hydratedPopulatedDocs === false) {\n    throw new MongooseError('Cannot set `hydratedPopulatedDocs` option to false if `virtuals` option is truthy because `virtuals: true` also sets populated virtuals');\n  }\n\n  if (projection != null) {\n    if (obj != null && obj.$__ != null) {\n      obj = obj.toObject(internalToObjectOptions);\n    }\n    obj = applyProjection(obj, projection);\n  }\n  const document = require('./queryHelpers').createModel(this, obj, projection);\n  document.$init(obj, options);\n  return document;\n};\n\n/**\n * Same as `updateOne()`, except MongoDB will update _all_ documents that match\n * `filter` (as opposed to just the first one) regardless of the value of\n * the `multi` option.\n *\n * **Note** updateMany will _not_ fire update middleware. Use `pre('updateMany')`\n * and `post('updateMany')` instead.\n *\n * #### Example:\n *\n *     const res = await Person.updateMany({ name: /Stark$/ }, { isDeleted: true });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating the MongoDB server received the operation. This may be false if Mongoose did not send an update to the server because the update was empty.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n *     // Other supported syntaxes\n *     await Person.find({ name: /Stark$/ }).updateMany({ isDeleted: true }); // Using chaining syntax\n *     await Person.find().updateMany({ isDeleted: true }); // Set `isDeleted` on _all_ Person documents\n *\n * This function triggers the following middleware.\n *\n * - `updateMany()`\n *\n * @param {Object} filter\n * @param {Object|Array} update. If array, this update will be treated as an update pipeline and not casted.\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateMany = function updateMany(conditions, update, options) {\n  _checkContext(this, 'updateMany');\n\n  if (update == null) {\n    throw new MongooseError('updateMany `update` parameter cannot be nullish');\n  }\n\n  return _update(this, 'updateMany', conditions, update, options);\n};\n\n/**\n * Update _only_ the first document that matches `filter`.\n *\n * - Use `replaceOne()` if you want to overwrite an entire document rather than using atomic operators like `$set`.\n *\n * #### Example:\n *\n *     const res = await Person.updateOne({ name: 'Jean-Luc Picard' }, { ship: 'USS Enterprise' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating the MongoDB server received the operation. This may be false if Mongoose did not send an update to the server because the update was empty.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n *     // Other supported syntaxes\n *     await Person.findOne({ name: 'Jean-Luc Picard' }).updateOne({ ship: 'USS Enterprise' }); // Using chaining syntax\n *     await Person.updateOne({ ship: 'USS Enterprise' }); // Updates first doc's `ship` property\n *\n * This function triggers the following middleware.\n *\n * - `updateOne()`\n *\n * @param {Object} filter\n * @param {Object|Array} update. If array, this update will be treated as an update pipeline and not casted.\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @param {Boolean} [options.overwriteDiscriminatorKey=false] Mongoose removes discriminator key updates from `update` by default, set `overwriteDiscriminatorKey` to `true` to allow updating the discriminator key\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see MongoDB docs https://www.mongodb.com/docs/manual/reference/command/update/#update-command-output\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @api public\n */\n\nModel.updateOne = function updateOne(conditions, doc, options) {\n  _checkContext(this, 'updateOne');\n\n  return _update(this, 'updateOne', conditions, doc, options);\n};\n\n/**\n * Replace the existing document with the given document (no atomic operators like `$set`).\n *\n * #### Example:\n *\n *     const res = await Person.replaceOne({ _id: 24601 }, { name: 'Jean Valjean' });\n *     res.matchedCount; // Number of documents matched\n *     res.modifiedCount; // Number of documents modified\n *     res.acknowledged; // Boolean indicating the MongoDB server received the operation.\n *     res.upsertedId; // null or an id containing a document that had to be upserted.\n *     res.upsertedCount; // Number indicating how many documents had to be upserted. Will either be 0 or 1.\n *\n * This function triggers the following middleware.\n *\n * - `replaceOne()`\n *\n * @param {Object} filter\n * @param {Object} doc\n * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())\n * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)\n * @param {Boolean} [options.upsert=false] if true, and no documents found, insert a new document\n * @param {Object} [options.writeConcern=null] sets the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/) for replica sets. Overrides the [schema-level write concern](https://mongoosejs.com/docs/guide.html#writeConcern)\n * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Does nothing if schema-level timestamps are not set.\n * @param {Boolean} [options.translateAliases=null] If set to `true`, translates any schema-defined aliases in `filter`, `projection`, `update`, and `distinct`. Throws an error if there are any conflicts where both alias and raw property are defined on the same object.\n * @return {Query}\n * @see Query docs https://mongoosejs.com/docs/queries.html\n * @see UpdateResult https://mongodb.github.io/node-mongodb-native/4.9/interfaces/UpdateResult.html\n * @return {Query}\n * @api public\n */\n\nModel.replaceOne = function replaceOne(conditions, doc, options) {\n  _checkContext(this, 'replaceOne');\n\n  const versionKey = this && this.schema && this.schema.options && this.schema.options.versionKey || null;\n  if (versionKey && !doc[versionKey]) {\n    doc[versionKey] = 0;\n  }\n\n  return _update(this, 'replaceOne', conditions, doc, options);\n};\n\n/**\n * Common code for `updateOne()`, `updateMany()`, `replaceOne()`, and `update()`\n * because they need to do the same thing\n * @api private\n */\n\nfunction _update(model, op, conditions, doc, options) {\n  const mq = new model.Query({}, {}, model, model.collection);\n\n  // gh-2406\n  // make local deep copy of conditions\n  if (conditions instanceof Document) {\n    conditions = conditions.toObject();\n  } else {\n    conditions = clone(conditions);\n  }\n  options = typeof options === 'function' ? options : clone(options);\n\n  const versionKey = model &&\n  model.schema &&\n  model.schema.options &&\n  model.schema.options.versionKey || null;\n  decorateUpdateWithVersionKey(doc, options, versionKey);\n\n  return mq[op](conditions, doc, options);\n}\n\n/**\n * Performs [aggregations](https://www.mongodb.com/docs/manual/aggregation/) on the models collection.\n *\n * The `aggregate` itself is returned.\n *\n * This function triggers the following middleware.\n *\n * - `aggregate()`\n *\n * #### Example:\n *\n *     // Find the max balance of all accounts\n *     const res = await Users.aggregate([\n *       { $group: { _id: null, maxBalance: { $max: '$balance' }}},\n *       { $project: { _id: 0, maxBalance: 1 }}\n *     ]);\n *\n *     console.log(res); // [ { maxBalance: 98000 } ]\n *\n *     // Or use the aggregation pipeline builder.\n *     const res = await Users.aggregate().\n *       group({ _id: null, maxBalance: { $max: '$balance' } }).\n *       project('-id maxBalance').\n *       exec();\n *     console.log(res); // [ { maxBalance: 98 } ]\n *\n * #### Note:\n *\n * - Mongoose does **not** cast aggregation pipelines to the model's schema because `$project` and `$group` operators allow redefining the \"shape\" of the documents at any stage of the pipeline, which may leave documents in an incompatible format. You can use the [mongoose-cast-aggregation plugin](https://github.com/AbdelrahmanHafez/mongoose-cast-aggregation) to enable minimal casting for aggregation pipelines.\n * - The documents returned are plain javascript objects, not mongoose documents (since any shape of document can be returned).\n *\n * #### More About Aggregations:\n *\n * - [Mongoose `Aggregate`](https://mongoosejs.com/docs/api/aggregate.html)\n * - [An Introduction to Mongoose Aggregate](https://masteringjs.io/tutorials/mongoose/aggregate)\n * - [MongoDB Aggregation docs](https://www.mongodb.com/docs/manual/applications/aggregation/)\n *\n * @see Aggregate https://mongoosejs.com/docs/api/aggregate.html#Aggregate()\n * @see MongoDB https://www.mongodb.com/docs/manual/applications/aggregation/\n * @param {Array} [pipeline] aggregation pipeline as an array of objects\n * @param {Object} [options] aggregation options\n * @return {Aggregate}\n * @api public\n */\n\nModel.aggregate = function aggregate(pipeline, options) {\n  _checkContext(this, 'aggregate');\n\n  if (typeof options === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.aggregate() no longer accepts a callback');\n  }\n\n  const aggregate = new Aggregate(pipeline || []);\n  aggregate.model(this);\n  if (options != null) {\n    aggregate.option(options);\n  }\n\n  return aggregate;\n};\n\n/**\n * Casts and validates the given object against this model's schema, passing the\n * given `context` to custom validators.\n *\n * #### Example:\n *\n *     const Model = mongoose.model('Test', Schema({\n *       name: { type: String, required: true },\n *       age: { type: Number, required: true }\n *     });\n *\n *     try {\n *       await Model.validate({ name: null }, ['name'])\n *     } catch (err) {\n *       err instanceof mongoose.Error.ValidationError; // true\n *       Object.keys(err.errors); // ['name']\n *     }\n *\n * @param {Object} obj\n * @param {Object|Array|String} pathsOrOptions\n * @param {Object} [context]\n * @return {Promise<Object>} casted and validated copy of `obj` if validation succeeded\n * @api public\n */\n\nModel.validate = async function validate(obj, pathsOrOptions, context) {\n  if ((arguments.length < 3) || (arguments.length === 3 && typeof arguments[2] === 'function')) {\n    // For convenience, if we're validating a document or an object, make `context` default to\n    // the model so users don't have to always pass `context`, re: gh-10132, gh-10346\n    context = obj;\n  }\n  if (typeof context === 'function' || typeof arguments[3] === 'function') {\n    throw new MongooseError('Model.validate() no longer accepts a callback');\n  }\n\n  let schema = this.schema;\n  const discriminatorKey = schema.options.discriminatorKey;\n  if (schema.discriminators != null && obj != null && obj[discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[discriminatorKey]) || schema;\n  }\n  let paths = Object.keys(schema.paths);\n\n  if (pathsOrOptions != null) {\n    const _pathsToValidate = typeof pathsOrOptions === 'string' ? new Set(pathsOrOptions.split(' ')) : Array.isArray(pathsOrOptions) ? new Set(pathsOrOptions) : new Set(paths);\n    paths = paths.filter(p => {\n      if (pathsOrOptions.pathsToSkip) {\n        if (Array.isArray(pathsOrOptions.pathsToSkip)) {\n          if (pathsOrOptions.pathsToSkip.find(x => x == p)) {\n            return false;\n          }\n        } else if (typeof pathsOrOptions.pathsToSkip == 'string') {\n          if (pathsOrOptions.pathsToSkip.includes(p)) {\n            return false;\n          }\n        }\n      }\n      const pieces = p.split('.');\n      let cur = pieces[0];\n\n      for (const piece of pieces) {\n        if (_pathsToValidate.has(cur)) {\n          return true;\n        }\n        cur += '.' + piece;\n      }\n\n      return _pathsToValidate.has(p);\n    });\n  }\n\n  for (const path of paths) {\n    const schemaType = schema.path(path);\n    if (!schemaType || !schemaType.$isMongooseArray || schemaType.$isMongooseDocumentArray) {\n      continue;\n    }\n\n    const val = get(obj, path);\n    pushNestedArrayPaths(paths, val, path);\n  }\n\n  let error = null;\n  paths = new Set(paths);\n\n  try {\n    obj = this.castObject(obj);\n  } catch (err) {\n    error = err;\n    for (const key of Object.keys(error.errors || {})) {\n      paths.delete(key);\n    }\n  }\n\n  let remaining = paths.size;\n\n  return new Promise((resolve, reject) => {\n    if (remaining === 0) {\n      return settle();\n    }\n\n    for (const path of paths) {\n      const schemaType = schema.path(path);\n      if (schemaType == null) {\n        _checkDone();\n        continue;\n      }\n\n      const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');\n      let cur = obj;\n      for (let i = 0; i < pieces.length - 1; ++i) {\n        cur = cur[pieces[i]];\n      }\n\n      const val = get(obj, path, void 0);\n\n      schemaType.doValidate(val, err => {\n        if (err) {\n          error = error || new ValidationError();\n          error.addError(path, err);\n        }\n        _checkDone();\n      }, context, { path: path });\n    }\n\n    function settle() {\n      if (error) {\n        reject(error);\n      } else {\n        resolve(obj);\n      }\n    }\n\n    function _checkDone() {\n      if (--remaining <= 0) {\n        return settle();\n      }\n    }\n  });\n};\n\n/**\n * Populates document references.\n *\n * Changed in Mongoose 6: the model you call `populate()` on should be the\n * \"local field\" model, **not** the \"foreign field\" model.\n *\n * #### Available top-level options:\n *\n * - path: space delimited path(s) to populate\n * - select: optional fields to select\n * - match: optional query conditions to match\n * - model: optional name of the model to use for population\n * - options: optional query options like sort, limit, etc\n * - justOne: optional boolean, if true Mongoose will always set `path` to a document, or `null` if no document was found. If false, Mongoose will always set `path` to an array, which will be empty if no documents are found. Inferred from schema by default.\n * - strictPopulate: optional boolean, set to `false` to allow populating paths that aren't in the schema.\n * - forceRepopulate: optional boolean, defaults to `true`. Set to `false` to prevent Mongoose from repopulating paths that are already populated\n *\n * #### Example:\n *\n *     const Dog = mongoose.model('Dog', new Schema({ name: String, breed: String }));\n *     const Person = mongoose.model('Person', new Schema({\n *       name: String,\n *       pet: { type: mongoose.ObjectId, ref: 'Dog' }\n *     }));\n *\n *     const pets = await Pet.create([\n *       { name: 'Daisy', breed: 'Beagle' },\n *       { name: 'Einstein', breed: 'Catalan Sheepdog' }\n *     ]);\n *\n *     // populate many plain objects\n *     const users = [\n *       { name: 'John Wick', dog: pets[0]._id },\n *       { name: 'Doc Brown', dog: pets[1]._id }\n *     ];\n *     await User.populate(users, { path: 'dog', select: 'name' });\n *     users[0].dog.name; // 'Daisy'\n *     users[0].dog.breed; // undefined because of `select`\n *\n * @param {Document|Array} docs Either a single document or array of documents to populate.\n * @param {Object|String} options Either the paths to populate or an object specifying all parameters\n * @param {string} [options.path=null] The path to populate.\n * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).\n * @param {boolean} [options.retainNullValues=false] By default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.\n * @param {boolean} [options.getters=false] If true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).\n * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.\n * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.\n * @param {Boolean} [options.skipInvalidIds=false] By default, Mongoose throws a cast error if `localField` and `foreignField` schemas don't line up. If you enable this option, Mongoose will instead filter out any `localField` properties that cannot be casted to `foreignField`'s schema type.\n * @param {Number} [options.perDocumentLimit=null] For legacy reasons, `limit` with `populate()` may give incorrect results because it only executes a single query for every document being populated. If you set `perDocumentLimit`, Mongoose will ensure correct `limit` per document by executing a separate query for each document to `populate()`. For example, `.find().populate({ path: 'test', perDocumentLimit: 2 })` will execute 2 additional queries if `.find()` returns 2 documents.\n * @param {Boolean} [options.strictPopulate=true] Set to false to allow populating paths that aren't defined in the given model's schema.\n * @param {Object} [options.options=null] Additional options like `limit` and `lean`.\n * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.\n * @param {Boolean} [options.forceRepopulate=true] Set to `false` to prevent Mongoose from repopulating paths that are already populated\n * @param {Boolean} [options.ordered=false] Set to `true` to execute any populate queries one at a time, as opposed to in parallel. Set this option to `true` if populating multiple paths or paths with multiple models in transactions.\n * @return {Promise}\n * @api public\n */\n\nModel.populate = async function populate(docs, paths) {\n  _checkContext(this, 'populate');\n  if (typeof paths === 'function' || typeof arguments[2] === 'function') {\n    throw new MongooseError('Model.populate() no longer accepts a callback');\n  }\n  // normalized paths\n  paths = utils.populate(paths);\n\n  if (paths.length === 0) {\n    return docs;\n  }\n\n  // each path has its own query options and must be executed separately\n  if (paths.find(p => p.ordered)) {\n    // Populate in series, primarily for transactions because MongoDB doesn't support multiple operations on\n    // one transaction in parallel.\n    // Note that if _any_ path has `ordered`, we make the top-level populate `ordered` as well.\n    for (const path of paths) {\n      await _populatePath(this, docs, path);\n    }\n  } else {\n    // By default, populate in parallel\n    const promises = [];\n    for (const path of paths) {\n      promises.push(_populatePath(this, docs, path));\n    }\n    await Promise.all(promises);\n  }\n\n  return docs;\n};\n\n/*!\n * Populates `docs` for a single `populateOptions` instance.\n */\nconst excludeIdReg = /\\s?-_id\\s?/;\nconst excludeIdRegGlobal = /\\s?-_id\\s?/g;\n\nasync function _populatePath(model, docs, populateOptions) {\n  if (populateOptions.strictPopulate == null) {\n    if (populateOptions._localModel != null && populateOptions._localModel.schema._userProvidedOptions.strictPopulate != null) {\n      populateOptions.strictPopulate = populateOptions._localModel.schema._userProvidedOptions.strictPopulate;\n    } else if (populateOptions._localModel != null && model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    } else if (model.base.options.strictPopulate != null) {\n      populateOptions.strictPopulate = model.base.options.strictPopulate;\n    }\n  }\n\n  // normalize single / multiple docs passed\n  if (!Array.isArray(docs)) {\n    docs = [docs];\n  }\n  if (docs.length === 0 || docs.every(utils.isNullOrUndefined)) {\n    return;\n  }\n\n  const modelsMap = getModelsMapForPopulate(model, docs, populateOptions);\n  if (modelsMap instanceof MongooseError) {\n    throw modelsMap;\n  }\n  const len = modelsMap.length;\n  let vals = [];\n\n  function flatten(item) {\n    // no need to include undefined values in our query\n    return undefined !== item;\n  }\n\n  let hasOne = false;\n  const params = [];\n  for (let i = 0; i < len; ++i) {\n    const mod = modelsMap[i];\n    let select = mod.options.select;\n    let ids = utils.array.flatten(mod.ids, flatten);\n    ids = utils.array.unique(ids);\n\n    const assignmentOpts = {};\n    assignmentOpts.sort = mod &&\n      mod.options &&\n      mod.options.options &&\n      mod.options.options.sort || void 0;\n    assignmentOpts.excludeId = excludeIdReg.test(select) || (select && select._id === 0);\n\n    // Lean transform may delete `_id`, which would cause assignment\n    // to fail. So delay running lean transform until _after_\n    // `_assign()`\n    if (mod.options &&\n        mod.options.options &&\n        mod.options.options.lean &&\n        mod.options.options.lean.transform) {\n      mod.options.options._leanTransform = mod.options.options.lean.transform;\n      mod.options.options.lean = true;\n    }\n\n    if (ids.length === 0 || ids.every(utils.isNullOrUndefined)) {\n      // Ensure that we set to 0 or empty array even\n      // if we don't actually execute a query to make sure there's a value\n      // and we know this path was populated for future sets. See gh-7731, gh-8230\n      _assign(model, [], mod, assignmentOpts);\n      continue;\n    }\n\n    hasOne = true;\n    if (typeof populateOptions.foreignField === 'string') {\n      mod.foreignField.clear();\n      mod.foreignField.add(populateOptions.foreignField);\n    }\n    const match = createPopulateQueryFilter(ids, mod.match, mod.foreignField, mod.model, mod.options.skipInvalidIds);\n    if (assignmentOpts.excludeId) {\n      // override the exclusion from the query so we can use the _id\n      // for document matching during assignment. we'll delete the\n      // _id back off before returning the result.\n      if (typeof select === 'string') {\n        select = select.replace(excludeIdRegGlobal, ' ');\n      } else if (Array.isArray(select)) {\n        select = select.filter(field => field !== '-_id');\n      } else {\n        // preserve original select conditions by copying\n        select = { ...select };\n        delete select._id;\n      }\n    }\n\n    if (mod.options.options && mod.options.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.options.limit;\n    } else if (mod.options.limit != null) {\n      assignmentOpts.originalLimit = mod.options.limit;\n    }\n    params.push([mod, match, select, assignmentOpts]);\n  }\n  if (!hasOne) {\n    // If models but no docs, skip further deep populate.\n    if (modelsMap.length !== 0) {\n      return;\n    }\n    // If no models and no docs to populate but we have a nested populate,\n    // probably a case of unnecessarily populating a non-ref path re: gh-8946\n    if (populateOptions.populate != null) {\n      const opts = utils.populate(populateOptions.populate).map(pop => Object.assign({}, pop, {\n        path: populateOptions.path + '.' + pop.path\n      }));\n      return model.populate(docs, opts);\n    }\n    return;\n  }\n\n  if (populateOptions.ordered) {\n    // Populate in series, primarily for transactions because MongoDB doesn't support multiple operations on\n    // one transaction in parallel.\n    for (const arr of params) {\n      await _execPopulateQuery.apply(null, arr).then(valsFromDb => { vals = vals.concat(valsFromDb); });\n    }\n  } else {\n    // By default, populate in parallel\n    const promises = [];\n    for (const arr of params) {\n      promises.push(_execPopulateQuery.apply(null, arr).then(valsFromDb => { vals = vals.concat(valsFromDb); }));\n    }\n\n    await Promise.all(promises);\n  }\n\n\n  for (const arr of params) {\n    const mod = arr[0];\n    const assignmentOpts = arr[3];\n    for (const val of vals) {\n      mod.options._childDocs.push(val);\n    }\n    _assign(model, vals, mod, assignmentOpts);\n  }\n\n  for (const arr of params) {\n    removeDeselectedForeignField(arr[0].foreignField, arr[0].options, vals);\n  }\n  for (const arr of params) {\n    const mod = arr[0];\n    if (mod.options && mod.options.options && mod.options.options._leanTransform) {\n      for (const doc of vals) {\n        mod.options.options._leanTransform(doc);\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nfunction _execPopulateQuery(mod, match, select) {\n  let subPopulate = clone(mod.options.populate);\n  const queryOptions = {};\n  if (mod.options.skip !== undefined) {\n    queryOptions.skip = mod.options.skip;\n  }\n  if (mod.options.limit !== undefined) {\n    queryOptions.limit = mod.options.limit;\n  }\n  if (mod.options.perDocumentLimit !== undefined) {\n    queryOptions.perDocumentLimit = mod.options.perDocumentLimit;\n  }\n  Object.assign(queryOptions, mod.options.options);\n\n  if (mod.count) {\n    delete queryOptions.skip;\n  }\n\n  if (queryOptions.perDocumentLimit != null) {\n    queryOptions.limit = queryOptions.perDocumentLimit;\n    delete queryOptions.perDocumentLimit;\n  } else if (queryOptions.limit != null) {\n    queryOptions.limit = queryOptions.limit * mod.ids.length;\n  }\n\n  const query = mod.model.find(match, select, queryOptions);\n  // If we're doing virtual populate and projection is inclusive and foreign\n  // field is not selected, automatically select it because mongoose needs it.\n  // If projection is exclusive and client explicitly unselected the foreign\n  // field, that's the client's fault.\n  for (const foreignField of mod.foreignField) {\n    if (foreignField !== '_id' &&\n        query.selectedInclusively() &&\n        !isPathSelectedInclusive(query._fields, foreignField)) {\n      query.select(foreignField);\n    }\n  }\n\n  // If using count, still need the `foreignField` so we can match counts\n  // to documents, otherwise we would need a separate `count()` for every doc.\n  if (mod.count) {\n    for (const foreignField of mod.foreignField) {\n      query.select(foreignField);\n    }\n  }\n\n  // If we need to sub-populate, call populate recursively\n  if (subPopulate) {\n    // If subpopulating on a discriminator, skip check for non-existent\n    // paths. Because the discriminator may not have the path defined.\n    if (mod.model.baseModelName != null) {\n      if (Array.isArray(subPopulate)) {\n        subPopulate.forEach(pop => { pop.strictPopulate = false; });\n      } else if (typeof subPopulate === 'string') {\n        subPopulate = { path: subPopulate, strictPopulate: false };\n      } else {\n        subPopulate.strictPopulate = false;\n      }\n    }\n    const basePath = mod.options._fullPath || mod.options.path;\n\n    if (Array.isArray(subPopulate)) {\n      for (const pop of subPopulate) {\n        pop._fullPath = basePath + '.' + pop.path;\n      }\n    } else if (typeof subPopulate === 'object') {\n      subPopulate._fullPath = basePath + '.' + subPopulate.path;\n    }\n\n    query.populate(subPopulate);\n  }\n\n  return query.exec().then(\n    docs => {\n      for (const val of docs) {\n        leanPopulateMap.set(val, mod.model);\n      }\n      return docs;\n    }\n  );\n}\n\n/*!\n * ignore\n */\n\nfunction _assign(model, vals, mod, assignmentOpts) {\n  const options = mod.options;\n  const isVirtual = mod.isVirtual;\n  const justOne = mod.justOne;\n  let _val;\n  const lean = options &&\n    options.options &&\n    options.options.lean || false;\n  const len = vals.length;\n  const rawOrder = {};\n  const rawDocs = {};\n  let key;\n  let val;\n\n  // Clone because `assignRawDocsToIdStructure` will mutate the array\n  const allIds = clone(mod.allIds);\n  // optimization:\n  // record the document positions as returned by\n  // the query result.\n  for (let i = 0; i < len; i++) {\n    val = vals[i];\n    if (val == null) {\n      continue;\n    }\n    for (const foreignField of mod.foreignField) {\n      _val = utils.getValue(foreignField, val);\n      if (Array.isArray(_val)) {\n        _val = utils.array.unique(utils.array.flatten(_val));\n\n        for (let __val of _val) {\n          if (__val instanceof Document) {\n            __val = __val._doc._id;\n          }\n          if (__val?.constructor?.name === 'Binary' && __val.sub_type === 4 && typeof __val.toUUID === 'function') {\n            // Workaround for gh-15315 because Mongoose UUIDs don't use BSON UUIDs yet.\n            key = String(__val.toUUID());\n          } else if (__val?.constructor?.name === 'Buffer' && __val._subtype === 4 && typeof __val.toUUID === 'function') {\n            key = String(__val.toUUID());\n          } else {\n            key = String(__val);\n          }\n          if (rawDocs[key]) {\n            if (Array.isArray(rawDocs[key])) {\n              rawDocs[key].push(val);\n              rawOrder[key].push(i);\n            } else {\n              rawDocs[key] = [rawDocs[key], val];\n              rawOrder[key] = [rawOrder[key], i];\n            }\n          } else {\n            if (isVirtual && !justOne) {\n              rawDocs[key] = [val];\n              rawOrder[key] = [i];\n            } else {\n              rawDocs[key] = val;\n              rawOrder[key] = i;\n            }\n          }\n        }\n      } else {\n        if (_val instanceof Document) {\n          _val = _val._doc._id;\n        }\n        if (_val?.constructor?.name === 'Binary' && _val.sub_type === 4 && typeof _val.toUUID === 'function') {\n          // Workaround for gh-15315 because Mongoose UUIDs don't use BSON UUIDs yet.\n          key = String(_val.toUUID());\n        } else if (_val?.constructor?.name === 'Buffer' && _val._subtype === 4 && typeof _val.toUUID === 'function') {\n          key = String(_val.toUUID());\n        } else {\n          key = String(_val);\n        }\n        if (rawDocs[key]) {\n          if (Array.isArray(rawDocs[key])) {\n            rawDocs[key].push(val);\n            rawOrder[key].push(i);\n          } else if (isVirtual ||\n            rawDocs[key].constructor !== val.constructor ||\n            (rawDocs[key] instanceof Document ? String(rawDocs[key]._doc._id) : String(rawDocs[key]._id)) !== (val instanceof Document ? String(val._doc._id) : String(val._id))) {\n            // May need to store multiple docs with the same id if there's multiple models\n            // if we have discriminators or a ref function. But avoid converting to an array\n            // if we have multiple queries on the same model because of `perDocumentLimit` re: gh-9906\n            rawDocs[key] = [rawDocs[key], val];\n            rawOrder[key] = [rawOrder[key], i];\n          }\n        } else {\n          rawDocs[key] = val;\n          rawOrder[key] = i;\n        }\n      }\n      // flag each as result of population\n      if (!lean) {\n        val.$__.wasPopulated = val.$__.wasPopulated || { value: _val };\n      }\n    }\n  }\n\n  assignVals({\n    originalModel: model,\n    // If virtual, make sure to not mutate original field\n    rawIds: mod.isVirtual ? allIds : mod.allIds,\n    allIds: allIds,\n    unpopulatedValues: mod.unpopulatedValues,\n    foreignField: mod.foreignField,\n    rawDocs: rawDocs,\n    rawOrder: rawOrder,\n    docs: mod.docs,\n    path: options.path,\n    options: assignmentOpts,\n    justOne: mod.justOne,\n    isVirtual: mod.isVirtual,\n    allOptions: mod,\n    populatedModel: mod.model,\n    lean: lean,\n    virtual: mod.virtual,\n    count: mod.count,\n    match: mod.match\n  });\n}\n\n/**\n * Compiler utility.\n *\n * @param {String|Function} name model name or class extending Model\n * @param {Schema} schema\n * @param {String} collectionName\n * @param {Connection} connection\n * @param {Mongoose} base mongoose instance\n * @api private\n */\n\nModel.compile = function compile(name, schema, collectionName, connection, base) {\n  const versioningEnabled = schema.options.versionKey !== false;\n\n  if (versioningEnabled && !schema.paths[schema.options.versionKey]) {\n    // add versioning to top level documents only\n    const o = {};\n    o[schema.options.versionKey] = Number;\n    schema.add(o);\n  }\n  let model;\n  if (typeof name === 'function' && name.prototype instanceof Model) {\n    model = name;\n    name = model.name;\n    schema.loadClass(model, false);\n    model.prototype.$isMongooseModelPrototype = true;\n  } else {\n    // generate new class\n    model = function model(doc, fields, skipId) {\n      model.hooks.execPreSync('createModel', doc);\n      if (!(this instanceof model)) {\n        return new model(doc, fields, skipId);\n      }\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (model.discriminators == null || doc == null || doc[discriminatorKey] == null) {\n        Model.call(this, doc, fields, skipId);\n        return;\n      }\n\n      // If discriminator key is set, use the discriminator instead (gh-7586)\n      const Discriminator = model.discriminators[doc[discriminatorKey]] ||\n        getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      if (Discriminator != null) {\n        return new Discriminator(doc, fields, skipId);\n      }\n\n      // Otherwise, just use the top-level model\n      Model.call(this, doc, fields, skipId);\n    };\n  }\n\n  model.hooks = schema.s.hooks.clone();\n  model.base = base;\n  model.modelName = name;\n\n  if (!(model.prototype instanceof Model)) {\n    Object.setPrototypeOf(model, Model);\n    Object.setPrototypeOf(model.prototype, Model.prototype);\n  }\n  model.model = function model(name) {\n    return this.db.model(name);\n  };\n\n  model.db = connection;\n  model.prototype.db = connection;\n  model.prototype[modelDbSymbol] = connection;\n  model.discriminators = model.prototype.discriminators = undefined;\n  model[modelSymbol] = true;\n  model.events = new EventEmitter();\n\n  schema._preCompile();\n\n  const _userProvidedOptions = schema._userProvidedOptions || {};\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: schema.options.capped,\n    Promise: model.base.Promise,\n    modelName: name\n  };\n  if (schema.options.autoCreate !== void 0) {\n    collectionOptions.autoCreate = schema.options.autoCreate;\n  }\n\n  const collection = connection.collection(\n    collectionName,\n    collectionOptions\n  );\n\n  model.prototype.collection = collection;\n  model.prototype.$collection = collection;\n  model.prototype[modelCollectionSymbol] = collection;\n\n  model.prototype.$__setSchema(schema);\n\n  // apply methods and statics\n  applyMethods(model, schema);\n  applyStatics(model, schema);\n  applyHooks(model, schema);\n  applyStaticHooks(model, schema.s.hooks, schema.statics);\n\n  model.schema = model.prototype.$__schema;\n  model.collection = collection;\n  model.$__collection = collection;\n\n  // Create custom query constructor\n  model.Query = function() {\n    Query.apply(this, arguments);\n  };\n  Object.setPrototypeOf(model.Query.prototype, Query.prototype);\n  model.Query.base = Query.base;\n  model.Query.prototype.constructor = Query;\n  model._applyQueryMiddleware();\n  applyQueryMethods(model, schema.query);\n\n  return model;\n};\n\n/**\n * If auto encryption is enabled, returns a ClientEncryption instance that is configured with the same settings that\n * Mongoose's underlying MongoClient is using.  If the client has not yet been configured, returns null.\n *\n * @returns {ClientEncryption | null}\n */\nModel.clientEncryption = function clientEncryption() {\n  const ClientEncryption = this.base.driver.get().ClientEncryption;\n  if (!ClientEncryption) {\n    throw new Error('The mongodb driver must be used to obtain a ClientEncryption object.');\n  }\n\n  const client = this.collection?.conn?.client;\n\n  if (!client) return null;\n\n  const autoEncryptionOptions = client.options.autoEncryption;\n\n  if (!autoEncryptionOptions) return null;\n\n  const {\n    keyVaultNamespace,\n    keyVaultClient,\n    kmsProviders,\n    credentialProviders,\n    proxyOptions,\n    tlsOptions\n  } = autoEncryptionOptions;\n  return new ClientEncryption(keyVaultClient ?? client,\n    { keyVaultNamespace, kmsProviders, credentialProviders, proxyOptions, tlsOptions }\n  );\n};\n\n/**\n * Update this model to use the new connection, including updating all internal\n * references and creating a new `Collection` instance using the new connection.\n * Not for external use, only used by `setDriver()` to ensure that you can still\n * call `setDriver()` after creating a model using `mongoose.model()`.\n *\n * @param {Connection} newConnection the new connection to use\n * @api private\n */\n\nModel.$__updateConnection = function $__updateConnection(newConnection) {\n  this.db = newConnection;\n  this.prototype.db = newConnection;\n  this.prototype[modelDbSymbol] = newConnection;\n\n  const collection = newConnection.collection(\n    this.collection.collectionName,\n    this.collection.opts\n  );\n\n  this.prototype.collection = collection;\n  this.prototype.$collection = collection;\n  this.prototype[modelCollectionSymbol] = collection;\n\n  this.collection = collection;\n  this.$__collection = collection;\n};\n\n/**\n * Register custom query methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nfunction applyQueryMethods(model, methods) {\n  for (const i in methods) {\n    model.Query.prototype[i] = methods[i];\n  }\n}\n\n/**\n * Subclass this model with `conn`, `schema`, and `collection` settings.\n *\n * @param {Connection} conn\n * @param {Schema} [schema]\n * @param {String} [collection]\n * @return {Model}\n * @api private\n * @memberOf Model\n * @static\n * @method __subclass\n */\n\nModel.__subclass = function subclass(conn, schema, collection) {\n  // subclass model using this connection and collection name\n  const _this = this;\n\n  const Model = function Model(doc, fields, skipId) {\n    if (!(this instanceof Model)) {\n      return new Model(doc, fields, skipId);\n    }\n    _this.call(this, doc, fields, skipId);\n  };\n\n  Object.setPrototypeOf(Model, _this);\n  Object.setPrototypeOf(Model.prototype, _this.prototype);\n  Model.db = conn;\n  Model.prototype.db = conn;\n  Model.prototype[modelDbSymbol] = conn;\n\n  _this[subclassedSymbol] = _this[subclassedSymbol] || [];\n  _this[subclassedSymbol].push(Model);\n  if (_this.discriminators != null) {\n    Model.discriminators = {};\n    for (const key of Object.keys(_this.discriminators)) {\n      Model.discriminators[key] = _this.discriminators[key].\n        __subclass(_this.db, _this.discriminators[key].schema, collection);\n    }\n  }\n\n  const s = schema && typeof schema !== 'string'\n    ? schema\n    : _this.prototype.$__schema;\n\n  const options = s.options || {};\n  const _userProvidedOptions = s._userProvidedOptions || {};\n\n  if (!collection) {\n    collection = _this.prototype.$__schema.get('collection') ||\n      utils.toCollectionName(_this.modelName, this.base.pluralize());\n  }\n\n  const collectionOptions = {\n    schemaUserProvidedOptions: _userProvidedOptions,\n    capped: s && options.capped\n  };\n\n  Model.prototype.collection = conn.collection(collection, collectionOptions);\n  Model.prototype.$collection = Model.prototype.collection;\n  Model.prototype[modelCollectionSymbol] = Model.prototype.collection;\n  Model.collection = Model.prototype.collection;\n  Model.$__collection = Model.collection;\n  // Errors handled internally, so ignore\n  Model.init().catch(() => {});\n  return Model;\n};\n\n/**\n * Apply changes made to this model's schema after this model was compiled.\n * By default, adding virtuals and other properties to a schema after the model is compiled does nothing.\n * Call this function to apply virtuals and properties that were added later.\n *\n * #### Example:\n *\n *     const schema = new mongoose.Schema({ field: String });\n *     const TestModel = mongoose.model('Test', schema);\n *     TestModel.schema.virtual('myVirtual').get(function() {\n *       return this.field + ' from myVirtual';\n *     });\n *     const doc = new TestModel({ field: 'Hello' });\n *     doc.myVirtual; // undefined\n *\n *     TestModel.recompileSchema();\n *     doc.myVirtual; // 'Hello from myVirtual'\n *\n * @return {undefined}\n * @api public\n * @memberOf Model\n * @static\n * @method recompileSchema\n */\n\nModel.recompileSchema = function recompileSchema() {\n  this.prototype.$__setSchema(this.schema);\n\n  if (this.schema._applyDiscriminators != null) {\n    for (const disc of this.schema._applyDiscriminators.keys()) {\n      this.discriminator(disc, this.schema._applyDiscriminators.get(disc));\n    }\n  }\n\n  delete this.schema._defaultToObjectOptionsMap;\n\n  applyEmbeddedDiscriminators(this.schema, new WeakSet(), true);\n};\n\n/**\n * Helper for console.log. Given a model named 'MyModel', returns the string\n * `'Model { MyModel }'`.\n *\n * #### Example:\n *\n *     const MyModel = mongoose.model('Test', Schema({ name: String }));\n *     MyModel.inspect(); // 'Model { Test }'\n *     console.log(MyModel); // Prints 'Model { Test }'\n *\n * @api public\n */\n\nModel.inspect = function() {\n  return `Model { ${this.modelName} }`;\n};\n\n/**\n * Return the MongoDB namespace for this model as a string. The namespace is the database name, followed by '.', followed by the collection name.\n *\n * #### Example:\n *\n *     const conn = mongoose.createConnection('mongodb://127.0.0.1:27017/mydb');\n *     const TestModel = conn.model('Test', mongoose.Schema({ name: String }));\n *\n *     TestModel.namespace(); // 'mydb.tests'\n *\n * @api public\n */\n\nModel.namespace = function namespace() {\n  return this.db.name + '.' + this.collection.collectionName;\n};\n\nif (util.inspect.custom) {\n  // Avoid Node deprecation warning DEP0079\n  Model[util.inspect.custom] = Model.inspect;\n}\n\n/*!\n * Applies query middleware from this model's schema to this model's\n * Query constructor.\n */\n\nModel._applyQueryMiddleware = function _applyQueryMiddleware() {\n  const Query = this.Query;\n  const queryMiddleware = this.schema.s.hooks.filter(hook => {\n    const contexts = _getContexts(hook);\n    if (hook.name === 'validate') {\n      return !!contexts.query;\n    }\n    if (hook.name === 'deleteOne' || hook.name === 'updateOne') {\n      return !!contexts.query || Object.keys(contexts).length === 0;\n    }\n    if (hook.query != null || hook.document != null) {\n      return !!hook.query;\n    }\n    return true;\n  });\n\n  Query.prototype._queryMiddleware = queryMiddleware;\n};\n\nfunction _getContexts(hook) {\n  const ret = {};\n  if (hook.hasOwnProperty('query')) {\n    ret.query = hook.query;\n  }\n  if (hook.hasOwnProperty('document')) {\n    ret.document = hook.document;\n  }\n  return ret;\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = exports = Model;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}}]
}