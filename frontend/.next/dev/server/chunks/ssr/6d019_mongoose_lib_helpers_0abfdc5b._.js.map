{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/immediate.js"],"sourcesContent":["/*!\n * Centralize this so we can more easily work around issues with people\n * stubbing out `process.nextTick()` in tests using sinon:\n * https://github.com/sinonjs/lolex#automatically-incrementing-mocked-time\n * See gh-6074\n */\n\n'use strict';\n\nconst nextTick = typeof process !== 'undefined' && typeof process.nextTick === 'function' ?\n  process.nextTick.bind(process) :\n  cb => setTimeout(cb, 0); // Fallback for browser build\n\nmodule.exports = function immediate(cb) {\n  return nextTick(cb);\n};\n"],"names":[],"mappings":"AAAA;;;;;CAKC,GAID,MAAM,WAAW,OAAO,YAAY,eAAe,OAAO,QAAQ,QAAQ,KAAK,aAC7E,QAAQ,QAAQ,CAAC,IAAI,CAAC,WACtB,CAAA,KAAM,WAAW,IAAI,IAAI,6BAA6B;AAExD,OAAO,OAAO,GAAG,SAAS,UAAU,EAAE;IACpC,OAAO,SAAS;AAClB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 17, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/symbols.js"],"sourcesContent":["'use strict';\n\nexports.arrayAtomicsBackupSymbol = Symbol('mongoose#Array#atomicsBackup');\nexports.arrayAtomicsSymbol = Symbol('mongoose#Array#_atomics');\nexports.arrayParentSymbol = Symbol('mongoose#Array#_parent');\nexports.arrayPathSymbol = Symbol('mongoose#Array#_path');\nexports.arraySchemaSymbol = Symbol('mongoose#Array#_schema');\nexports.documentArrayParent = Symbol('mongoose#documentArrayParent');\nexports.documentIsSelected = Symbol('mongoose#Document#isSelected');\nexports.documentIsModified = Symbol('mongoose#Document#isModified');\nexports.documentModifiedPaths = Symbol('mongoose#Document#modifiedPaths');\nexports.documentSchemaSymbol = Symbol('mongoose#Document#schema');\nexports.getSymbol = Symbol('mongoose#Document#get');\nexports.modelSymbol = Symbol('mongoose#Model');\nexports.objectIdSymbol = Symbol('mongoose#ObjectId');\nexports.populateModelSymbol = Symbol('mongoose#PopulateOptions#Model');\nexports.schemaTypeSymbol = Symbol('mongoose#schemaType');\nexports.sessionNewDocuments = Symbol('mongoose#ClientSession#newDocuments');\nexports.scopeSymbol = Symbol('mongoose#Document#scope');\nexports.validatorErrorSymbol = Symbol('mongoose#validatorError');\n"],"names":[],"mappings":"AAEA,QAAQ,wBAAwB,GAAG,OAAO;AAC1C,QAAQ,kBAAkB,GAAG,OAAO;AACpC,QAAQ,iBAAiB,GAAG,OAAO;AACnC,QAAQ,eAAe,GAAG,OAAO;AACjC,QAAQ,iBAAiB,GAAG,OAAO;AACnC,QAAQ,mBAAmB,GAAG,OAAO;AACrC,QAAQ,kBAAkB,GAAG,OAAO;AACpC,QAAQ,kBAAkB,GAAG,OAAO;AACpC,QAAQ,qBAAqB,GAAG,OAAO;AACvC,QAAQ,oBAAoB,GAAG,OAAO;AACtC,QAAQ,SAAS,GAAG,OAAO;AAC3B,QAAQ,WAAW,GAAG,OAAO;AAC7B,QAAQ,cAAc,GAAG,OAAO;AAChC,QAAQ,mBAAmB,GAAG,OAAO;AACrC,QAAQ,gBAAgB,GAAG,OAAO;AAClC,QAAQ,mBAAmB,GAAG,OAAO;AACrC,QAAQ,WAAW,GAAG,OAAO;AAC7B,QAAQ,oBAAoB,GAAG,OAAO","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/getConstructorName.js"],"sourcesContent":["'use strict';\n\n/**\n * If `val` is an object, returns constructor name, if possible. Otherwise returns undefined.\n * @api private\n */\n\nmodule.exports = function getConstructorName(val) {\n  if (val == null) {\n    return void 0;\n  }\n  if (typeof val.constructor !== 'function') {\n    return void 0;\n  }\n  return val.constructor.name;\n};\n"],"names":[],"mappings":"AAEA;;;CAGC,GAED,OAAO,OAAO,GAAG,SAAS,mBAAmB,GAAG;IAC9C,IAAI,OAAO,MAAM;QACf,OAAO,KAAK;IACd;IACA,IAAI,OAAO,IAAI,WAAW,KAAK,YAAY;QACzC,OAAO,KAAK;IACd;IACA,OAAO,IAAI,WAAW,CAAC,IAAI;AAC7B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 55, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/specialProperties.js"],"sourcesContent":["'use strict';\n\nmodule.exports = new Set(['__proto__', 'constructor', 'prototype']);\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,IAAI,IAAI;IAAC;IAAa;IAAe;CAAY","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/isMongooseObject.js"],"sourcesContent":["'use strict';\n\nconst isMongooseArray = require('../types/array/isMongooseArray').isMongooseArray;\n/**\n * Returns if `v` is a mongoose object that has a `toObject()` method we can use.\n *\n * This is for compatibility with libs like Date.js which do foolish things to Natives.\n *\n * @param {Any} v\n * @api private\n */\n\nmodule.exports = function(v) {\n  return (\n    v != null && (\n      isMongooseArray(v) || // Array or Document Array\n      v.$__ != null || // Document\n      v.isMongooseBuffer || // Buffer\n      v.$isMongooseMap // Map\n    )\n  );\n};\n"],"names":[],"mappings":"AAEA,MAAM,kBAAkB,yHAA0C,eAAe;AACjF;;;;;;;CAOC,GAED,OAAO,OAAO,GAAG,SAAS,CAAC;IACzB,OACE,KAAK,QAAQ,CACX,gBAAgB,MAAM,0BAA0B;IAChD,EAAE,GAAG,IAAI,QAAQ,WAAW;IAC5B,EAAE,gBAAgB,IAAI,SAAS;IAC/B,EAAE,cAAc,CAAC,MAAM;IACzB;AAEJ","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 83, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/getFunctionName.js"],"sourcesContent":["'use strict';\n\nconst functionNameRE = /^function\\s*([^\\s(]+)/;\n\nmodule.exports = function(fn) {\n  return (\n    fn.name ||\n    (fn.toString().trim().match(functionNameRE) || [])[1]\n  );\n};\n"],"names":[],"mappings":"AAEA,MAAM,iBAAiB;AAEvB,OAAO,OAAO,GAAG,SAAS,EAAE;IAC1B,OACE,GAAG,IAAI,IACP,CAAC,GAAG,QAAQ,GAAG,IAAI,GAAG,KAAK,CAAC,mBAAmB,EAAE,CAAC,CAAC,EAAE;AAEzD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 91, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/isBsonType.js"],"sourcesContent":["'use strict';\n\n/**\n * Get the bson type, if it exists\n * @api private\n */\n\nfunction isBsonType(obj, typename) {\n  return (\n    obj != null &&\n    obj._bsontype === typename\n  );\n}\n\nmodule.exports = isBsonType;\n"],"names":[],"mappings":"AAEA;;;CAGC,GAED,SAAS,WAAW,GAAG,EAAE,QAAQ;IAC/B,OACE,OAAO,QACP,IAAI,SAAS,KAAK;AAEtB;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 102, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/isObject.js"],"sourcesContent":["'use strict';\n\n/**\n * Determines if `arg` is an object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nmodule.exports = function(arg) {\n  return (\n    Buffer.isBuffer(arg) ||\n    Object.prototype.toString.call(arg) === '[object Object]'\n  );\n};\n"],"names":[],"mappings":"AAEA;;;;;;CAMC,GAED,OAAO,OAAO,GAAG,SAAS,GAAG;IAC3B,OACE,OAAO,QAAQ,CAAC,QAChB,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS;AAE5C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 115, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/isPOJO.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function isPOJO(arg) {\n  if (arg == null || typeof arg !== 'object') {\n    return false;\n  }\n  const proto = Object.getPrototypeOf(arg);\n  // Prototype may be null if you used `Object.create(null)`\n  // Checking `proto`'s constructor is safe because `getPrototypeOf()`\n  // explicitly crosses the boundary from object data to object metadata\n  return !proto || proto.constructor.name === 'Object';\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,OAAO,GAAG;IAClC,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;QAC1C,OAAO;IACT;IACA,MAAM,QAAQ,OAAO,cAAc,CAAC;IACpC,0DAA0D;IAC1D,oEAAoE;IACpE,sEAAsE;IACtE,OAAO,CAAC,SAAS,MAAM,WAAW,CAAC,IAAI,KAAK;AAC9C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 129, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/trusted.js"],"sourcesContent":["'use strict';\n\nconst trustedSymbol = Symbol('mongoose#trustedSymbol');\n\nexports.trustedSymbol = trustedSymbol;\n\nexports.trusted = function trusted(obj) {\n  if (obj == null || typeof obj !== 'object') {\n    return obj;\n  }\n  obj[trustedSymbol] = true;\n  return obj;\n};\n"],"names":[],"mappings":"AAEA,MAAM,gBAAgB,OAAO;AAE7B,QAAQ,aAAa,GAAG;AAExB,QAAQ,OAAO,GAAG,SAAS,QAAQ,GAAG;IACpC,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;QAC1C,OAAO;IACT;IACA,GAAG,CAAC,cAAc,GAAG;IACrB,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 142, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/clone.js"],"sourcesContent":["'use strict';\n\nconst Decimal = require('../types/decimal128');\nconst ObjectId = require('../types/objectid');\nconst specialProperties = require('./specialProperties');\nconst isMongooseObject = require('./isMongooseObject');\nconst getFunctionName = require('./getFunctionName');\nconst isBsonType = require('./isBsonType');\nconst isMongooseArray = require('../types/array/isMongooseArray').isMongooseArray;\nconst isObject = require('./isObject');\nconst isPOJO = require('./isPOJO');\nconst symbols = require('./symbols');\nconst trustedSymbol = require('./query/trusted').trustedSymbol;\nconst BSON = require('bson');\n\n/**\n * Object clone with Mongoose natives support.\n *\n * If options.minimize is true, creates a minimal data object. Empty objects and undefined values will not be cloned. This makes the data payload sent to MongoDB as small as possible.\n *\n * Functions and primitives are never cloned.\n *\n * @param {Object} obj the object to clone\n * @param {Object} options\n * @param {Boolean} isArrayChild true if cloning immediately underneath an array. Special case for minimize.\n * @return {Object} the cloned object\n * @api private\n */\n\nfunction clone(obj, options, isArrayChild) {\n  if (obj == null) {\n    return obj;\n  }\n\n  if (isBsonType(obj, 'Double')) {\n    return new BSON.Double(obj.value);\n  }\n  if (typeof obj === 'number' || typeof obj === 'string' || typeof obj === 'boolean' || typeof obj === 'bigint') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return cloneArray(obj, options);\n  }\n\n  if (isMongooseObject(obj)) {\n    if (options) {\n      if (options.retainDocuments && obj.$__ != null) {\n        const clonedDoc = obj.$clone();\n        if (obj.__index != null) {\n          clonedDoc.__index = obj.__index;\n        }\n        if (obj.__parentArray != null) {\n          clonedDoc.__parentArray = obj.__parentArray;\n        }\n        clonedDoc.$__parent = obj.$__parent;\n        return clonedDoc;\n      }\n    }\n\n    if (isPOJO(obj) && obj.$__ != null && obj._doc != null) {\n      return obj._doc;\n    }\n\n    let ret;\n    if (options && options.json && typeof obj.toJSON === 'function') {\n      ret = obj.toJSON(options);\n    } else {\n      ret = obj.toObject(options);\n    }\n\n    return ret;\n  }\n\n  const objConstructor = obj.constructor;\n\n  if (objConstructor) {\n    switch (getFunctionName(objConstructor)) {\n      case 'Object':\n        return cloneObject(obj, options, isArrayChild);\n      case 'Date':\n        return new objConstructor(+obj);\n      case 'RegExp':\n        return cloneRegExp(obj);\n      default:\n        // ignore\n        break;\n    }\n  }\n\n  if (isBsonType(obj, 'ObjectId')) {\n    if (options && options.flattenObjectIds) {\n      return obj.toJSON();\n    }\n    return new ObjectId(obj.id);\n  }\n\n  if (isBsonType(obj, 'Decimal128')) {\n    if (options && options.flattenDecimals) {\n      return obj.toJSON();\n    }\n    return Decimal.fromString(obj.toString());\n  }\n\n  // object created with Object.create(null)\n  if (!objConstructor && isObject(obj)) {\n    return cloneObject(obj, options, isArrayChild);\n  }\n\n  if (typeof obj === 'object' && obj[symbols.schemaTypeSymbol]) {\n    return obj.clone();\n  }\n\n  // If we're cloning this object to go into a MongoDB command,\n  // and there's a `toBSON()` function, assume this object will be\n  // stored as a primitive in MongoDB and doesn't need to be cloned.\n  if (options && options.bson && typeof obj.toBSON === 'function') {\n    return obj;\n  }\n\n  if (typeof obj.valueOf === 'function') {\n    return obj.valueOf();\n  }\n\n  return cloneObject(obj, options, isArrayChild);\n}\nmodule.exports = clone;\n\n/*!\n * ignore\n */\n\nfunction cloneObject(obj, options, isArrayChild) {\n  const minimize = options && options.minimize;\n  const omitUndefined = options && options.omitUndefined;\n  const seen = options && options._seen;\n  const ret = {};\n  let hasKeys;\n\n  if (seen && seen.has(obj)) {\n    return seen.get(obj);\n  } else if (seen) {\n    seen.set(obj, ret);\n  }\n  if (trustedSymbol in obj && options?.copyTrustedSymbol !== false) {\n    ret[trustedSymbol] = obj[trustedSymbol];\n  }\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    const key = keys[i];\n    if (specialProperties.has(key)) {\n      continue;\n    }\n\n    // Don't pass `isArrayChild` down\n    const val = clone(obj[key], options, false);\n\n    if ((minimize === false || omitUndefined) && typeof val === 'undefined') {\n      delete ret[key];\n    } else if (minimize !== true || (typeof val !== 'undefined')) {\n      hasKeys || (hasKeys = true);\n      ret[key] = val;\n    }\n  }\n\n  return minimize && !isArrayChild ? hasKeys && ret : ret;\n}\n\nfunction cloneArray(arr, options) {\n  let i = 0;\n  const len = arr.length;\n\n  let ret = null;\n  if (options?.retainDocuments) {\n    if (arr.isMongooseDocumentArray) {\n      ret = new (arr.$schemaType().schema.base.Types.DocumentArray)([], arr.$path(), arr.$parent(), arr.$schemaType());\n    } else if (arr.isMongooseArray) {\n      ret = new (arr.$parent().schema.base.Types.Array)([], arr.$path(), arr.$parent(), arr.$schemaType());\n    } else {\n      ret = new Array(len);\n    }\n  } else {\n    ret = new Array(len);\n  }\n\n  arr = isMongooseArray(arr) ? arr.__array : arr;\n  for (i = 0; i < len; ++i) {\n    ret[i] = clone(arr[i], options, true);\n  }\n\n  return ret;\n}\n\nfunction cloneRegExp(regexp) {\n  const ret = new RegExp(regexp.source, regexp.flags);\n\n  if (ret.lastIndex !== regexp.lastIndex) {\n    ret.lastIndex = regexp.lastIndex;\n  }\n  return ret;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 314, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/error/combinePathErrors.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function combinePathErrors(err) {\n  const keys = Object.keys(err.errors || {});\n  const len = keys.length;\n  const msgs = [];\n  let key;\n\n  for (let i = 0; i < len; ++i) {\n    key = keys[i];\n    if (err === err.errors[key]) {\n      continue;\n    }\n    msgs.push(key + ': ' + err.errors[key].message);\n  }\n\n  return msgs.join(', ');\n};\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,kBAAkB,GAAG;IAC7C,MAAM,OAAO,OAAO,IAAI,CAAC,IAAI,MAAM,IAAI,CAAC;IACxC,MAAM,MAAM,KAAK,MAAM;IACvB,MAAM,OAAO,EAAE;IACf,IAAI;IAEJ,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE,EAAG;QAC5B,MAAM,IAAI,CAAC,EAAE;QACb,IAAI,QAAQ,IAAI,MAAM,CAAC,IAAI,EAAE;YAC3B;QACF;QACA,KAAK,IAAI,CAAC,MAAM,OAAO,IAAI,MAAM,CAAC,IAAI,CAAC,OAAO;IAChD;IAEA,OAAO,KAAK,IAAI,CAAC;AACnB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 334, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/topology/allServersUnknown.js"],"sourcesContent":["'use strict';\n\nconst getConstructorName = require('../getConstructorName');\n\nmodule.exports = function allServersUnknown(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  const servers = Array.from(topologyDescription.servers.values());\n  return servers.length > 0 && servers.every(server => server.type === 'Unknown');\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,kBAAkB,mBAAmB;IAC7D,IAAI,mBAAmB,yBAAyB,uBAAuB;QACrE,OAAO;IACT;IAEA,MAAM,UAAU,MAAM,IAAI,CAAC,oBAAoB,OAAO,CAAC,MAAM;IAC7D,OAAO,QAAQ,MAAM,GAAG,KAAK,QAAQ,KAAK,CAAC,CAAA,SAAU,OAAO,IAAI,KAAK;AACvE","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 346, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/topology/isAtlas.js"],"sourcesContent":["'use strict';\n\nconst getConstructorName = require('../getConstructorName');\n\n/**\n * @typedef { import('mongodb').TopologyDescription } TopologyDescription\n */\n\n/**\n * Checks if topologyDescription contains servers connected to an atlas instance\n *\n * @param  {TopologyDescription} topologyDescription\n * @returns {boolean}\n */\nmodule.exports = function isAtlas(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  if (topologyDescription.servers.size === 0) {\n    return false;\n  }\n\n  for (const server of topologyDescription.servers.values()) {\n    if (server.host.endsWith('.mongodb.net') === false || server.port !== 27017) {\n      return false;\n    }\n  }\n\n  return true;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;CAEC,GAED;;;;;CAKC,GACD,OAAO,OAAO,GAAG,SAAS,QAAQ,mBAAmB;IACnD,IAAI,mBAAmB,yBAAyB,uBAAuB;QACrE,OAAO;IACT;IAEA,IAAI,oBAAoB,OAAO,CAAC,IAAI,KAAK,GAAG;QAC1C,OAAO;IACT;IAEA,KAAK,MAAM,UAAU,oBAAoB,OAAO,CAAC,MAAM,GAAI;QACzD,IAAI,OAAO,IAAI,CAAC,QAAQ,CAAC,oBAAoB,SAAS,OAAO,IAAI,KAAK,OAAO;YAC3E,OAAO;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 372, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/topology/isSSLError.js"],"sourcesContent":["'use strict';\n\nconst getConstructorName = require('../getConstructorName');\n\nconst nonSSLMessage = 'Client network socket disconnected before secure TLS ' +\n  'connection was established';\n\nmodule.exports = function isSSLError(topologyDescription) {\n  if (getConstructorName(topologyDescription) !== 'TopologyDescription') {\n    return false;\n  }\n\n  const descriptions = Array.from(topologyDescription.servers.values());\n  return descriptions.length > 0 &&\n    descriptions.every(descr => descr.error && descr.error.message.indexOf(nonSSLMessage) !== -1);\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,MAAM,gBAAgB,0DACpB;AAEF,OAAO,OAAO,GAAG,SAAS,WAAW,mBAAmB;IACtD,IAAI,mBAAmB,yBAAyB,uBAAuB;QACrE,OAAO;IACT;IAEA,MAAM,eAAe,MAAM,IAAI,CAAC,oBAAoB,OAAO,CAAC,MAAM;IAClE,OAAO,aAAa,MAAM,GAAG,KAC3B,aAAa,KAAK,CAAC,CAAA,QAAS,MAAM,KAAK,IAAI,MAAM,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,mBAAmB,CAAC;AAC/F","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 385, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schematype/handleImmutable.js"],"sourcesContent":["'use strict';\n\nconst StrictModeError = require('../../error/strict');\n\n/*!\n * ignore\n */\n\nmodule.exports = function(schematype) {\n  if (schematype.$immutable) {\n    schematype.$immutableSetter = createImmutableSetter(schematype.path,\n      schematype.options.immutable);\n    schematype.set(schematype.$immutableSetter);\n  } else if (schematype.$immutableSetter) {\n    schematype.setters = schematype.setters.\n      filter(fn => fn !== schematype.$immutableSetter);\n    delete schematype.$immutableSetter;\n  }\n};\n\nfunction createImmutableSetter(path, immutable) {\n  return function immutableSetter(v, _priorVal, _doc, options) {\n    if (this == null || this.$__ == null) {\n      return v;\n    }\n    if (this.isNew) {\n      return v;\n    }\n    if (options && options.overwriteImmutable) {\n      return v;\n    }\n\n    const _immutable = typeof immutable === 'function' ?\n      immutable.call(this, this) :\n      immutable;\n    if (!_immutable) {\n      return v;\n    }\n\n    const _value = this.$__.priorDoc != null ?\n      this.$__.priorDoc.$__getValue(path) :\n      this.$__getValue(path);\n    if (this.$__.strictMode === 'throw' && v !== _value) {\n      throw new StrictModeError(path, 'Path `' + path + '` is immutable ' +\n        'and strict mode is set to throw.', true);\n    }\n\n    return _value;\n  };\n}\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,UAAU;IAClC,IAAI,WAAW,UAAU,EAAE;QACzB,WAAW,gBAAgB,GAAG,sBAAsB,WAAW,IAAI,EACjE,WAAW,OAAO,CAAC,SAAS;QAC9B,WAAW,GAAG,CAAC,WAAW,gBAAgB;IAC5C,OAAO,IAAI,WAAW,gBAAgB,EAAE;QACtC,WAAW,OAAO,GAAG,WAAW,OAAO,CACrC,MAAM,CAAC,CAAA,KAAM,OAAO,WAAW,gBAAgB;QACjD,OAAO,WAAW,gBAAgB;IACpC;AACF;AAEA,SAAS,sBAAsB,IAAI,EAAE,SAAS;IAC5C,OAAO,SAAS,gBAAgB,CAAC,EAAE,SAAS,EAAE,IAAI,EAAE,OAAO;QACzD,IAAI,IAAI,IAAI,QAAQ,IAAI,CAAC,GAAG,IAAI,MAAM;YACpC,OAAO;QACT;QACA,IAAI,IAAI,CAAC,KAAK,EAAE;YACd,OAAO;QACT;QACA,IAAI,WAAW,QAAQ,kBAAkB,EAAE;YACzC,OAAO;QACT;QAEA,MAAM,aAAa,OAAO,cAAc,aACtC,UAAU,IAAI,CAAC,IAAI,EAAE,IAAI,IACzB;QACF,IAAI,CAAC,YAAY;YACf,OAAO;QACT;QAEA,MAAM,SAAS,IAAI,CAAC,GAAG,CAAC,QAAQ,IAAI,OAClC,IAAI,CAAC,GAAG,CAAC,QAAQ,CAAC,WAAW,CAAC,QAC9B,IAAI,CAAC,WAAW,CAAC;QACnB,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,KAAK,WAAW,MAAM,QAAQ;YACnD,MAAM,IAAI,gBAAgB,MAAM,WAAW,OAAO,oBAChD,oCAAoC;QACxC;QAEA,OAAO;IACT;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/isAsyncFunction.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function isAsyncFunction(v) {\n  return (\n    typeof v === 'function' &&\n    v.constructor &&\n    v.constructor.name === 'AsyncFunction'\n  );\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,gBAAgB,CAAC;IACzC,OACE,OAAO,MAAM,cACb,EAAE,WAAW,IACb,EAAE,WAAW,CAAC,IAAI,KAAK;AAE3B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 430, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/isSimpleValidator.js"],"sourcesContent":["'use strict';\n\n/**\n * Determines if `arg` is a flat object.\n *\n * @param {Object|Array|String|Function|RegExp|any} arg\n * @api private\n * @return {Boolean}\n */\n\nmodule.exports = function isSimpleValidator(obj) {\n  const keys = Object.keys(obj);\n  let result = true;\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    if (typeof obj[keys[i]] === 'object' && obj[keys[i]] !== null) {\n      result = false;\n      break;\n    }\n  }\n\n  return result;\n};\n"],"names":[],"mappings":"AAEA;;;;;;CAMC,GAED,OAAO,OAAO,GAAG,SAAS,kBAAkB,GAAG;IAC7C,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,MAAM,KAAK,MAAM,EAAE,IAAI,KAAK,EAAE,EAAG;QAC/C,IAAI,OAAO,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,YAAY,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,MAAM;YAC7D,SAAS;YACT;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 451, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/promiseOrCallback.js"],"sourcesContent":["'use strict';\n\nconst immediate = require('./immediate');\n\nconst emittedSymbol = Symbol('mongoose#emitted');\n\nmodule.exports = function promiseOrCallback(callback, fn, ee, Promise) {\n  if (typeof callback === 'function') {\n    try {\n      return fn(function(error) {\n        if (error != null) {\n          if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n            error[emittedSymbol] = true;\n            ee.emit('error', error);\n          }\n          try {\n            callback(error);\n          } catch (error) {\n            return immediate(() => {\n              throw error;\n            });\n          }\n          return;\n        }\n        callback.apply(this, arguments);\n      });\n    } catch (error) {\n      if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n        error[emittedSymbol] = true;\n        ee.emit('error', error);\n      }\n\n      return callback(error);\n    }\n  }\n\n  Promise = Promise || global.Promise;\n\n  return new Promise((resolve, reject) => {\n    fn(function(error, res) {\n      if (error != null) {\n        if (ee != null && ee.listeners != null && ee.listeners('error').length > 0 && !error[emittedSymbol]) {\n          error[emittedSymbol] = true;\n          ee.emit('error', error);\n        }\n        return reject(error);\n      }\n      if (arguments.length > 2) {\n        return resolve(Array.prototype.slice.call(arguments, 1));\n      }\n      resolve(res);\n    });\n  });\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,MAAM,gBAAgB,OAAO;AAE7B,OAAO,OAAO,GAAG,SAAS,kBAAkB,QAAQ,EAAE,EAAE,EAAE,EAAE,EAAE,OAAO;IACnE,IAAI,OAAO,aAAa,YAAY;QAClC,IAAI;YACF,OAAO,GAAG,SAAS,KAAK;gBACtB,IAAI,SAAS,MAAM;oBACjB,IAAI,MAAM,QAAQ,GAAG,SAAS,IAAI,QAAQ,GAAG,SAAS,CAAC,SAAS,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE;wBACnG,KAAK,CAAC,cAAc,GAAG;wBACvB,GAAG,IAAI,CAAC,SAAS;oBACnB;oBACA,IAAI;wBACF,SAAS;oBACX,EAAE,OAAO,OAAO;wBACd,OAAO,UAAU;4BACf,MAAM;wBACR;oBACF;oBACA;gBACF;gBACA,SAAS,KAAK,CAAC,IAAI,EAAE;YACvB;QACF,EAAE,OAAO,OAAO;YACd,IAAI,MAAM,QAAQ,GAAG,SAAS,IAAI,QAAQ,GAAG,SAAS,CAAC,SAAS,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE;gBACnG,KAAK,CAAC,cAAc,GAAG;gBACvB,GAAG,IAAI,CAAC,SAAS;YACnB;YAEA,OAAO,SAAS;QAClB;IACF;IAEA,UAAU,WAAW,yDAAO,OAAO;IAEnC,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,GAAG,SAAS,KAAK,EAAE,GAAG;YACpB,IAAI,SAAS,MAAM;gBACjB,IAAI,MAAM,QAAQ,GAAG,SAAS,IAAI,QAAQ,GAAG,SAAS,CAAC,SAAS,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,cAAc,EAAE;oBACnG,KAAK,CAAC,cAAc,GAAG;oBACvB,GAAG,IAAI,CAAC,SAAS;gBACnB;gBACA,OAAO,OAAO;YAChB;YACA,IAAI,UAAU,MAAM,GAAG,GAAG;gBACxB,OAAO,QAAQ,MAAM,SAAS,CAAC,KAAK,CAAC,IAAI,CAAC,WAAW;YACvD;YACA,QAAQ;QACV;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 502, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/merge.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function merge(s1, s2, skipConflictingPaths) {\n  const paths = Object.keys(s2.tree);\n  const pathsToAdd = {};\n  for (const key of paths) {\n    if (skipConflictingPaths && (s1.paths[key] || s1.nested[key] || s1.singleNestedPaths[key])) {\n      continue;\n    }\n    pathsToAdd[key] = s2.tree[key];\n  }\n  s1.options._isMerging = true;\n  s1.add(pathsToAdd, null);\n  delete s1.options._isMerging;\n\n  s1.callQueue = s1.callQueue.concat(s2.callQueue);\n  s1.method(s2.methods);\n  s1.static(s2.statics);\n\n  for (const [option, value] of Object.entries(s2._userProvidedOptions)) {\n    if (!(option in s1._userProvidedOptions)) {\n      s1.set(option, value);\n    }\n  }\n\n  for (const query in s2.query) {\n    s1.query[query] = s2.query[query];\n  }\n\n  for (const virtual in s2.virtuals) {\n    s1.virtuals[virtual] = s2.virtuals[virtual].clone();\n  }\n\n  s1._indexes = s1._indexes.concat(s2._indexes || []);\n  s1.s.hooks.merge(s2.s.hooks, false);\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,MAAM,EAAE,EAAE,EAAE,EAAE,oBAAoB;IAC1D,MAAM,QAAQ,OAAO,IAAI,CAAC,GAAG,IAAI;IACjC,MAAM,aAAa,CAAC;IACpB,KAAK,MAAM,OAAO,MAAO;QACvB,IAAI,wBAAwB,CAAC,GAAG,KAAK,CAAC,IAAI,IAAI,GAAG,MAAM,CAAC,IAAI,IAAI,GAAG,iBAAiB,CAAC,IAAI,GAAG;YAC1F;QACF;QACA,UAAU,CAAC,IAAI,GAAG,GAAG,IAAI,CAAC,IAAI;IAChC;IACA,GAAG,OAAO,CAAC,UAAU,GAAG;IACxB,GAAG,GAAG,CAAC,YAAY;IACnB,OAAO,GAAG,OAAO,CAAC,UAAU;IAE5B,GAAG,SAAS,GAAG,GAAG,SAAS,CAAC,MAAM,CAAC,GAAG,SAAS;IAC/C,GAAG,MAAM,CAAC,GAAG,OAAO;IACpB,GAAG,MAAM,CAAC,GAAG,OAAO;IAEpB,KAAK,MAAM,CAAC,QAAQ,MAAM,IAAI,OAAO,OAAO,CAAC,GAAG,oBAAoB,EAAG;QACrE,IAAI,CAAC,CAAC,UAAU,GAAG,oBAAoB,GAAG;YACxC,GAAG,GAAG,CAAC,QAAQ;QACjB;IACF;IAEA,IAAK,MAAM,SAAS,GAAG,KAAK,CAAE;QAC5B,GAAG,KAAK,CAAC,MAAM,GAAG,GAAG,KAAK,CAAC,MAAM;IACnC;IAEA,IAAK,MAAM,WAAW,GAAG,QAAQ,CAAE;QACjC,GAAG,QAAQ,CAAC,QAAQ,GAAG,GAAG,QAAQ,CAAC,QAAQ,CAAC,KAAK;IACnD;IAEA,GAAG,QAAQ,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,GAAG,QAAQ,IAAI,EAAE;IAClD,GAAG,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE;AAC/B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 535, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/projection/hasIncludedChildren.js"],"sourcesContent":["'use strict';\n\n/**\n * Creates an object that precomputes whether a given path has child fields in\n * the projection.\n *\n * #### Example:\n *\n *     const res = hasIncludedChildren({ 'a.b.c': 0 });\n *     res.a; // 1\n *     res['a.b']; // 1\n *     res['a.b.c']; // 1\n *     res['a.c']; // undefined\n *\n * @param {Object} fields\n * @api private\n */\n\nmodule.exports = function hasIncludedChildren(fields) {\n  const hasIncludedChildren = {};\n  const keys = Object.keys(fields);\n\n  for (const key of keys) {\n\n    if (key.indexOf('.') === -1) {\n      hasIncludedChildren[key] = 1;\n      continue;\n    }\n    const parts = key.split('.');\n    let c = parts[0];\n\n    for (let i = 0; i < parts.length; ++i) {\n      hasIncludedChildren[c] = 1;\n      if (i + 1 < parts.length) {\n        c = c + '.' + parts[i + 1];\n      }\n    }\n  }\n\n  return hasIncludedChildren;\n};\n"],"names":[],"mappings":"AAEA;;;;;;;;;;;;;;CAcC,GAED,OAAO,OAAO,GAAG,SAAS,oBAAoB,MAAM;IAClD,MAAM,sBAAsB,CAAC;IAC7B,MAAM,OAAO,OAAO,IAAI,CAAC;IAEzB,KAAK,MAAM,OAAO,KAAM;QAEtB,IAAI,IAAI,OAAO,CAAC,SAAS,CAAC,GAAG;YAC3B,mBAAmB,CAAC,IAAI,GAAG;YAC3B;QACF;QACA,MAAM,QAAQ,IAAI,KAAK,CAAC;QACxB,IAAI,IAAI,KAAK,CAAC,EAAE;QAEhB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,EAAE,EAAG;YACrC,mBAAmB,CAAC,EAAE,GAAG;YACzB,IAAI,IAAI,IAAI,MAAM,MAAM,EAAE;gBACxB,IAAI,IAAI,MAAM,KAAK,CAAC,IAAI,EAAE;YAC5B;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 572, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/projection/isNestedProjection.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function isNestedProjection(val) {\n  if (val == null || typeof val !== 'object') {\n    return false;\n  }\n  return val.$slice == null && val.$elemMatch == null && val.$meta == null && val.$ == null;\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,mBAAmB,GAAG;IAC9C,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;QAC1C,OAAO;IACT;IACA,OAAO,IAAI,MAAM,IAAI,QAAQ,IAAI,UAAU,IAAI,QAAQ,IAAI,KAAK,IAAI,QAAQ,IAAI,CAAC,IAAI;AACvF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 582, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/document/applyDefaults.js"],"sourcesContent":["'use strict';\n\nconst isNestedProjection = require('../projection/isNestedProjection');\n\nmodule.exports = function applyDefaults(doc, fields, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip, options) {\n  const paths = Object.keys(doc.$__schema.paths);\n  const plen = paths.length;\n  const skipParentChangeTracking = options && options.skipParentChangeTracking;\n\n  for (let i = 0; i < plen; ++i) {\n    let def;\n    let curPath = '';\n    const p = paths[i];\n\n    if (p === '_id' && doc.$__.skipId) {\n      continue;\n    }\n\n    const type = doc.$__schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    if (path[len - 1] === '$*') {\n      continue;\n    }\n    let included = false;\n    let doc_ = doc._doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (exclude === true) {\n        if (curPath in fields) {\n          break;\n        }\n      } else if (exclude === false && fields && !included) {\n        const hasSubpaths = type.$isSingleNested || type.$isMongooseDocumentArray;\n        if ((curPath in fields && !isNestedProjection(fields[curPath])) || (j === len - 1 && hasSubpaths && hasIncludedChildren != null && hasIncludedChildren[curPath])) {\n          included = true;\n        } else if (hasIncludedChildren != null && !hasIncludedChildren[curPath]) {\n          break;\n        }\n      }\n\n      if (j === len - 1) {\n        if (doc_[piece] !== void 0) {\n          break;\n        }\n\n        if (isBeforeSetters != null) {\n          if (typeof type.defaultValue === 'function') {\n            if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {\n              break;\n            }\n            if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {\n              break;\n            }\n          } else if (!isBeforeSetters) {\n            // Non-function defaults should always run **before** setters\n            continue;\n          }\n        }\n\n        if (pathsToSkip && pathsToSkip[curPath]) {\n          break;\n        }\n\n        if (fields && exclude !== null) {\n          if (exclude === true) {\n            // apply defaults to all non-excluded fields\n            if (p in fields) {\n              continue;\n            }\n\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              applyChangeTracking(doc, p, skipParentChangeTracking);\n            }\n          } else if (included) {\n            // selected field\n            try {\n              def = type.getDefault(doc, false);\n            } catch (err) {\n              doc.invalidate(p, err);\n              break;\n            }\n\n            if (typeof def !== 'undefined') {\n              doc_[piece] = def;\n              applyChangeTracking(doc, p, skipParentChangeTracking);\n            }\n          }\n        } else {\n          try {\n            def = type.getDefault(doc, false);\n          } catch (err) {\n            doc.invalidate(p, err);\n            break;\n          }\n\n          if (typeof def !== 'undefined') {\n            doc_[piece] = def;\n            applyChangeTracking(doc, p, skipParentChangeTracking);\n          }\n        }\n      } else {\n        doc_ = doc_[piece];\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction applyChangeTracking(doc, fullPath, skipParentChangeTracking) {\n  doc.$__.activePaths.default(fullPath);\n  if (!skipParentChangeTracking && doc.$isSubdocument && doc.$isSingleNested && doc.$parent() != null) {\n    doc.$parent().$__.activePaths.default(doc.$__pathRelativeToParent(fullPath));\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 698, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/document/cleanModifiedSubpaths.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function cleanModifiedSubpaths(doc, path, options) {\n  options = options || {};\n  const skipDocArrays = options.skipDocArrays;\n\n  let deleted = 0;\n  if (!doc) {\n    return deleted;\n  }\n\n  for (const modifiedPath of Object.keys(doc.$__.activePaths.getStatePaths('modify'))) {\n    if (skipDocArrays) {\n      const schemaType = doc.$__schema.path(modifiedPath);\n      if (schemaType && schemaType.$isMongooseDocumentArray) {\n        continue;\n      }\n    }\n    if (modifiedPath.startsWith(path + '.')) {\n      doc.$__.activePaths.clearPath(modifiedPath);\n      ++deleted;\n\n      if (doc.$isSubdocument) {\n        cleanParent(doc, modifiedPath);\n      }\n    }\n  }\n  return deleted;\n};\n\nfunction cleanParent(doc, path, seen = new Set()) {\n  if (seen.has(doc)) {\n    throw new Error('Infinite subdocument loop: subdoc with _id ' + doc._id + ' is a parent of itself');\n  }\n  const parent = doc.$parent();\n  const newPath = doc.$__pathRelativeToParent(void 0, false) + '.' + path;\n  parent.$__.activePaths.clearPath(newPath);\n  if (parent.$isSubdocument) {\n    cleanParent(parent, newPath, seen);\n  }\n}\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,sBAAsB,GAAG,EAAE,IAAI,EAAE,OAAO;IAChE,UAAU,WAAW,CAAC;IACtB,MAAM,gBAAgB,QAAQ,aAAa;IAE3C,IAAI,UAAU;IACd,IAAI,CAAC,KAAK;QACR,OAAO;IACT;IAEA,KAAK,MAAM,gBAAgB,OAAO,IAAI,CAAC,IAAI,GAAG,CAAC,WAAW,CAAC,aAAa,CAAC,WAAY;QACnF,IAAI,eAAe;YACjB,MAAM,aAAa,IAAI,SAAS,CAAC,IAAI,CAAC;YACtC,IAAI,cAAc,WAAW,wBAAwB,EAAE;gBACrD;YACF;QACF;QACA,IAAI,aAAa,UAAU,CAAC,OAAO,MAAM;YACvC,IAAI,GAAG,CAAC,WAAW,CAAC,SAAS,CAAC;YAC9B,EAAE;YAEF,IAAI,IAAI,cAAc,EAAE;gBACtB,YAAY,KAAK;YACnB;QACF;IACF;IACA,OAAO;AACT;AAEA,SAAS,YAAY,GAAG,EAAE,IAAI,EAAE,OAAO,IAAI,KAAK;IAC9C,IAAI,KAAK,GAAG,CAAC,MAAM;QACjB,MAAM,IAAI,MAAM,gDAAgD,IAAI,GAAG,GAAG;IAC5E;IACA,MAAM,SAAS,IAAI,OAAO;IAC1B,MAAM,UAAU,IAAI,uBAAuB,CAAC,KAAK,GAAG,SAAS,MAAM;IACnE,OAAO,GAAG,CAAC,WAAW,CAAC,SAAS,CAAC;IACjC,IAAI,OAAO,cAAc,EAAE;QACzB,YAAY,QAAQ,SAAS;IAC/B;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 739, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/document/compile.js"],"sourcesContent":["'use strict';\n\nconst clone = require('../../helpers/clone');\nconst documentSchemaSymbol = require('../../helpers/symbols').documentSchemaSymbol;\nconst internalToObjectOptions = require('../../options').internalToObjectOptions;\nconst utils = require('../../utils');\n\nlet Document;\nconst getSymbol = require('../../helpers/symbols').getSymbol;\nconst scopeSymbol = require('../../helpers/symbols').scopeSymbol;\n\nconst isPOJO = utils.isPOJO;\n\n/*!\n * exports\n */\n\nexports.compile = compile;\nexports.defineKey = defineKey;\n\nconst _isEmptyOptions = Object.freeze({\n  minimize: true,\n  virtuals: false,\n  getters: false,\n  transform: false\n});\n\nconst noDottedPathGetOptions = Object.freeze({\n  noDottedPath: true\n});\n\n/**\n * Compiles schemas.\n * @param {Object} tree\n * @param {Any} proto\n * @param {String} prefix\n * @param {Object} options\n * @api private\n */\n\nfunction compile(tree, proto, prefix, options) {\n  Document = Document || require('../../document');\n  const typeKey = options.typeKey;\n\n  for (const key of Object.keys(tree)) {\n    const limb = tree[key];\n\n    const hasSubprops = isPOJO(limb) &&\n      Object.keys(limb).length > 0 &&\n      (!limb[typeKey] || (typeKey === 'type' && isPOJO(limb.type) && limb.type.type));\n    const subprops = hasSubprops ? limb : null;\n\n    defineKey({ prop: key, subprops: subprops, prototype: proto, prefix: prefix, options: options });\n  }\n}\n\n/**\n * Defines the accessor named prop on the incoming prototype.\n * @param {Object} options\n * @param {String} options.prop\n * @param {Boolean} options.subprops\n * @param {Any} options.prototype\n * @param {String} [options.prefix]\n * @param {Object} options.options\n * @api private\n */\n\nfunction defineKey({ prop, subprops, prototype, prefix, options }) {\n  Document = Document || require('../../document');\n  const path = (prefix ? prefix + '.' : '') + prop;\n  prefix = prefix || '';\n  const useGetOptions = prefix ? Object.freeze({}) : noDottedPathGetOptions;\n\n  if (subprops) {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        const _this = this;\n        if (!this.$__.getters) {\n          this.$__.getters = {};\n        }\n\n        if (!this.$__.getters[path]) {\n          const nested = Object.create(Document.prototype, getOwnPropertyDescriptors(this));\n\n          // save scope for nested getters/setters\n          if (!prefix) {\n            nested.$__[scopeSymbol] = this;\n          }\n          nested.$__.nestedPath = path;\n\n          Object.defineProperty(nested, 'schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, '$__schema', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, documentSchemaSymbol, {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: prototype.schema\n          });\n\n          Object.defineProperty(nested, 'toObject', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return clone(_this.get(path, null, {\n                virtuals: this &&\n                  this.schema &&\n                  this.schema.options &&\n                  this.schema.options.toObject &&\n                  this.schema.options.toObject.virtuals || null\n              }));\n            }\n          });\n\n          Object.defineProperty(nested, '$__get', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: this && this.schema && this.schema.options && this.schema.options.toObject && this.schema.options.toObject.virtuals || null\n              });\n            }\n          });\n\n          Object.defineProperty(nested, 'toJSON', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return _this.get(path, null, {\n                virtuals: this && this.schema && this.schema.options && this.schema.options.toJSON && this.schema.options.toJSON.virtuals || null\n              });\n            }\n          });\n\n          Object.defineProperty(nested, '$__isNested', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: true\n          });\n\n          Object.defineProperty(nested, '$isEmpty', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: function() {\n              return Object.keys(this.get(path, null, _isEmptyOptions) || {}).length === 0;\n            }\n          });\n\n          Object.defineProperty(nested, '$__parent', {\n            enumerable: false,\n            configurable: true,\n            writable: false,\n            value: this\n          });\n\n          compile(subprops, nested, path, options);\n          this.$__.getters[path] = nested;\n        }\n\n        return this.$__.getters[path];\n      },\n      set: function(v) {\n        if (v != null && v.$__isNested) {\n          // Convert top-level to POJO, but leave subdocs hydrated so `$set`\n          // can handle them. See gh-9293.\n          v = v.$__get();\n        } else if (v instanceof Document && !v.$__isNested) {\n          v = v.$toObject(internalToObjectOptions);\n        }\n        const doc = this.$__[scopeSymbol] || this;\n        doc.$set(path, v);\n      }\n    });\n  } else {\n    Object.defineProperty(prototype, prop, {\n      enumerable: true,\n      configurable: true,\n      get: function() {\n        return this[getSymbol].call(\n          this.$__[scopeSymbol] || this,\n          path,\n          null,\n          useGetOptions\n        );\n      },\n      set: function(v) {\n        this.$set.call(this.$__[scopeSymbol] || this, path, v);\n      }\n    });\n  }\n}\n\n// gets descriptors for all properties of `object`\n// makes all properties non-enumerable to match previous behavior to #2211\nfunction getOwnPropertyDescriptors(object) {\n  const result = {};\n\n  Object.getOwnPropertyNames(object).forEach(function(key) {\n    const skip = [\n      'isNew',\n      '$__',\n      '$errors',\n      'errors',\n      '_doc',\n      '$locals',\n      '$op',\n      '__parentArray',\n      '__index',\n      '$isDocumentArrayElement'\n    ].indexOf(key) === -1;\n    if (skip) {\n      return;\n    }\n\n    result[key] = Object.getOwnPropertyDescriptor(object, key);\n    result[key].enumerable = false;\n  });\n\n  return result;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 940, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/firstKey.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function firstKey(obj) {\n  if (obj == null) {\n    return null;\n  }\n  return Object.keys(obj)[0];\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,SAAS,GAAG;IACpC,IAAI,OAAO,MAAM;QACf,OAAO;IACT;IACA,OAAO,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE;AAC5B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 950, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/common.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst Binary = require('bson').Binary;\nconst isBsonType = require('./isBsonType');\nconst isMongooseObject = require('./isMongooseObject');\nconst MongooseError = require('../error');\nconst util = require('util');\n\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options, schema) {\n  let keys;\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});\n  } else {\n    keys = Object.keys(update || {});\n  }\n\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val;\n\n    // Avoid going into mixed paths if schema is specified\n    const keySchema = schema && schema.path && schema.path(path + key);\n    const isNested = schema && schema.nested && schema.nested[path + key];\n    if (keySchema && keySchema.instance === 'Mixed') continue;\n\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      const flat = flatten(val, path + key, options, schema);\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n\n    if (isNested) {\n      const paths = Object.keys(schema.paths);\n      for (const p of paths) {\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\n          result[p] = void 0;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction modifiedPaths(update, path, result, recursion = null) {\n  if (update == null || typeof update !== 'object') {\n    return;\n  }\n\n  if (recursion == null) {\n    recursion = {\n      raw: { update, path },\n      trace: new WeakSet()\n    };\n  }\n\n  if (recursion.trace.has(update)) {\n    throw new MongooseError(`a circular reference in the update value, updateValue:\n${util.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}\nupdatePath: '${recursion.raw.path}'`);\n  }\n  recursion.trace.add(update);\n\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n\n    const _path = path + key;\n    result[_path] = true;\n    if (!Buffer.isBuffer(val) && isMongooseObject(val)) {\n      val = val.toObject({ transform: false, virtuals: false });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result, recursion);\n    }\n  }\n  recursion.trace.delete(update);\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction shouldFlatten(val) {\n  return val &&\n      typeof val === 'object' &&\n      !(val instanceof Date) &&\n      !isBsonType(val, 'ObjectId') &&\n      (!Array.isArray(val) || val.length !== 0) &&\n      !(val instanceof Buffer) &&\n      !isBsonType(val, 'Decimal128') &&\n      !(val instanceof Binary);\n}\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,MAAM,SAAS,+FAAgB,MAAM;AACrC,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN,QAAQ,OAAO,GAAG;AAClB,QAAQ,aAAa,GAAG;AAExB;;CAEC,GAED,SAAS,QAAQ,MAAM,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM;IAC5C,IAAI;IACJ,IAAI,UAAU,iBAAiB,WAAW,CAAC,OAAO,QAAQ,CAAC,SAAS;QAClE,OAAO,OAAO,IAAI,CAAC,OAAO,QAAQ,CAAC;YAAE,WAAW;YAAO,UAAU;QAAM,MAAM,CAAC;IAChF,OAAO;QACL,OAAO,OAAO,IAAI,CAAC,UAAU,CAAC;IAChC;IAEA,MAAM,UAAU,KAAK,MAAM;IAC3B,MAAM,SAAS,CAAC;IAChB,OAAO,OAAO,OAAO,MAAM;IAE3B,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,EAAE,EAAG;QAChC,MAAM,MAAM,IAAI,CAAC,EAAE;QACnB,MAAM,MAAM,MAAM,CAAC,IAAI;QACvB,MAAM,CAAC,OAAO,IAAI,GAAG;QAErB,sDAAsD;QACtD,MAAM,YAAY,UAAU,OAAO,IAAI,IAAI,OAAO,IAAI,CAAC,OAAO;QAC9D,MAAM,WAAW,UAAU,OAAO,MAAM,IAAI,OAAO,MAAM,CAAC,OAAO,IAAI;QACrE,IAAI,aAAa,UAAU,QAAQ,KAAK,SAAS;QAEjD,IAAI,cAAc,MAAM;YACtB,IAAI,WAAW,QAAQ,UAAU,IAAI,MAAM,OAAO,CAAC,MAAM;gBACvD;YACF;YACA,MAAM,OAAO,QAAQ,KAAK,OAAO,KAAK,SAAS;YAC/C,IAAK,MAAM,KAAK,KAAM;gBACpB,MAAM,CAAC,EAAE,GAAG,IAAI,CAAC,EAAE;YACrB;YACA,IAAI,MAAM,OAAO,CAAC,MAAM;gBACtB,MAAM,CAAC,OAAO,IAAI,GAAG;YACvB;QACF;QAEA,IAAI,UAAU;YACZ,MAAM,QAAQ,OAAO,IAAI,CAAC,OAAO,KAAK;YACtC,KAAK,MAAM,KAAK,MAAO;gBACrB,IAAI,EAAE,UAAU,CAAC,OAAO,MAAM,QAAQ,CAAC,OAAO,cAAc,CAAC,IAAI;oBAC/D,MAAM,CAAC,EAAE,GAAG,KAAK;gBACnB;YACF;QACF;IACF;IAEA,OAAO;AACT;AAEA;;CAEC,GAED,SAAS,cAAc,MAAM,EAAE,IAAI,EAAE,MAAM,EAAE,YAAY,IAAI;IAC3D,IAAI,UAAU,QAAQ,OAAO,WAAW,UAAU;QAChD;IACF;IAEA,IAAI,aAAa,MAAM;QACrB,YAAY;YACV,KAAK;gBAAE;gBAAQ;YAAK;YACpB,OAAO,IAAI;QACb;IACF;IAEA,IAAI,UAAU,KAAK,CAAC,GAAG,CAAC,SAAS;QAC/B,MAAM,IAAI,cAAc,CAAC;AAC7B,EAAE,KAAK,OAAO,CAAC,UAAU,GAAG,CAAC,MAAM,EAAE;YAAE,YAAY;YAAO,OAAO;QAAE,GAAG;aACzD,EAAE,UAAU,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC;IAClC;IACA,UAAU,KAAK,CAAC,GAAG,CAAC;IAEpB,MAAM,OAAO,OAAO,IAAI,CAAC,UAAU,CAAC;IACpC,MAAM,UAAU,KAAK,MAAM;IAC3B,SAAS,UAAU,CAAC;IACpB,OAAO,OAAO,OAAO,MAAM;IAE3B,IAAK,IAAI,IAAI,GAAG,IAAI,SAAS,EAAE,EAAG;QAChC,MAAM,MAAM,IAAI,CAAC,EAAE;QACnB,IAAI,MAAM,MAAM,CAAC,IAAI;QAErB,MAAM,QAAQ,OAAO;QACrB,MAAM,CAAC,MAAM,GAAG;QAChB,IAAI,CAAC,OAAO,QAAQ,CAAC,QAAQ,iBAAiB,MAAM;YAClD,MAAM,IAAI,QAAQ,CAAC;gBAAE,WAAW;gBAAO,UAAU;YAAM;QACzD;QACA,IAAI,cAAc,MAAM;YACtB,cAAc,KAAK,OAAO,KAAK,QAAQ;QACzC;IACF;IACA,UAAU,KAAK,CAAC,MAAM,CAAC;IAEvB,OAAO;AACT;AAEA;;CAEC,GAED,SAAS,cAAc,GAAG;IACxB,OAAO,OACH,OAAO,QAAQ,YACf,CAAC,CAAC,eAAe,IAAI,KACrB,CAAC,WAAW,KAAK,eACjB,CAAC,CAAC,MAAM,OAAO,CAAC,QAAQ,IAAI,MAAM,KAAK,CAAC,KACxC,CAAC,CAAC,eAAe,MAAM,KACvB,CAAC,WAAW,KAAK,iBACjB,CAAC,CAAC,eAAe,MAAM;AAC7B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1060, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/get.js"],"sourcesContent":["'use strict';\n\n/**\n * Simplified lodash.get to work around the annoying null quirk. See:\n * https://github.com/lodash/lodash/issues/3659\n * @api private\n */\n\nmodule.exports = function get(obj, path, def) {\n  let parts;\n  let isPathArray = false;\n  if (typeof path === 'string') {\n    if (path.indexOf('.') === -1) {\n      const _v = getProperty(obj, path);\n      if (_v == null) {\n        return def;\n      }\n      return _v;\n    }\n\n    parts = path.split('.');\n  } else {\n    isPathArray = true;\n    parts = path;\n\n    if (parts.length === 1) {\n      const _v = getProperty(obj, parts[0]);\n      if (_v == null) {\n        return def;\n      }\n      return _v;\n    }\n  }\n  let rest = path;\n  let cur = obj;\n  for (const part of parts) {\n    if (cur == null) {\n      return def;\n    }\n\n    // `lib/cast.js` depends on being able to get dotted paths in updates,\n    // like `{ $set: { 'a.b': 42 } }`\n    if (!isPathArray && cur[rest] != null) {\n      return cur[rest];\n    }\n\n    cur = getProperty(cur, part);\n\n    if (!isPathArray) {\n      rest = rest.substr(part.length + 1);\n    }\n  }\n\n  return cur == null ? def : cur;\n};\n\nfunction getProperty(obj, prop) {\n  if (obj == null) {\n    return obj;\n  }\n  if (obj instanceof Map) {\n    return obj.get(prop);\n  }\n  return obj[prop];\n}\n"],"names":[],"mappings":"AAEA;;;;CAIC,GAED,OAAO,OAAO,GAAG,SAAS,IAAI,GAAG,EAAE,IAAI,EAAE,GAAG;IAC1C,IAAI;IACJ,IAAI,cAAc;IAClB,IAAI,OAAO,SAAS,UAAU;QAC5B,IAAI,KAAK,OAAO,CAAC,SAAS,CAAC,GAAG;YAC5B,MAAM,KAAK,YAAY,KAAK;YAC5B,IAAI,MAAM,MAAM;gBACd,OAAO;YACT;YACA,OAAO;QACT;QAEA,QAAQ,KAAK,KAAK,CAAC;IACrB,OAAO;QACL,cAAc;QACd,QAAQ;QAER,IAAI,MAAM,MAAM,KAAK,GAAG;YACtB,MAAM,KAAK,YAAY,KAAK,KAAK,CAAC,EAAE;YACpC,IAAI,MAAM,MAAM;gBACd,OAAO;YACT;YACA,OAAO;QACT;IACF;IACA,IAAI,OAAO;IACX,IAAI,MAAM;IACV,KAAK,MAAM,QAAQ,MAAO;QACxB,IAAI,OAAO,MAAM;YACf,OAAO;QACT;QAEA,sEAAsE;QACtE,iCAAiC;QACjC,IAAI,CAAC,eAAe,GAAG,CAAC,KAAK,IAAI,MAAM;YACrC,OAAO,GAAG,CAAC,KAAK;QAClB;QAEA,MAAM,YAAY,KAAK;QAEvB,IAAI,CAAC,aAAa;YAChB,OAAO,KAAK,MAAM,CAAC,KAAK,MAAM,GAAG;QACnC;IACF;IAEA,OAAO,OAAO,OAAO,MAAM;AAC7B;AAEA,SAAS,YAAY,GAAG,EAAE,IAAI;IAC5B,IAAI,OAAO,MAAM;QACf,OAAO;IACT;IACA,IAAI,eAAe,KAAK;QACtB,OAAO,IAAI,GAAG,CAAC;IACjB;IACA,OAAO,GAAG,CAAC,KAAK;AAClB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1118, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/discriminator/areDiscriminatorValuesEqual.js"],"sourcesContent":["'use strict';\n\nconst isBsonType = require('../isBsonType');\n\nmodule.exports = function areDiscriminatorValuesEqual(a, b) {\n  if (typeof a === 'string' && typeof b === 'string') {\n    return a === b;\n  }\n  if (typeof a === 'number' && typeof b === 'number') {\n    return a === b;\n  }\n  if (isBsonType(a, 'ObjectId') && isBsonType(b, 'ObjectId')) {\n    return a.toString() === b.toString();\n  }\n  return false;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,4BAA4B,CAAC,EAAE,CAAC;IACxD,IAAI,OAAO,MAAM,YAAY,OAAO,MAAM,UAAU;QAClD,OAAO,MAAM;IACf;IACA,IAAI,OAAO,MAAM,YAAY,OAAO,MAAM,UAAU;QAClD,OAAO,MAAM;IACf;IACA,IAAI,WAAW,GAAG,eAAe,WAAW,GAAG,aAAa;QAC1D,OAAO,EAAE,QAAQ,OAAO,EAAE,QAAQ;IACpC;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1135, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/discriminator/getSchemaDiscriminatorByValue.js"],"sourcesContent":["'use strict';\n\nconst areDiscriminatorValuesEqual = require('./areDiscriminatorValuesEqual');\n\n/**\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Schema} schema\n * @param {string} value\n * @api private\n */\n\nmodule.exports = function getSchemaDiscriminatorByValue(schema, value) {\n  if (schema == null || schema.discriminators == null) {\n    return null;\n  }\n  for (const key of Object.keys(schema.discriminators)) {\n    const discriminatorSchema = schema.discriminators[key];\n    if (discriminatorSchema.discriminatorMapping == null) {\n      continue;\n    }\n    if (areDiscriminatorValuesEqual(discriminatorSchema.discriminatorMapping.value, value)) {\n      return discriminatorSchema;\n    }\n  }\n  return null;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;;;;;CAMC,GAED,OAAO,OAAO,GAAG,SAAS,8BAA8B,MAAM,EAAE,KAAK;IACnE,IAAI,UAAU,QAAQ,OAAO,cAAc,IAAI,MAAM;QACnD,OAAO;IACT;IACA,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,OAAO,cAAc,EAAG;QACpD,MAAM,sBAAsB,OAAO,cAAc,CAAC,IAAI;QACtD,IAAI,oBAAoB,oBAAoB,IAAI,MAAM;YACpD;QACF;QACA,IAAI,4BAA4B,oBAAoB,oBAAoB,CAAC,KAAK,EAAE,QAAQ;YACtF,OAAO;QACT;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1161, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/document/getEmbeddedDiscriminatorPath.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\nconst getSchemaDiscriminatorByValue = require('../discriminator/getSchemaDiscriminatorByValue');\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n *\n * @param {Document} doc\n * @param {String|String[]} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(doc, path, options) {\n  options = options || {};\n  const typeOnly = options.typeOnly;\n  const parts = Array.isArray(path) ?\n    path :\n    (path.indexOf('.') === -1 ? [path] : path.split('.'));\n  let schemaType = null;\n  let type = 'adhocOrUndefined';\n\n  const schema = getSchemaDiscriminatorByValue(doc.schema, doc.get(doc.schema.options.discriminatorKey)) || doc.schema;\n\n  for (let i = 0; i < parts.length; ++i) {\n    const subpath = parts.slice(0, i + 1).join('.');\n    schemaType = schema.path(subpath);\n    if (schemaType == null) {\n      type = 'adhocOrUndefined';\n      continue;\n    }\n    if (schemaType.instance === 'Mixed') {\n      return typeOnly ? 'real' : schemaType;\n    }\n    type = schema.pathType(subpath);\n    if ((schemaType.$isSingleNested || schemaType.$isMongooseDocumentArrayElement) &&\n    schemaType.schema.discriminators != null) {\n      const discriminators = schemaType.schema.discriminators;\n      const discriminatorKey = doc.get(subpath + '.' +\n        get(schemaType, 'schema.options.discriminatorKey'));\n      if (discriminatorKey == null || discriminators[discriminatorKey] == null) {\n        continue;\n      }\n      const rest = parts.slice(i + 1).join('.');\n      return getEmbeddedDiscriminatorPath(doc.get(subpath), rest, options);\n    }\n  }\n\n  // Are we getting the whole schema or just the type, 'real', 'nested', etc.\n  return typeOnly ? type : schemaType;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN;;;;;;;;CAQC,GAED,OAAO,OAAO,GAAG,SAAS,6BAA6B,GAAG,EAAE,IAAI,EAAE,OAAO;IACvE,UAAU,WAAW,CAAC;IACtB,MAAM,WAAW,QAAQ,QAAQ;IACjC,MAAM,QAAQ,MAAM,OAAO,CAAC,QAC1B,OACC,KAAK,OAAO,CAAC,SAAS,CAAC,IAAI;QAAC;KAAK,GAAG,KAAK,KAAK,CAAC;IAClD,IAAI,aAAa;IACjB,IAAI,OAAO;IAEX,MAAM,SAAS,8BAA8B,IAAI,MAAM,EAAE,IAAI,GAAG,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,gBAAgB,MAAM,IAAI,MAAM;IAEpH,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,EAAE,EAAG;QACrC,MAAM,UAAU,MAAM,KAAK,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC;QAC3C,aAAa,OAAO,IAAI,CAAC;QACzB,IAAI,cAAc,MAAM;YACtB,OAAO;YACP;QACF;QACA,IAAI,WAAW,QAAQ,KAAK,SAAS;YACnC,OAAO,WAAW,SAAS;QAC7B;QACA,OAAO,OAAO,QAAQ,CAAC;QACvB,IAAI,CAAC,WAAW,eAAe,IAAI,WAAW,+BAA+B,KAC7E,WAAW,MAAM,CAAC,cAAc,IAAI,MAAM;YACxC,MAAM,iBAAiB,WAAW,MAAM,CAAC,cAAc;YACvD,MAAM,mBAAmB,IAAI,GAAG,CAAC,UAAU,MACzC,IAAI,YAAY;YAClB,IAAI,oBAAoB,QAAQ,cAAc,CAAC,iBAAiB,IAAI,MAAM;gBACxE;YACF;YACA,MAAM,OAAO,MAAM,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;YACrC,OAAO,6BAA6B,IAAI,GAAG,CAAC,UAAU,MAAM;QAC9D;IACF;IAEA,2EAA2E;IAC3E,OAAO,WAAW,OAAO;AAC3B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1208, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/getKeysInSchemaOrder.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\n\nmodule.exports = function getKeysInSchemaOrder(schema, val, path) {\n  const schemaKeys = path != null ? Object.keys(get(schema.tree, path, {})) : Object.keys(schema.tree);\n  const valKeys = new Set(Object.keys(val));\n\n  let keys;\n  if (valKeys.size > 1) {\n    keys = new Set();\n    for (const key of schemaKeys) {\n      if (valKeys.has(key)) {\n        keys.add(key);\n      }\n    }\n    for (const key of valKeys) {\n      if (!keys.has(key)) {\n        keys.add(key);\n      }\n    }\n    keys = Array.from(keys);\n  } else {\n    keys = Array.from(valKeys);\n  }\n\n  return keys;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,qBAAqB,MAAM,EAAE,GAAG,EAAE,IAAI;IAC9D,MAAM,aAAa,QAAQ,OAAO,OAAO,IAAI,CAAC,IAAI,OAAO,IAAI,EAAE,MAAM,CAAC,MAAM,OAAO,IAAI,CAAC,OAAO,IAAI;IACnG,MAAM,UAAU,IAAI,IAAI,OAAO,IAAI,CAAC;IAEpC,IAAI;IACJ,IAAI,QAAQ,IAAI,GAAG,GAAG;QACpB,OAAO,IAAI;QACX,KAAK,MAAM,OAAO,WAAY;YAC5B,IAAI,QAAQ,GAAG,CAAC,MAAM;gBACpB,KAAK,GAAG,CAAC;YACX;QACF;QACA,KAAK,MAAM,OAAO,QAAS;YACzB,IAAI,CAAC,KAAK,GAAG,CAAC,MAAM;gBAClB,KAAK,GAAG,CAAC;YACX;QACF;QACA,OAAO,MAAM,IAAI,CAAC;IACpB,OAAO;QACL,OAAO,MAAM,IAAI,CAAC;IACpB;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1235, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/getSubdocumentStrictValue.js"],"sourcesContent":["'use strict';\n\n/**\n * Find the `strict` mode setting for the deepest subdocument along a given path\n * to ensure we have the correct default value for `strict`. When setting values\n * underneath a subdocument, we should use the subdocument's `strict` setting by\n * default, not the top-level document's.\n *\n * @param {Schema} schema\n * @param {String[]} parts\n * @returns {boolean | 'throw' | undefined}\n */\n\nmodule.exports = function getSubdocumentStrictValue(schema, parts) {\n  if (parts.length === 1) {\n    return undefined;\n  }\n  let cur = parts[0];\n  let strict = undefined;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const curSchemaType = schema.path(cur);\n    if (curSchemaType && curSchemaType.schema) {\n      strict = curSchemaType.schema.options.strict;\n      schema = curSchemaType.schema;\n      cur = curSchemaType.$isMongooseDocumentArray && !isNaN(parts[i + 1]) ? '' : parts[i + 1];\n    } else {\n      cur += cur.length ? ('.' + parts[i + 1]) : parts[i + 1];\n    }\n  }\n\n  return strict;\n};\n"],"names":[],"mappings":"AAEA;;;;;;;;;CASC,GAED,OAAO,OAAO,GAAG,SAAS,0BAA0B,MAAM,EAAE,KAAK;IAC/D,IAAI,MAAM,MAAM,KAAK,GAAG;QACtB,OAAO;IACT;IACA,IAAI,MAAM,KAAK,CAAC,EAAE;IAClB,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,GAAG,GAAG,EAAE,EAAG;QACzC,MAAM,gBAAgB,OAAO,IAAI,CAAC;QAClC,IAAI,iBAAiB,cAAc,MAAM,EAAE;YACzC,SAAS,cAAc,MAAM,CAAC,OAAO,CAAC,MAAM;YAC5C,SAAS,cAAc,MAAM;YAC7B,MAAM,cAAc,wBAAwB,IAAI,CAAC,MAAM,KAAK,CAAC,IAAI,EAAE,IAAI,KAAK,KAAK,CAAC,IAAI,EAAE;QAC1F,OAAO;YACL,OAAO,IAAI,MAAM,GAAI,MAAM,KAAK,CAAC,IAAI,EAAE,GAAI,KAAK,CAAC,IAAI,EAAE;QACzD;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1266, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/document/handleSpreadDoc.js"],"sourcesContent":["'use strict';\n\nconst utils = require('../../utils');\n\nconst keysToSkip = new Set(['__index', '__parentArray', '_doc']);\n\n/**\n * Using spread operator on a Mongoose document gives you a\n * POJO that has a tendency to cause infinite recursion. So\n * we use this function on `set()` to prevent that.\n */\n\nmodule.exports = function handleSpreadDoc(v, includeExtraKeys) {\n  if (utils.isPOJO(v) && v.$__ != null && v._doc != null) {\n    if (includeExtraKeys) {\n      const extraKeys = {};\n      for (const key of Object.keys(v)) {\n        if (typeof key === 'symbol') {\n          continue;\n        }\n        if (key[0] === '$') {\n          continue;\n        }\n        if (keysToSkip.has(key)) {\n          continue;\n        }\n        extraKeys[key] = v[key];\n      }\n      return { ...v._doc, ...extraKeys };\n    }\n    return v._doc;\n  }\n\n  return v;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,MAAM,aAAa,IAAI,IAAI;IAAC;IAAW;IAAiB;CAAO;AAE/D;;;;CAIC,GAED,OAAO,OAAO,GAAG,SAAS,gBAAgB,CAAC,EAAE,gBAAgB;IAC3D,IAAI,MAAM,MAAM,CAAC,MAAM,EAAE,GAAG,IAAI,QAAQ,EAAE,IAAI,IAAI,MAAM;QACtD,IAAI,kBAAkB;YACpB,MAAM,YAAY,CAAC;YACnB,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,GAAI;gBAChC,IAAI,OAAO,QAAQ,UAAU;oBAC3B;gBACF;gBACA,IAAI,GAAG,CAAC,EAAE,KAAK,KAAK;oBAClB;gBACF;gBACA,IAAI,WAAW,GAAG,CAAC,MAAM;oBACvB;gBACF;gBACA,SAAS,CAAC,IAAI,GAAG,CAAC,CAAC,IAAI;YACzB;YACA,OAAO;gBAAE,GAAG,EAAE,IAAI;gBAAE,GAAG,SAAS;YAAC;QACnC;QACA,OAAO,EAAE,IAAI;IACf;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1305, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/projection/isDefiningProjection.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function isDefiningProjection(val) {\n  if (val == null) {\n    // `undefined` or `null` become exclusive projections\n    return true;\n  }\n  if (typeof val === 'object') {\n    // Only cases where a value does **not** define whether the whole projection\n    // is inclusive or exclusive are `$meta` and `$slice`.\n    return !('$meta' in val) && !('$slice' in val);\n  }\n  return true;\n};\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,qBAAqB,GAAG;IAChD,IAAI,OAAO,MAAM;QACf,qDAAqD;QACrD,OAAO;IACT;IACA,IAAI,OAAO,QAAQ,UAAU;QAC3B,4EAA4E;QAC5E,sDAAsD;QACtD,OAAO,CAAC,CAAC,WAAW,GAAG,KAAK,CAAC,CAAC,YAAY,GAAG;IAC/C;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1323, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/projection/isExclusive.js"],"sourcesContent":["'use strict';\n\nconst isDefiningProjection = require('./isDefiningProjection');\nconst isPOJO = require('../isPOJO');\n\n/*!\n * ignore\n */\n\nmodule.exports = function isExclusive(projection) {\n  if (projection == null) {\n    return null;\n  }\n\n  const keys = Object.keys(projection);\n  let exclude = null;\n\n  if (keys.length === 1 && keys[0] === '_id') {\n    exclude = !projection._id;\n  } else {\n    for (let ki = 0; ki < keys.length; ++ki) {\n      // Does this projection explicitly define inclusion/exclusion?\n      // Explicitly avoid `$meta` and `$slice`\n      const key = keys[ki];\n      if (key !== '_id' && isDefiningProjection(projection[key])) {\n        exclude = isPOJO(projection[key]) ?\n          (isExclusive(projection[key]) ?? exclude) :\n          !projection[key];\n        if (exclude != null) {\n          break;\n        }\n      }\n    }\n  }\n\n  return exclude;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,YAAY,UAAU;IAC9C,IAAI,cAAc,MAAM;QACtB,OAAO;IACT;IAEA,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,IAAI,UAAU;IAEd,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI,CAAC,EAAE,KAAK,OAAO;QAC1C,UAAU,CAAC,WAAW,GAAG;IAC3B,OAAO;QACL,IAAK,IAAI,KAAK,GAAG,KAAK,KAAK,MAAM,EAAE,EAAE,GAAI;YACvC,8DAA8D;YAC9D,wCAAwC;YACxC,MAAM,MAAM,IAAI,CAAC,GAAG;YACpB,IAAI,QAAQ,SAAS,qBAAqB,UAAU,CAAC,IAAI,GAAG;gBAC1D,UAAU,OAAO,UAAU,CAAC,IAAI,IAC7B,YAAY,UAAU,CAAC,IAAI,KAAK,UACjC,CAAC,UAAU,CAAC,IAAI;gBAClB,IAAI,WAAW,MAAM;oBACnB;gBACF;YACF;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1354, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/projection/isPathExcluded.js"],"sourcesContent":["'use strict';\n\nconst isDefiningProjection = require('./isDefiningProjection');\n\n/**\n * Determines if `path` is excluded by `projection`\n *\n * @param {Object} projection\n * @param {String} path\n * @return {Boolean}\n * @api private\n */\n\nmodule.exports = function isPathExcluded(projection, path) {\n  if (projection == null) {\n    return false;\n  }\n\n  if (path === '_id') {\n    return projection._id === 0;\n  }\n\n  const paths = Object.keys(projection);\n  let type = null;\n\n  for (const _path of paths) {\n    if (isDefiningProjection(projection[_path])) {\n      type = projection[path] === 1 ? 'inclusive' : 'exclusive';\n      break;\n    }\n  }\n\n  if (type === 'inclusive') {\n    return projection[path] !== 1;\n  }\n  if (type === 'exclusive') {\n    return projection[path] === 0;\n  }\n  return false;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;;;;;;CAOC,GAED,OAAO,OAAO,GAAG,SAAS,eAAe,UAAU,EAAE,IAAI;IACvD,IAAI,cAAc,MAAM;QACtB,OAAO;IACT;IAEA,IAAI,SAAS,OAAO;QAClB,OAAO,WAAW,GAAG,KAAK;IAC5B;IAEA,MAAM,QAAQ,OAAO,IAAI,CAAC;IAC1B,IAAI,OAAO;IAEX,KAAK,MAAM,SAAS,MAAO;QACzB,IAAI,qBAAqB,UAAU,CAAC,MAAM,GAAG;YAC3C,OAAO,UAAU,CAAC,KAAK,KAAK,IAAI,cAAc;YAC9C;QACF;IACF;IAEA,IAAI,SAAS,aAAa;QACxB,OAAO,UAAU,CAAC,KAAK,KAAK;IAC9B;IACA,IAAI,SAAS,aAAa;QACxB,OAAO,UAAU,CAAC,KAAK,KAAK;IAC9B;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1389, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/markArraySubdocsPopulated.js"],"sourcesContent":["'use strict';\n\nconst utils = require('../../utils');\n\n/**\n * If populating a path within a document array, make sure each\n * subdoc within the array knows its subpaths are populated.\n *\n * #### Example:\n *\n *     const doc = await Article.findOne().populate('comments.author');\n *     doc.comments[0].populated('author'); // Should be set\n *\n * @param {Document} doc\n * @param {Object} [populated]\n * @api private\n */\n\nmodule.exports = function markArraySubdocsPopulated(doc, populated) {\n  if (doc._doc._id == null || populated == null || populated.length === 0) {\n    return;\n  }\n\n  const id = String(doc._doc._id);\n  for (const item of populated) {\n    if (item.isVirtual) {\n      continue;\n    }\n    const path = item.path;\n    const pieces = path.split('.');\n    for (let i = 0; i < pieces.length - 1; ++i) {\n      const subpath = pieces.slice(0, i + 1).join('.');\n      const rest = pieces.slice(i + 1).join('.');\n      const val = doc.get(subpath);\n      if (val == null) {\n        continue;\n      }\n\n      if (utils.isMongooseDocumentArray(val)) {\n        for (let j = 0; j < val.length; ++j) {\n          if (val[j]) {\n            val[j].populated(rest, item._docs[id] == null ? void 0 : item._docs[id][j], item);\n          }\n        }\n        break;\n      }\n    }\n  }\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;;;;;;;;;;;CAYC,GAED,OAAO,OAAO,GAAG,SAAS,0BAA0B,GAAG,EAAE,SAAS;IAChE,IAAI,IAAI,IAAI,CAAC,GAAG,IAAI,QAAQ,aAAa,QAAQ,UAAU,MAAM,KAAK,GAAG;QACvE;IACF;IAEA,MAAM,KAAK,OAAO,IAAI,IAAI,CAAC,GAAG;IAC9B,KAAK,MAAM,QAAQ,UAAW;QAC5B,IAAI,KAAK,SAAS,EAAE;YAClB;QACF;QACA,MAAM,OAAO,KAAK,IAAI;QACtB,MAAM,SAAS,KAAK,KAAK,CAAC;QAC1B,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,GAAG,GAAG,EAAE,EAAG;YAC1C,MAAM,UAAU,OAAO,KAAK,CAAC,GAAG,IAAI,GAAG,IAAI,CAAC;YAC5C,MAAM,OAAO,OAAO,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;YACtC,MAAM,MAAM,IAAI,GAAG,CAAC;YACpB,IAAI,OAAO,MAAM;gBACf;YACF;YAEA,IAAI,MAAM,uBAAuB,CAAC,MAAM;gBACtC,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,EAAE,EAAG;oBACnC,IAAI,GAAG,CAAC,EAAE,EAAE;wBACV,GAAG,CAAC,EAAE,CAAC,SAAS,CAAC,MAAM,KAAK,KAAK,CAAC,GAAG,IAAI,OAAO,KAAK,IAAI,KAAK,KAAK,CAAC,GAAG,CAAC,EAAE,EAAE;oBAC9E;gBACF;gBACA;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1435, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/minimize.js"],"sourcesContent":["'use strict';\n\nconst { isPOJO } = require('../utils');\n\nmodule.exports = minimize;\n\n/**\n * Minimizes an object, removing undefined values and empty objects\n *\n * @param {Object} object to minimize\n * @return {Object|undefined}\n * @api private\n */\n\nfunction minimize(obj) {\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys;\n  let key;\n  let val;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    if (isPOJO(val)) {\n      obj[key] = minimize(val);\n    }\n\n    if (undefined === obj[key]) {\n      delete obj[key];\n      continue;\n    }\n\n    hasKeys = true;\n  }\n\n  return hasKeys\n    ? obj\n    : undefined;\n}\n"],"names":[],"mappings":"AAEA,MAAM,EAAE,MAAM,EAAE;AAEhB,OAAO,OAAO,GAAG;AAEjB;;;;;;CAMC,GAED,SAAS,SAAS,GAAG;IACnB,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,IAAI,IAAI,KAAK,MAAM;IACnB,IAAI;IACJ,IAAI;IACJ,IAAI;IAEJ,MAAO,IAAK;QACV,MAAM,IAAI,CAAC,EAAE;QACb,MAAM,GAAG,CAAC,IAAI;QAEd,IAAI,OAAO,MAAM;YACf,GAAG,CAAC,IAAI,GAAG,SAAS;QACtB;QAEA,IAAI,cAAc,GAAG,CAAC,IAAI,EAAE;YAC1B,OAAO,GAAG,CAAC,IAAI;YACf;QACF;QAEA,UAAU;IACZ;IAEA,OAAO,UACH,MACA;AACN","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1467, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/path/parentPaths.js"],"sourcesContent":["'use strict';\n\nconst dotRE = /\\./g;\nmodule.exports = function parentPaths(path) {\n  if (path.indexOf('.') === -1) {\n    return [path];\n  }\n  const pieces = path.split(dotRE);\n  const len = pieces.length;\n  const ret = new Array(len);\n  let cur = '';\n  for (let i = 0; i < len; ++i) {\n    cur += (cur.length !== 0) ? '.' + pieces[i] : pieces[i];\n    ret[i] = cur;\n  }\n\n  return ret;\n};\n"],"names":[],"mappings":"AAEA,MAAM,QAAQ;AACd,OAAO,OAAO,GAAG,SAAS,YAAY,IAAI;IACxC,IAAI,KAAK,OAAO,CAAC,SAAS,CAAC,GAAG;QAC5B,OAAO;YAAC;SAAK;IACf;IACA,MAAM,SAAS,KAAK,KAAK,CAAC;IAC1B,MAAM,MAAM,OAAO,MAAM;IACzB,MAAM,MAAM,IAAI,MAAM;IACtB,IAAI,MAAM;IACV,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE,EAAG;QAC5B,OAAO,AAAC,IAAI,MAAM,KAAK,IAAK,MAAM,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE;QACvD,GAAG,CAAC,EAAE,GAAG;IACX;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1488, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/discriminator/checkEmbeddedDiscriminatorKeyProjection.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function checkEmbeddedDiscriminatorKeyProjection(userProjection, path, schema, selected, addedPaths) {\n  const userProjectedInPath = Object.keys(userProjection).\n    reduce((cur, key) => cur || key.startsWith(path + '.'), false);\n  const _discriminatorKey = path + '.' + schema.options.discriminatorKey;\n  if (!userProjectedInPath &&\n      addedPaths.length === 1 &&\n      addedPaths[0] === _discriminatorKey) {\n    selected.splice(selected.indexOf(_discriminatorKey), 1);\n  }\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,wCAAwC,cAAc,EAAE,IAAI,EAAE,MAAM,EAAE,QAAQ,EAAE,UAAU;IAClH,MAAM,sBAAsB,OAAO,IAAI,CAAC,gBACtC,MAAM,CAAC,CAAC,KAAK,MAAQ,OAAO,IAAI,UAAU,CAAC,OAAO,MAAM;IAC1D,MAAM,oBAAoB,OAAO,MAAM,OAAO,OAAO,CAAC,gBAAgB;IACtE,IAAI,CAAC,uBACD,WAAW,MAAM,KAAK,KACtB,UAAU,CAAC,EAAE,KAAK,mBAAmB;QACvC,SAAS,MAAM,CAAC,SAAS,OAAO,CAAC,oBAAoB;IACvD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1499, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/discriminator/getDiscriminatorByValue.js"],"sourcesContent":["'use strict';\n\nconst areDiscriminatorValuesEqual = require('./areDiscriminatorValuesEqual');\n\n/**\n * returns discriminator by discriminatorMapping.value\n *\n * @param {Object} discriminators\n * @param {string} value\n * @api private\n */\n\nmodule.exports = function getDiscriminatorByValue(discriminators, value) {\n  if (discriminators == null) {\n    return null;\n  }\n  for (const name of Object.keys(discriminators)) {\n    const it = discriminators[name];\n    if (\n      it.schema &&\n      it.schema.discriminatorMapping &&\n      areDiscriminatorValuesEqual(it.schema.discriminatorMapping.value, value)\n    ) {\n      return it;\n    }\n  }\n  return null;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;;;;;CAMC,GAED,OAAO,OAAO,GAAG,SAAS,wBAAwB,cAAc,EAAE,KAAK;IACrE,IAAI,kBAAkB,MAAM;QAC1B,OAAO;IACT;IACA,KAAK,MAAM,QAAQ,OAAO,IAAI,CAAC,gBAAiB;QAC9C,MAAM,KAAK,cAAc,CAAC,KAAK;QAC/B,IACE,GAAG,MAAM,IACT,GAAG,MAAM,CAAC,oBAAoB,IAC9B,4BAA4B,GAAG,MAAM,CAAC,oBAAoB,CAAC,KAAK,EAAE,QAClE;YACA,OAAO;QACT;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1522, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/projection/isPathSelectedInclusive.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function isPathSelectedInclusive(fields, path) {\n  const chunks = path.split('.');\n  let cur = '';\n  let j;\n  let keys;\n  let numKeys;\n  for (let i = 0; i < chunks.length; ++i) {\n    cur += cur.length ? '.' : '' + chunks[i];\n    if (fields[cur]) {\n      keys = Object.keys(fields);\n      numKeys = keys.length;\n      for (j = 0; j < numKeys; ++j) {\n        if (keys[i].indexOf(cur + '.') === 0 && keys[i].indexOf(path) !== 0) {\n          continue;\n        }\n      }\n      return true;\n    }\n  }\n\n  return false;\n};\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,wBAAwB,MAAM,EAAE,IAAI;IAC5D,MAAM,SAAS,KAAK,KAAK,CAAC;IAC1B,IAAI,MAAM;IACV,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,EAAE,EAAG;QACtC,OAAO,IAAI,MAAM,GAAG,MAAM,KAAK,MAAM,CAAC,EAAE;QACxC,IAAI,MAAM,CAAC,IAAI,EAAE;YACf,OAAO,OAAO,IAAI,CAAC;YACnB,UAAU,KAAK,MAAM;YACrB,IAAK,IAAI,GAAG,IAAI,SAAS,EAAE,EAAG;gBAC5B,IAAI,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,MAAM,SAAS,KAAK,IAAI,CAAC,EAAE,CAAC,OAAO,CAAC,UAAU,GAAG;oBACnE;gBACF;YACF;YACA,OAAO;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1549, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/isPromise.js"],"sourcesContent":["'use strict';\nfunction isPromise(val) {\n  return !!val && (typeof val === 'object' || typeof val === 'function') && typeof val.then === 'function';\n}\n\nmodule.exports = isPromise;\n"],"names":[],"mappings":"AACA,SAAS,UAAU,GAAG;IACpB,OAAO,CAAC,CAAC,OAAO,CAAC,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAU,KAAK,OAAO,IAAI,IAAI,KAAK;AAChG;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1557, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/document/getDeepestSubdocumentForPath.js"],"sourcesContent":["'use strict';\n\n/**\n * Find the deepest subdocument along a given path to ensure setter functions run\n * with the correct subdocument as `this`. If no subdocuments, returns the top-level\n * document.\n *\n * @param {Document} doc\n * @param {String[]} parts\n * @param {Schema} schema\n * @returns Document\n */\n\nmodule.exports = function getDeepestSubdocumentForPath(doc, parts, schema) {\n  let curPath = parts[0];\n  let curSchema = schema;\n  let subdoc = doc;\n  for (let i = 0; i < parts.length - 1; ++i) {\n    const curSchemaType = curSchema.path(curPath);\n    if (curSchemaType && curSchemaType.schema) {\n      let newSubdoc = subdoc.get(curPath);\n      curSchema = curSchemaType.schema;\n      curPath = parts[i + 1];\n      if (Array.isArray(newSubdoc) && !isNaN(curPath)) {\n        newSubdoc = newSubdoc[curPath];\n        curPath = '';\n      }\n      if (newSubdoc == null) {\n        break;\n      }\n      subdoc = newSubdoc;\n    } else {\n      curPath += curPath.length ? '.' + parts[i + 1] : parts[i + 1];\n    }\n  }\n\n  return subdoc;\n};\n"],"names":[],"mappings":"AAEA;;;;;;;;;CASC,GAED,OAAO,OAAO,GAAG,SAAS,6BAA6B,GAAG,EAAE,KAAK,EAAE,MAAM;IACvE,IAAI,UAAU,KAAK,CAAC,EAAE;IACtB,IAAI,YAAY;IAChB,IAAI,SAAS;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,GAAG,GAAG,EAAE,EAAG;QACzC,MAAM,gBAAgB,UAAU,IAAI,CAAC;QACrC,IAAI,iBAAiB,cAAc,MAAM,EAAE;YACzC,IAAI,YAAY,OAAO,GAAG,CAAC;YAC3B,YAAY,cAAc,MAAM;YAChC,UAAU,KAAK,CAAC,IAAI,EAAE;YACtB,IAAI,MAAM,OAAO,CAAC,cAAc,CAAC,MAAM,UAAU;gBAC/C,YAAY,SAAS,CAAC,QAAQ;gBAC9B,UAAU;YACZ;YACA,IAAI,aAAa,MAAM;gBACrB;YACF;YACA,SAAS;QACX,OAAO;YACL,WAAW,QAAQ,MAAM,GAAG,MAAM,KAAK,CAAC,IAAI,EAAE,GAAG,KAAK,CAAC,IAAI,EAAE;QAC/D;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1594, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/lookupLocalFields.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function lookupLocalFields(cur, path, val) {\n  if (cur == null) {\n    return cur;\n  }\n\n  if (cur._doc != null) {\n    cur = cur._doc;\n  }\n\n  if (arguments.length >= 3) {\n    if (typeof cur !== 'object') {\n      return void 0;\n    }\n    if (val === void 0) {\n      return void 0;\n    }\n    if (cur instanceof Map) {\n      cur.set(path, val);\n    } else {\n      cur[path] = val;\n    }\n    return val;\n  }\n\n\n  // Support populating paths under maps using `map.$*.subpath`\n  if (path === '$*') {\n    return cur instanceof Map ?\n      Array.from(cur.values()) :\n      Object.keys(cur).map(key => cur[key]);\n  }\n\n  if (cur instanceof Map) {\n    return cur.get(path);\n  }\n\n  return cur[path];\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,kBAAkB,GAAG,EAAE,IAAI,EAAE,GAAG;IACxD,IAAI,OAAO,MAAM;QACf,OAAO;IACT;IAEA,IAAI,IAAI,IAAI,IAAI,MAAM;QACpB,MAAM,IAAI,IAAI;IAChB;IAEA,IAAI,UAAU,MAAM,IAAI,GAAG;QACzB,IAAI,OAAO,QAAQ,UAAU;YAC3B,OAAO,KAAK;QACd;QACA,IAAI,QAAQ,KAAK,GAAG;YAClB,OAAO,KAAK;QACd;QACA,IAAI,eAAe,KAAK;YACtB,IAAI,GAAG,CAAC,MAAM;QAChB,OAAO;YACL,GAAG,CAAC,KAAK,GAAG;QACd;QACA,OAAO;IACT;IAGA,6DAA6D;IAC7D,IAAI,SAAS,MAAM;QACjB,OAAO,eAAe,MACpB,MAAM,IAAI,CAAC,IAAI,MAAM,MACrB,OAAO,IAAI,CAAC,KAAK,GAAG,CAAC,CAAA,MAAO,GAAG,CAAC,IAAI;IACxC;IAEA,IAAI,eAAe,KAAK;QACtB,OAAO,IAAI,GAAG,CAAC;IACjB;IAEA,OAAO,GAAG,CAAC,KAAK;AAClB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1628, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/modelNamesFromRefPath.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/mongooseError');\nconst isPathExcluded = require('../projection/isPathExcluded');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst util = require('util');\nconst utils = require('../../utils');\n\nconst hasNumericPropRE = /(\\.\\d+$|\\.\\d+\\.)/g;\n\nmodule.exports = function modelNamesFromRefPath(refPath, doc, populatedPath, modelSchema, queryProjection) {\n  if (refPath == null) {\n    return [];\n  }\n\n  if (typeof refPath === 'string' && queryProjection != null && isPathExcluded(queryProjection, refPath)) {\n    throw new MongooseError('refPath `' + refPath + '` must not be excluded in projection, got ' +\n      util.inspect(queryProjection));\n  }\n\n  // If populated path has numerics, the end `refPath` should too. For example,\n  // if populating `a.0.b` instead of `a.b` and `b` has `refPath = a.c`, we\n  // should return `a.0.c` for the refPath.\n\n  if (hasNumericPropRE.test(populatedPath)) {\n    const chunks = populatedPath.split(hasNumericPropRE);\n\n    if (chunks[chunks.length - 1] === '') {\n      throw new Error('Can\\'t populate individual element in an array');\n    }\n\n    let _refPath = '';\n    let _remaining = refPath;\n    // 2nd, 4th, etc. will be numeric props. For example: `[ 'a', '.0.', 'b' ]`\n    for (let i = 0; i < chunks.length; i += 2) {\n      const chunk = chunks[i];\n      if (_remaining.startsWith(chunk + '.')) {\n        _refPath += _remaining.substring(0, chunk.length) + chunks[i + 1];\n        _remaining = _remaining.substring(chunk.length + 1);\n      } else if (i === chunks.length - 1) {\n        _refPath += _remaining;\n        _remaining = '';\n        break;\n      } else {\n        throw new Error('Could not normalize ref path, chunk ' + chunk + ' not in populated path');\n      }\n    }\n\n    const refValue = mpath.get(_refPath, doc, lookupLocalFields);\n    let modelNames = Array.isArray(refValue) ? refValue : [refValue];\n    modelNames = utils.array.flatten(modelNames);\n    return modelNames;\n  }\n\n  const refValue = mpath.get(refPath, doc, lookupLocalFields);\n\n  let modelNames;\n  if (modelSchema != null && modelSchema.virtuals.hasOwnProperty(refPath)) {\n    modelNames = [modelSchema.virtuals[refPath].applyGetters(void 0, doc)];\n  } else {\n    modelNames = Array.isArray(refValue) ? refValue : [refValue];\n  }\n\n  return modelNames;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN,MAAM,mBAAmB;AAEzB,OAAO,OAAO,GAAG,SAAS,sBAAsB,OAAO,EAAE,GAAG,EAAE,aAAa,EAAE,WAAW,EAAE,eAAe;IACvG,IAAI,WAAW,MAAM;QACnB,OAAO,EAAE;IACX;IAEA,IAAI,OAAO,YAAY,YAAY,mBAAmB,QAAQ,eAAe,iBAAiB,UAAU;QACtG,MAAM,IAAI,cAAc,cAAc,UAAU,+CAC9C,KAAK,OAAO,CAAC;IACjB;IAEA,6EAA6E;IAC7E,yEAAyE;IACzE,yCAAyC;IAEzC,IAAI,iBAAiB,IAAI,CAAC,gBAAgB;QACxC,MAAM,SAAS,cAAc,KAAK,CAAC;QAEnC,IAAI,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,KAAK,IAAI;YACpC,MAAM,IAAI,MAAM;QAClB;QAEA,IAAI,WAAW;QACf,IAAI,aAAa;QACjB,2EAA2E;QAC3E,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,KAAK,EAAG;YACzC,MAAM,QAAQ,MAAM,CAAC,EAAE;YACvB,IAAI,WAAW,UAAU,CAAC,QAAQ,MAAM;gBACtC,YAAY,WAAW,SAAS,CAAC,GAAG,MAAM,MAAM,IAAI,MAAM,CAAC,IAAI,EAAE;gBACjE,aAAa,WAAW,SAAS,CAAC,MAAM,MAAM,GAAG;YACnD,OAAO,IAAI,MAAM,OAAO,MAAM,GAAG,GAAG;gBAClC,YAAY;gBACZ,aAAa;gBACb;YACF,OAAO;gBACL,MAAM,IAAI,MAAM,yCAAyC,QAAQ;YACnE;QACF;QAEA,MAAM,WAAW,MAAM,GAAG,CAAC,UAAU,KAAK;QAC1C,IAAI,aAAa,MAAM,OAAO,CAAC,YAAY,WAAW;YAAC;SAAS;QAChE,aAAa,MAAM,KAAK,CAAC,OAAO,CAAC;QACjC,OAAO;IACT;IAEA,MAAM,WAAW,MAAM,GAAG,CAAC,SAAS,KAAK;IAEzC,IAAI;IACJ,IAAI,eAAe,QAAQ,YAAY,QAAQ,CAAC,cAAc,CAAC,UAAU;QACvE,aAAa;YAAC,YAAY,QAAQ,CAAC,QAAQ,CAAC,YAAY,CAAC,KAAK,GAAG;SAAK;IACxE,OAAO;QACL,aAAa,MAAM,OAAO,CAAC,YAAY,WAAW;YAAC;SAAS;IAC9D;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1690, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/arrayDepth.js"],"sourcesContent":["'use strict';\n\nmodule.exports = arrayDepth;\n\nfunction arrayDepth(arr) {\n  if (!Array.isArray(arr)) {\n    return { min: 0, max: 0, containsNonArrayItem: true };\n  }\n  if (arr.length === 0) {\n    return { min: 1, max: 1, containsNonArrayItem: false };\n  }\n  if (arr.length === 1 && !Array.isArray(arr[0])) {\n    return { min: 1, max: 1, containsNonArrayItem: false };\n  }\n\n  const res = arrayDepth(arr[0]);\n\n  for (let i = 1; i < arr.length; ++i) {\n    const _res = arrayDepth(arr[i]);\n    if (_res.min < res.min) {\n      res.min = _res.min;\n    }\n    if (_res.max > res.max) {\n      res.max = _res.max;\n    }\n    res.containsNonArrayItem = res.containsNonArrayItem || _res.containsNonArrayItem;\n  }\n\n  res.min = res.min + 1;\n  res.max = res.max + 1;\n\n  return res;\n}\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG;AAEjB,SAAS,WAAW,GAAG;IACrB,IAAI,CAAC,MAAM,OAAO,CAAC,MAAM;QACvB,OAAO;YAAE,KAAK;YAAG,KAAK;YAAG,sBAAsB;QAAK;IACtD;IACA,IAAI,IAAI,MAAM,KAAK,GAAG;QACpB,OAAO;YAAE,KAAK;YAAG,KAAK;YAAG,sBAAsB;QAAM;IACvD;IACA,IAAI,IAAI,MAAM,KAAK,KAAK,CAAC,MAAM,OAAO,CAAC,GAAG,CAAC,EAAE,GAAG;QAC9C,OAAO;YAAE,KAAK;YAAG,KAAK;YAAG,sBAAsB;QAAM;IACvD;IAEA,MAAM,MAAM,WAAW,GAAG,CAAC,EAAE;IAE7B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,EAAE,EAAG;QACnC,MAAM,OAAO,WAAW,GAAG,CAAC,EAAE;QAC9B,IAAI,KAAK,GAAG,GAAG,IAAI,GAAG,EAAE;YACtB,IAAI,GAAG,GAAG,KAAK,GAAG;QACpB;QACA,IAAI,KAAK,GAAG,GAAG,IAAI,GAAG,EAAE;YACtB,IAAI,GAAG,GAAG,KAAK,GAAG;QACpB;QACA,IAAI,oBAAoB,GAAG,IAAI,oBAAoB,IAAI,KAAK,oBAAoB;IAClF;IAEA,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG;IACpB,IAAI,GAAG,GAAG,IAAI,GAAG,GAAG;IAEpB,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1732, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/omitUndefined.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function omitUndefined(val) {\n  if (val == null || typeof val !== 'object') {\n    return val;\n  }\n  if (Array.isArray(val)) {\n    for (let i = val.length - 1; i >= 0; --i) {\n      if (val[i] === undefined) {\n        val.splice(i, 1);\n      }\n    }\n  }\n  for (const key of Object.keys(val)) {\n    if (val[key] === void 0) {\n      delete val[key];\n    }\n  }\n  return val;\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,cAAc,GAAG;IACzC,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;QAC1C,OAAO;IACT;IACA,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,IAAK,IAAI,IAAI,IAAI,MAAM,GAAG,GAAG,KAAK,GAAG,EAAE,EAAG;YACxC,IAAI,GAAG,CAAC,EAAE,KAAK,WAAW;gBACxB,IAAI,MAAM,CAAC,GAAG;YAChB;QACF;IACF;IACA,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,KAAM;QAClC,IAAI,GAAG,CAAC,IAAI,KAAK,KAAK,GAAG;YACvB,OAAO,GAAG,CAAC,IAAI;QACjB;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1754, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/cast%24expr.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst StrictModeError = require('../../error/strict');\nconst castNumber = require('../../cast/number');\nconst omitUndefined = require('../omitUndefined');\n\nconst booleanComparison = new Set(['$and', '$or']);\nconst comparisonOperator = new Set(['$cmp', '$eq', '$lt', '$lte', '$gt', '$gte']);\nconst arithmeticOperatorArray = new Set([\n  // avoid casting '$add' or '$subtract', because expressions can be either number or date,\n  // and we don't have a good way of inferring which arguments should be numbers and which should\n  // be dates.\n  '$multiply',\n  '$divide',\n  '$log',\n  '$mod',\n  '$trunc',\n  '$avg',\n  '$max',\n  '$min',\n  '$stdDevPop',\n  '$stdDevSamp',\n  '$sum'\n]);\nconst arithmeticOperatorNumber = new Set([\n  '$abs',\n  '$exp',\n  '$ceil',\n  '$floor',\n  '$ln',\n  '$log10',\n  '$sqrt',\n  '$sin',\n  '$cos',\n  '$tan',\n  '$asin',\n  '$acos',\n  '$atan',\n  '$atan2',\n  '$asinh',\n  '$acosh',\n  '$atanh',\n  '$sinh',\n  '$cosh',\n  '$tanh',\n  '$degreesToRadians',\n  '$radiansToDegrees'\n]);\nconst arrayElementOperators = new Set([\n  '$arrayElemAt',\n  '$first',\n  '$last'\n]);\nconst dateOperators = new Set([\n  '$year',\n  '$month',\n  '$week',\n  '$dayOfMonth',\n  '$dayOfYear',\n  '$hour',\n  '$minute',\n  '$second',\n  '$isoDayOfWeek',\n  '$isoWeekYear',\n  '$isoWeek',\n  '$millisecond'\n]);\nconst expressionOperator = new Set(['$not']);\n\nmodule.exports = function cast$expr(val, schema, strictQuery) {\n  if (typeof val === 'boolean') {\n    return val;\n  }\n  if (typeof val !== 'object' || val === null) {\n    throw new Error('`$expr` must be an object or boolean literal');\n  }\n\n  return _castExpression(val, schema, strictQuery);\n};\n\nfunction _castExpression(val, schema, strictQuery) {\n  // Preserve the value if it represents a path or if it's null\n  if (isPath(val) || val === null) {\n    return val;\n  }\n\n  if (val.$cond != null) {\n    if (Array.isArray(val.$cond)) {\n      val.$cond = val.$cond.map(expr => _castExpression(expr, schema, strictQuery));\n    } else {\n      val.$cond.if = _castExpression(val.$cond.if, schema, strictQuery);\n      val.$cond.then = _castExpression(val.$cond.then, schema, strictQuery);\n      val.$cond.else = _castExpression(val.$cond.else, schema, strictQuery);\n    }\n  } else if (val.$ifNull != null) {\n    val.$ifNull.map(v => _castExpression(v, schema, strictQuery));\n  } else if (val.$switch != null) {\n    if (Array.isArray(val.$switch.branches)) {\n      val.$switch.branches = val.$switch.branches.map(v => _castExpression(v, schema, strictQuery));\n    }\n    if ('default' in val.$switch) {\n      val.$switch.default = _castExpression(val.$switch.default, schema, strictQuery);\n    }\n  }\n\n  const keys = Object.keys(val);\n  for (const key of keys) {\n    if (booleanComparison.has(key)) {\n      val[key] = val[key].map(v => _castExpression(v, schema, strictQuery));\n    } else if (comparisonOperator.has(key)) {\n      val[key] = castComparison(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorArray.has(key)) {\n      val[key] = castArithmetic(val[key], schema, strictQuery);\n    } else if (arithmeticOperatorNumber.has(key)) {\n      val[key] = castNumberOperator(val[key], schema, strictQuery);\n    } else if (expressionOperator.has(key)) {\n      val[key] = _castExpression(val[key], schema, strictQuery);\n    }\n  }\n\n  if (val.$in) {\n    val.$in = castIn(val.$in, schema, strictQuery);\n  }\n  if (val.$size) {\n    val.$size = castNumberOperator(val.$size, schema, strictQuery);\n  }\n  if (val.$round) {\n    const $round = val.$round;\n    if (!Array.isArray($round) || $round.length < 1 || $round.length > 2) {\n      throw new CastError('Array', $round, '$round');\n    }\n    val.$round = $round.map(v => castNumberOperator(v, schema, strictQuery));\n  }\n\n  omitUndefined(val);\n\n  return val;\n}\n\n// { $op: <number> }\nfunction castNumberOperator(val) {\n  if (!isLiteral(val)) {\n    return val;\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val);\n  }\n}\n\nfunction castIn(val, schema, strictQuery) {\n  const path = val[1];\n  if (!isPath(path)) {\n    return val;\n  }\n  const search = val[0];\n\n  const schematype = schema.path(path.slice(1));\n  if (schematype === null) {\n    if (strictQuery === false) {\n      return val;\n    } else if (strictQuery === 'throw') {\n      throw new StrictModeError('$in');\n    }\n\n    return void 0;\n  }\n\n  if (!schematype.$isMongooseArray) {\n    throw new Error('Path must be an array for $in');\n  }\n\n  return [\n    schematype.$isMongooseDocumentArray ? schematype.$embeddedSchemaType.cast(search) : schematype.caster.cast(search),\n    path\n  ];\n}\n\n// { $op: [<number>, <number>] }\nfunction castArithmetic(val) {\n  if (!Array.isArray(val)) {\n    if (!isLiteral(val)) {\n      return val;\n    }\n    try {\n      return castNumber(val);\n    } catch (err) {\n      throw new CastError('Number', val);\n    }\n  }\n\n  return val.map(v => {\n    if (!isLiteral(v)) {\n      return v;\n    }\n    try {\n      return castNumber(v);\n    } catch (err) {\n      throw new CastError('Number', v);\n    }\n  });\n}\n\n// { $op: [expression, expression] }\nfunction castComparison(val, schema, strictQuery) {\n  if (!Array.isArray(val) || val.length !== 2) {\n    throw new Error('Comparison operator must be an array of length 2');\n  }\n\n  val[0] = _castExpression(val[0], schema, strictQuery);\n  const lhs = val[0];\n\n  if (isLiteral(val[1])) {\n    let path = null;\n    let schematype = null;\n    let caster = null;\n    if (isPath(lhs)) {\n      path = lhs.slice(1);\n      schematype = schema.path(path);\n    } else if (typeof lhs === 'object' && lhs != null) {\n      for (const key of Object.keys(lhs)) {\n        if (dateOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          caster = castNumber;\n        } else if (arrayElementOperators.has(key) && isPath(lhs[key])) {\n          path = lhs[key].slice(1) + '.' + key;\n          schematype = schema.path(lhs[key].slice(1));\n          if (schematype != null) {\n            if (schematype.$isMongooseDocumentArray) {\n              schematype = schematype.$embeddedSchemaType;\n            } else if (schematype.$isMongooseArray) {\n              schematype = schematype.caster;\n            }\n          }\n        }\n      }\n    }\n\n    const is$literal = typeof val[1] === 'object' && val[1] != null && val[1].$literal != null;\n    if (schematype != null) {\n      if (is$literal) {\n        val[1] = { $literal: schematype.cast(val[1].$literal) };\n      } else {\n        val[1] = schematype.cast(val[1]);\n      }\n    } else if (caster != null) {\n      if (is$literal) {\n        try {\n          val[1] = { $literal: caster(val[1].$literal) };\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path + '.$literal');\n        }\n      } else {\n        try {\n          val[1] = caster(val[1]);\n        } catch (err) {\n          throw new CastError(caster.name.replace(/^cast/, ''), val[1], path);\n        }\n      }\n    } else if (path != null && strictQuery === true) {\n      return void 0;\n    } else if (path != null && strictQuery === 'throw') {\n      throw new StrictModeError(path);\n    }\n  } else {\n    val[1] = _castExpression(val[1]);\n  }\n\n  return val;\n}\n\nfunction isPath(val) {\n  return typeof val === 'string' && val[0] === '$';\n}\n\nfunction isLiteral(val) {\n  if (typeof val === 'string' && val[0] === '$') {\n    return false;\n  }\n  if (typeof val === 'object' && val !== null && Object.keys(val).find(key => key[0] === '$')) {\n    // The `$literal` expression can make an object a literal\n    // https://www.mongodb.com/docs/manual/reference/operator/aggregation/literal/#mongodb-expression-exp.-literal\n    return val.$literal != null;\n  }\n  return true;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2036, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/isOperator.js"],"sourcesContent":["'use strict';\n\nconst specialKeys = new Set([\n  '$ref',\n  '$id',\n  '$db'\n]);\n\nmodule.exports = function isOperator(path) {\n  return (\n    path[0] === '$' &&\n    !specialKeys.has(path)\n  );\n};\n"],"names":[],"mappings":"AAEA,MAAM,cAAc,IAAI,IAAI;IAC1B;IACA;IACA;CACD;AAED,OAAO,OAAO,GAAG,SAAS,WAAW,IAAI;IACvC,OACE,IAAI,CAAC,EAAE,KAAK,OACZ,CAAC,YAAY,GAAG,CAAC;AAErB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2048, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/createJSONSchemaTypeDefinition.js"],"sourcesContent":["'use strict';\n\n/**\n * Handles creating `{ type: 'object' }` vs `{ bsonType: 'object' }` vs `{ bsonType: ['object', 'null'] }`\n *\n * @param {String} type\n * @param {String} bsonType\n * @param {Boolean} useBsonType\n * @param {Boolean} isRequired\n */\n\nmodule.exports = function createJSONSchemaTypeArray(type, bsonType, useBsonType, isRequired) {\n  if (useBsonType) {\n    if (isRequired) {\n      return { bsonType };\n    }\n    return { bsonType: [bsonType, 'null'] };\n  } else {\n    if (isRequired) {\n      return { type };\n    }\n    return { type: [type, 'null'] };\n  }\n};\n"],"names":[],"mappings":"AAEA;;;;;;;CAOC,GAED,OAAO,OAAO,GAAG,SAAS,0BAA0B,IAAI,EAAE,QAAQ,EAAE,WAAW,EAAE,UAAU;IACzF,IAAI,aAAa;QACf,IAAI,YAAY;YACd,OAAO;gBAAE;YAAS;QACpB;QACA,OAAO;YAAE,UAAU;gBAAC;gBAAU;aAAO;QAAC;IACxC,OAAO;QACL,IAAI,YAAY;YACd,OAAO;gBAAE;YAAK;QAChB;QACA,OAAO;YAAE,MAAM;gBAAC;gBAAM;aAAO;QAAC;IAChC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2086, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/each.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function each(arr, cb, done) {\n  if (arr.length === 0) {\n    return done();\n  }\n\n  let remaining = arr.length;\n  let err = null;\n  for (const v of arr) {\n    cb(v, function(_err) {\n      if (err != null) {\n        return;\n      }\n      if (_err != null) {\n        err = _err;\n        return done(err);\n      }\n\n      if (--remaining <= 0) {\n        return done();\n      }\n    });\n  }\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,KAAK,GAAG,EAAE,EAAE,EAAE,IAAI;IAC1C,IAAI,IAAI,MAAM,KAAK,GAAG;QACpB,OAAO;IACT;IAEA,IAAI,YAAY,IAAI,MAAM;IAC1B,IAAI,MAAM;IACV,KAAK,MAAM,KAAK,IAAK;QACnB,GAAG,GAAG,SAAS,IAAI;YACjB,IAAI,OAAO,MAAM;gBACf;YACF;YACA,IAAI,QAAQ,MAAM;gBAChB,MAAM;gBACN,OAAO,KAAK;YACd;YAEA,IAAI,EAAE,aAAa,GAAG;gBACpB,OAAO;YACT;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2111, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/applyBuiltinPlugins.js"],"sourcesContent":["'use strict';\n\nconst builtinPlugins = require('../../plugins');\n\nmodule.exports = function applyBuiltinPlugins(schema) {\n  for (const plugin of Object.values(builtinPlugins)) {\n    plugin(schema, { deduplicate: true });\n  }\n  schema.plugins = Object.values(builtinPlugins).\n    map(fn => ({ fn, opts: { deduplicate: true } })).\n    concat(schema.plugins);\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,oBAAoB,MAAM;IAClD,KAAK,MAAM,UAAU,OAAO,MAAM,CAAC,gBAAiB;QAClD,OAAO,QAAQ;YAAE,aAAa;QAAK;IACrC;IACA,OAAO,OAAO,GAAG,OAAO,MAAM,CAAC,gBAC7B,GAAG,CAAC,CAAA,KAAM,CAAC;YAAE;YAAI,MAAM;gBAAE,aAAa;YAAK;QAAE,CAAC,GAC9C,MAAM,CAAC,OAAO,OAAO;AACzB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2129, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js"],"sourcesContent":["'use strict';\nconst schemaMerge = require('../schema/merge');\nconst specialProperties = require('../../helpers/specialProperties');\nconst isBsonType = require('../../helpers/isBsonType');\nconst ObjectId = require('../../types/objectid');\nconst isObject = require('../../helpers/isObject');\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {String} [path]\n * @api private\n */\n\nmodule.exports = function mergeDiscriminatorSchema(to, from, path, seen) {\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  path = path || '';\n  seen = seen || new WeakSet();\n\n  if (seen.has(from)) {\n    return;\n  }\n  seen.add(from);\n\n  while (i < len) {\n    key = keys[i++];\n    if (!path) {\n      if (key === 'discriminators' ||\n        key === 'base' ||\n        key === '_applyDiscriminators' ||\n        key === '_userProvidedOptions' ||\n        key === 'options' ||\n        key === 'tree') {\n        continue;\n      }\n    }\n    if (path === 'tree' && from != null && from.instanceOfSchema) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (isObject(from[key])) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if ((from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\n              (from[key].$isMongooseDocumentArray && to[key].$isSingleNested) ||\n              (from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement)) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), true);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      mergeDiscriminatorSchema(to[key], from[key], path ? path + '.' + key : key, seen);\n    }\n  }\n\n  if (from != null && from.instanceOfSchema) {\n    to.tree = Object.assign({}, from.tree, to.tree);\n  }\n};\n"],"names":[],"mappings":"AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN;;;;;;;CAOC,GAED,OAAO,OAAO,GAAG,SAAS,yBAAyB,EAAE,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI;IACrE,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,IAAI,IAAI;IACR,MAAM,MAAM,KAAK,MAAM;IACvB,IAAI;IAEJ,OAAO,QAAQ;IACf,OAAO,QAAQ,IAAI;IAEnB,IAAI,KAAK,GAAG,CAAC,OAAO;QAClB;IACF;IACA,KAAK,GAAG,CAAC;IAET,MAAO,IAAI,IAAK;QACd,MAAM,IAAI,CAAC,IAAI;QACf,IAAI,CAAC,MAAM;YACT,IAAI,QAAQ,oBACV,QAAQ,UACR,QAAQ,0BACR,QAAQ,0BACR,QAAQ,aACR,QAAQ,QAAQ;gBAChB;YACF;QACF;QACA,IAAI,SAAS,UAAU,QAAQ,QAAQ,KAAK,gBAAgB,EAAE;YAC5D;QACF;QACA,IAAI,kBAAkB,GAAG,CAAC,MAAM;YAC9B;QACF;QACA,IAAI,EAAE,CAAC,IAAI,IAAI,MAAM;YACnB,EAAE,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI;QACrB,OAAO,IAAI,SAAS,IAAI,CAAC,IAAI,GAAG;YAC9B,IAAI,CAAC,SAAS,EAAE,CAAC,IAAI,GAAG;gBACtB,EAAE,CAAC,IAAI,GAAG,CAAC;YACb;YACA,IAAI,IAAI,CAAC,IAAI,IAAI,MAAM;gBACrB,oEAAoE;gBACpE,2EAA2E;gBAC3E,4DAA4D;gBAC5D,IAAI,AAAC,IAAI,CAAC,IAAI,CAAC,eAAe,IAAI,EAAE,CAAC,IAAI,CAAC,wBAAwB,IAC3D,IAAI,CAAC,IAAI,CAAC,wBAAwB,IAAI,EAAE,CAAC,IAAI,CAAC,eAAe,IAC7D,IAAI,CAAC,IAAI,CAAC,+BAA+B,IAAI,EAAE,CAAC,IAAI,CAAC,+BAA+B,EAAG;oBAC5F;gBACF,OAAO,IAAI,IAAI,CAAC,IAAI,CAAC,gBAAgB,EAAE;oBACrC,IAAI,EAAE,CAAC,IAAI,CAAC,gBAAgB,EAAE;wBAC5B,YAAY,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,KAAK,IAAI;oBAC1C,OAAO;wBACL,EAAE,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK;oBAC3B;oBACA;gBACF,OAAO,IAAI,WAAW,IAAI,CAAC,IAAI,EAAE,aAAa;oBAC5C,EAAE,CAAC,IAAI,GAAG,IAAI,SAAS,IAAI,CAAC,IAAI;oBAChC;gBACF;YACF;YACA,yBAAyB,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC,IAAI,EAAE,OAAO,OAAO,MAAM,MAAM,KAAK;QAC9E;IACF;IAEA,IAAI,QAAQ,QAAQ,KAAK,gBAAgB,EAAE;QACzC,GAAG,IAAI,GAAG,OAAO,MAAM,CAAC,CAAC,GAAG,KAAK,IAAI,EAAE,GAAG,IAAI;IAChD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2200, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/model/discriminator.js"],"sourcesContent":["'use strict';\n\nconst Mixed = require('../../schema/mixed');\nconst applyBuiltinPlugins = require('../schema/applyBuiltinPlugins');\nconst clone = require('../clone');\nconst defineKey = require('../document/compile').defineKey;\nconst get = require('../get');\nconst utils = require('../../utils');\nconst mergeDiscriminatorSchema = require('../../helpers/discriminator/mergeDiscriminatorSchema');\n\nconst CUSTOMIZABLE_DISCRIMINATOR_OPTIONS = {\n  toJSON: true,\n  toObject: true,\n  _id: true,\n  id: true,\n  virtuals: true,\n  methods: true,\n  statics: true\n};\n\n/**\n * Validate fields declared on the child schema when either schema is configured for encryption.  Specifically, this function ensures that:\n *\n * - any encrypted fields are declared on exactly one of the schemas (not both)\n * - encrypted fields cannot be declared on either the parent or child schema, where the other schema declares the same field without encryption.\n *\n * @param {Schema} parentSchema\n * @param {Schema} childSchema\n */\nfunction validateDiscriminatorSchemasForEncryption(parentSchema, childSchema) {\n  if (parentSchema.encryptionType() == null && childSchema.encryptionType() == null) return;\n\n  const allSharedNestedPaths = setIntersection(\n    allNestedPaths(parentSchema),\n    allNestedPaths(childSchema)\n  );\n\n  for (const path of allSharedNestedPaths) {\n    if (parentSchema._hasEncryptedField(path) && childSchema._hasEncryptedField(path)) {\n      throw new Error(`encrypted fields cannot be declared on both the base schema and the child schema in a discriminator. path=${path}`);\n    }\n\n    if (parentSchema._hasEncryptedField(path) || childSchema._hasEncryptedField(path)) {\n      throw new Error(`encrypted fields cannot have the same path as a non-encrypted field for discriminators. path=${path}`);\n    }\n  }\n\n  function allNestedPaths(schema) {\n    return [...Object.keys(schema.paths), ...Object.keys(schema.singleNestedPaths)];\n  }\n\n  /**\n   * @param {Iterable<string>} i1\n   * @param {Iterable<string>} i2\n   */\n  function* setIntersection(i1, i2) {\n    const s1 = new Set(i1);\n    for (const item of i2) {\n      if (s1.has(item)) {\n        yield item;\n      }\n    }\n  }\n}\n\n/*!\n * ignore\n */\n\nmodule.exports = function discriminator(model, name, schema, tiedValue, applyPlugins, mergeHooks, overwriteExisting) {\n  if (!(schema && schema.instanceOfSchema)) {\n    throw new Error('You must pass a valid discriminator Schema');\n  }\n\n  mergeHooks = mergeHooks == null ? true : mergeHooks;\n\n  if (model.schema.discriminatorMapping &&\n      !model.schema.discriminatorMapping.isRoot) {\n    throw new Error('Discriminator \"' + name +\n        '\" can only be a discriminator of the root model');\n  }\n\n  if (applyPlugins) {\n    const applyPluginsToDiscriminators = get(model.base,\n      'options.applyPluginsToDiscriminators', false) || !mergeHooks;\n    // Even if `applyPluginsToDiscriminators` isn't set, we should still apply\n    // global plugins to schemas embedded in the discriminator schema (gh-7370)\n    model.base._applyPlugins(schema, {\n      skipTopLevel: !applyPluginsToDiscriminators\n    });\n  } else if (!mergeHooks) {\n    applyBuiltinPlugins(schema);\n  }\n\n  const key = model.schema.options.discriminatorKey;\n\n  const existingPath = model.schema.path(key);\n  if (existingPath != null) {\n    if (!utils.hasUserDefinedProperty(existingPath.options, 'select')) {\n      existingPath.options.select = true;\n    }\n    existingPath.options.$skipDiscriminatorCheck = true;\n  } else {\n    const baseSchemaAddition = {};\n    baseSchemaAddition[key] = {\n      default: void 0,\n      select: true,\n      $skipDiscriminatorCheck: true\n    };\n    baseSchemaAddition[key][model.schema.options.typeKey] = String;\n    model.schema.add(baseSchemaAddition);\n    defineKey({\n      prop: key,\n      prototype: model.prototype,\n      options: model.schema.options\n    });\n  }\n\n  if (schema.path(key) && schema.path(key).options.$skipDiscriminatorCheck !== true) {\n    throw new Error('Discriminator \"' + name +\n        '\" cannot have field with name \"' + key + '\"');\n  }\n\n  let value = name;\n  if ((typeof tiedValue === 'string' && tiedValue.length) || tiedValue != null) {\n    value = tiedValue;\n  }\n\n  validateDiscriminatorSchemasForEncryption(model.schema, schema);\n\n  function merge(schema, baseSchema) {\n    // Retain original schema before merging base schema\n    schema._baseSchema = baseSchema;\n    if (baseSchema.paths._id &&\n        baseSchema.paths._id.options &&\n        !baseSchema.paths._id.options.auto) {\n      schema.remove('_id');\n    }\n\n    // Find conflicting paths: if something is a path in the base schema\n    // and a nested path in the child schema, overwrite the base schema path.\n    // See gh-6076\n    const baseSchemaPaths = Object.keys(baseSchema.paths);\n    const conflictingPaths = [];\n\n    for (const path of baseSchemaPaths) {\n      if (schema.nested[path]) {\n        conflictingPaths.push(path);\n        continue;\n      }\n\n      if (path.indexOf('.') === -1) {\n        continue;\n      }\n      const sp = path.split('.').slice(0, -1);\n      let cur = '';\n      for (const piece of sp) {\n        cur += (cur.length ? '.' : '') + piece;\n        if (schema.paths[cur] instanceof Mixed ||\n            schema.singleNestedPaths[cur] instanceof Mixed) {\n          conflictingPaths.push(path);\n        }\n      }\n    }\n\n    // Shallow clone `obj` so we can add additional properties without modifying original\n    // schema. `Schema.prototype.clone()` copies `obj` by reference, no cloning.\n    schema.obj = { ...schema.obj };\n    mergeDiscriminatorSchema(schema, baseSchema);\n    schema._gatherChildSchemas();\n\n    // Clean up conflicting paths _after_ merging re: gh-6076\n    for (const conflictingPath of conflictingPaths) {\n      delete schema.paths[conflictingPath];\n    }\n\n    // Rebuild schema models because schemas may have been merged re: #7884\n    schema.childSchemas.forEach(obj => {\n      obj.model.prototype.$__setSchema(obj.schema);\n    });\n\n    const obj = {};\n    obj[key] = {\n      default: value,\n      select: true,\n      set: function(newName) {\n        if (newName === value || (Array.isArray(value) && utils.deepEqual(newName, value))) {\n          return value;\n        }\n        throw new Error('Can\\'t set discriminator key \"' + key + '\"');\n      },\n      $skipDiscriminatorCheck: true\n    };\n    obj[key][schema.options.typeKey] = existingPath ? existingPath.options[schema.options.typeKey] : String;\n    schema.add(obj);\n\n    schema.discriminatorMapping = { key: key, value: value, isRoot: false };\n\n    if (baseSchema.options.collection) {\n      schema.options.collection = baseSchema.options.collection;\n    }\n    const toJSON = schema.options.toJSON;\n    const toObject = schema.options.toObject;\n    const _id = schema.options._id;\n    const id = schema.options.id;\n\n    const keys = Object.keys(schema.options);\n    schema.options.discriminatorKey = baseSchema.options.discriminatorKey;\n    const userProvidedOptions = schema._userProvidedOptions;\n    for (const _key of keys) {\n      if (!CUSTOMIZABLE_DISCRIMINATOR_OPTIONS[_key]) {\n        // Use `schema.options` in `deepEqual()` because of `discriminatorKey`\n        // set above. We don't allow customizing discriminator key, always\n        // overwrite. See gh-9238\n        if (_key in userProvidedOptions && !utils.deepEqual(schema.options[_key], baseSchema.options[_key])) {\n          throw new Error('Can\\'t customize discriminator option ' + _key +\n            ' (can only modify ' +\n            Object.keys(CUSTOMIZABLE_DISCRIMINATOR_OPTIONS).join(', ') +\n            ')');\n        }\n      }\n    }\n    schema.options = clone(baseSchema.options);\n\n    for (const _key of Object.keys(userProvidedOptions)) {\n      schema.options[_key] = userProvidedOptions[_key];\n    }\n    if (toJSON) schema.options.toJSON = toJSON;\n    if (toObject) schema.options.toObject = toObject;\n    if (typeof _id !== 'undefined') {\n      schema.options._id = _id;\n    }\n    schema.options.id = id;\n    if (mergeHooks) {\n      schema.s.hooks = model.schema.s.hooks.merge(schema.s.hooks);\n    }\n    if (applyPlugins) {\n      schema.plugins = Array.prototype.slice.call(baseSchema.plugins);\n    }\n    schema.callQueue = baseSchema.callQueue.concat(schema.callQueue);\n    delete schema._requiredpaths; // reset just in case Schema#requiredPaths() was called on either schema\n  }\n\n  // merges base schema into new discriminator schema and sets new type field.\n  merge(schema, model.schema);\n\n  if (!model.discriminators) {\n    model.discriminators = {};\n  }\n\n  if (!model.schema.discriminatorMapping) {\n    model.schema.discriminatorMapping = { key: key, value: null, isRoot: true };\n  }\n  if (!model.schema.discriminators) {\n    model.schema.discriminators = {};\n  }\n\n  model.schema.discriminators[name] = schema;\n\n  if (model.discriminators[name] && !schema.options.overwriteModels && !overwriteExisting) {\n    throw new Error('Discriminator with name \"' + name + '\" already exists');\n  }\n\n  return schema;\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2429, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/discriminator/getConstructor.js"],"sourcesContent":["'use strict';\n\nconst getDiscriminatorByValue = require('./getDiscriminatorByValue');\n\n/**\n * Find the correct constructor, taking into account discriminators\n * @api private\n */\n\nmodule.exports = function getConstructor(Constructor, value, defaultDiscriminatorValue) {\n  const discriminatorKey = Constructor.schema.options.discriminatorKey;\n  let discriminatorValue = (value != null && value[discriminatorKey]);\n  if (discriminatorValue == null) {\n    discriminatorValue = defaultDiscriminatorValue;\n  }\n  if (Constructor.discriminators &&\n      discriminatorValue != null) {\n    if (Constructor.discriminators[discriminatorValue]) {\n      Constructor = Constructor.discriminators[discriminatorValue];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, discriminatorValue);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  return Constructor;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;;CAGC,GAED,OAAO,OAAO,GAAG,SAAS,eAAe,WAAW,EAAE,KAAK,EAAE,yBAAyB;IACpF,MAAM,mBAAmB,YAAY,MAAM,CAAC,OAAO,CAAC,gBAAgB;IACpE,IAAI,qBAAsB,SAAS,QAAQ,KAAK,CAAC,iBAAiB;IAClE,IAAI,sBAAsB,MAAM;QAC9B,qBAAqB;IACvB;IACA,IAAI,YAAY,cAAc,IAC1B,sBAAsB,MAAM;QAC9B,IAAI,YAAY,cAAc,CAAC,mBAAmB,EAAE;YAClD,cAAc,YAAY,cAAc,CAAC,mBAAmB;QAC9D,OAAO;YACL,MAAM,qBAAqB,wBAAwB,YAAY,cAAc,EAAE;YAC/E,IAAI,oBAAoB;gBACtB,cAAc;YAChB;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2455, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/addAutoId.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function addAutoId(schema) {\n  const _obj = { _id: { auto: true } };\n  _obj._id[schema.options.typeKey] = 'ObjectId';\n  schema.add(_obj);\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,UAAU,MAAM;IACxC,MAAM,OAAO;QAAE,KAAK;YAAE,MAAM;QAAK;IAAE;IACnC,KAAK,GAAG,CAAC,OAAO,OAAO,CAAC,OAAO,CAAC,GAAG;IACnC,OAAO,GAAG,CAAC;AACb","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2468, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/handleIdOption.js"],"sourcesContent":["'use strict';\n\nconst addAutoId = require('./addAutoId');\n\nmodule.exports = function handleIdOption(schema, options) {\n  if (options == null || options._id == null) {\n    return schema;\n  }\n\n  schema = schema.clone();\n  if (!options._id) {\n    schema.remove('_id');\n    schema.options._id = false;\n  } else if (!schema.paths['_id']) {\n    addAutoId(schema);\n    schema.options._id = true;\n  }\n\n  return schema;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,eAAe,MAAM,EAAE,OAAO;IACtD,IAAI,WAAW,QAAQ,QAAQ,GAAG,IAAI,MAAM;QAC1C,OAAO;IACT;IAEA,SAAS,OAAO,KAAK;IACrB,IAAI,CAAC,QAAQ,GAAG,EAAE;QAChB,OAAO,MAAM,CAAC;QACd,OAAO,OAAO,CAAC,GAAG,GAAG;IACvB,OAAO,IAAI,CAAC,OAAO,KAAK,CAAC,MAAM,EAAE;QAC/B,UAAU;QACV,OAAO,OAAO,CAAC,GAAG,GAAG;IACvB;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2487, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/indexes/decorateDiscriminatorIndexOptions.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function decorateDiscriminatorIndexOptions(schema, indexOptions) {\n  // If the model is a discriminator and has an index, add a\n  // partialFilterExpression by default so the index will only apply\n  // to that discriminator.\n  const discriminatorName = schema.discriminatorMapping && schema.discriminatorMapping.value;\n  if (discriminatorName && !('sparse' in indexOptions)) {\n    const discriminatorKey = schema.options.discriminatorKey;\n    indexOptions.partialFilterExpression = indexOptions.partialFilterExpression || {};\n    indexOptions.partialFilterExpression[discriminatorKey] = discriminatorName;\n  }\n  return indexOptions;\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,kCAAkC,MAAM,EAAE,YAAY;IAC9E,0DAA0D;IAC1D,kEAAkE;IAClE,yBAAyB;IACzB,MAAM,oBAAoB,OAAO,oBAAoB,IAAI,OAAO,oBAAoB,CAAC,KAAK;IAC1F,IAAI,qBAAqB,CAAC,CAAC,YAAY,YAAY,GAAG;QACpD,MAAM,mBAAmB,OAAO,OAAO,CAAC,gBAAgB;QACxD,aAAa,uBAAuB,GAAG,aAAa,uBAAuB,IAAI,CAAC;QAChF,aAAa,uBAAuB,CAAC,iBAAiB,GAAG;IAC3D;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2503, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/getIndexes.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\nconst helperIsObject = require('../isObject');\nconst decorateDiscriminatorIndexOptions = require('../indexes/decorateDiscriminatorIndexOptions');\n\n/**\n * Gather all indexes defined in the schema, including single nested,\n * document arrays, and embedded discriminators.\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function getIndexes(schema) {\n  let indexes = [];\n  const schemaStack = new WeakMap();\n  const indexTypes = schema.constructor.indexTypes;\n  const indexByName = new Map();\n\n  collectIndexes(schema);\n  return indexes;\n\n  function collectIndexes(schema, prefix, baseSchema) {\n    // Ignore infinitely nested schemas, if we've already seen this schema\n    // along this path there must be a cycle\n    if (schemaStack.has(schema)) {\n      return;\n    }\n    schemaStack.set(schema, true);\n\n    prefix = prefix || '';\n    const keys = Object.keys(schema.paths);\n\n    for (const key of keys) {\n      const path = schema.paths[key];\n      if (baseSchema != null && baseSchema.paths[key]) {\n        // If looking at an embedded discriminator schema, don't look at paths\n        // that the\n        continue;\n      }\n\n      if (path._duplicateKeyErrorMessage != null) {\n        schema._duplicateKeyErrorMessagesByPath = schema._duplicateKeyErrorMessagesByPath || {};\n        schema._duplicateKeyErrorMessagesByPath[key] = path._duplicateKeyErrorMessage;\n      }\n\n      if (path.$isMongooseDocumentArray || path.$isSingleNested) {\n        if (get(path, 'options.excludeIndexes') !== true &&\n            get(path, 'schemaOptions.excludeIndexes') !== true &&\n            get(path, 'schema.options.excludeIndexes') !== true) {\n          collectIndexes(path.schema, prefix + key + '.');\n        }\n\n        if (path.schema.discriminators != null) {\n          const discriminators = path.schema.discriminators;\n          const discriminatorKeys = Object.keys(discriminators);\n          for (const discriminatorKey of discriminatorKeys) {\n            collectIndexes(discriminators[discriminatorKey],\n              prefix + key + '.', path.schema);\n          }\n        }\n\n        // Retained to minimize risk of backwards breaking changes due to\n        // gh-6113\n        if (path.$isMongooseDocumentArray) {\n          continue;\n        }\n      }\n\n      const index = path._index || (path.caster && path.caster._index);\n\n      if (index !== false && index !== null && index !== undefined) {\n        const field = {};\n        const isObject = helperIsObject(index);\n        const options = isObject ? { ...index } : {};\n        const type = typeof index === 'string' ? index :\n          isObject ? index.type :\n            false;\n\n        if (type && indexTypes.indexOf(type) !== -1) {\n          field[prefix + key] = type;\n        } else if (options.text) {\n          field[prefix + key] = 'text';\n          delete options.text;\n        } else {\n          let isDescendingIndex = false;\n          if (index === 'descending' || index === 'desc') {\n            isDescendingIndex = true;\n          } else if (index === 'ascending' || index === 'asc') {\n            isDescendingIndex = false;\n          } else {\n            isDescendingIndex = Number(index) === -1;\n          }\n\n          field[prefix + key] = isDescendingIndex ? -1 : 1;\n        }\n\n        delete options.type;\n        if (!('background' in options)) {\n          options.background = true;\n        }\n        if (schema.options.autoIndex != null) {\n          options._autoIndex = schema.options.autoIndex;\n        }\n\n        const indexName = options && options.name;\n\n        if (typeof indexName === 'string') {\n          if (indexByName.has(indexName)) {\n            Object.assign(indexByName.get(indexName), field);\n          } else {\n            indexes.push([field, options]);\n            indexByName.set(indexName, field);\n          }\n        } else {\n          indexes.push([field, options]);\n          indexByName.set(indexName, field);\n        }\n      }\n    }\n\n    schemaStack.delete(schema);\n\n    if (prefix) {\n      fixSubIndexPaths(schema, prefix);\n    } else {\n      schema._indexes.forEach(function(index) {\n        const options = index[1];\n        if (!('background' in options)) {\n          options.background = true;\n        }\n        decorateDiscriminatorIndexOptions(schema, options);\n      });\n      indexes = indexes.concat(schema._indexes);\n    }\n  }\n\n  /**\n   * Checks for indexes added to subdocs using Schema.index().\n   * These indexes need their paths prefixed properly.\n   *\n   * schema._indexes = [ [indexObj, options], [indexObj, options] ..]\n   * @param {Schema} schema\n   * @param {String} prefix\n   * @api private\n   */\n\n  function fixSubIndexPaths(schema, prefix) {\n    const subindexes = schema._indexes;\n    const len = subindexes.length;\n    for (let i = 0; i < len; ++i) {\n      const indexObj = subindexes[i][0];\n      const indexOptions = subindexes[i][1];\n      const keys = Object.keys(indexObj);\n      const klen = keys.length;\n      const newindex = {};\n\n      // use forward iteration, order matters\n      for (let j = 0; j < klen; ++j) {\n        const key = keys[j];\n        newindex[prefix + key] = indexObj[key];\n      }\n\n      const newIndexOptions = Object.assign({}, indexOptions);\n      if (indexOptions != null && indexOptions.partialFilterExpression != null) {\n        newIndexOptions.partialFilterExpression = {};\n        const partialFilterExpression = indexOptions.partialFilterExpression;\n        for (const key of Object.keys(partialFilterExpression)) {\n          newIndexOptions.partialFilterExpression[prefix + key] =\n            partialFilterExpression[key];\n        }\n      }\n\n      indexes.push([newindex, newIndexOptions]);\n    }\n  }\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2661, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/handleReadPreferenceAliases.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function handleReadPreferenceAliases(pref) {\n  switch (pref) {\n    case 'p':\n      pref = 'primary';\n      break;\n    case 'pp':\n      pref = 'primaryPreferred';\n      break;\n    case 's':\n      pref = 'secondary';\n      break;\n    case 'sp':\n      pref = 'secondaryPreferred';\n      break;\n    case 'n':\n      pref = 'nearest';\n      break;\n  }\n\n  return pref;\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,4BAA4B,IAAI;IACxD,OAAQ;QACN,KAAK;YACH,OAAO;YACP;QACF,KAAK;YACH,OAAO;YACP;QACF,KAAK;YACH,OAAO;YACP;QACF,KAAK;YACH,OAAO;YACP;QACF,KAAK;YACH,OAAO;YACP;IACJ;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2685, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/idGetter.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function addIdGetter(schema) {\n  // ensure the documents receive an id getter unless disabled\n  const autoIdGetter = !schema.paths['id'] &&\n    schema.paths['_id'] &&\n    schema.options.id;\n  if (!autoIdGetter) {\n    return schema;\n  }\n  if (schema.aliases && schema.aliases.id) {\n    return schema;\n  }\n  schema.virtual('id').get(idGetter);\n\n  return schema;\n};\n\n/**\n * Returns this documents _id cast to a string.\n * @api private\n */\n\nfunction idGetter() {\n  if (this._id != null) {\n    return this._id.toString();\n  }\n\n  return null;\n}\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,YAAY,MAAM;IAC1C,4DAA4D;IAC5D,MAAM,eAAe,CAAC,OAAO,KAAK,CAAC,KAAK,IACtC,OAAO,KAAK,CAAC,MAAM,IACnB,OAAO,OAAO,CAAC,EAAE;IACnB,IAAI,CAAC,cAAc;QACjB,OAAO;IACT;IACA,IAAI,OAAO,OAAO,IAAI,OAAO,OAAO,CAAC,EAAE,EAAE;QACvC,OAAO;IACT;IACA,OAAO,OAAO,CAAC,MAAM,GAAG,CAAC;IAEzB,OAAO;AACT;AAEA;;;CAGC,GAED,SAAS;IACP,IAAI,IAAI,CAAC,GAAG,IAAI,MAAM;QACpB,OAAO,IAAI,CAAC,GAAG,CAAC,QAAQ;IAC1B;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2712, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/indexes/isIndexSpecEqual.js"],"sourcesContent":["'use strict';\n\n/**\n * Compares two index specifications to determine if they are equal.\n *\n * #### Example:\n *     isIndexSpecEqual({ a: 1, b: 1 }, { a: 1, b: 1 }); // true\n *     isIndexSpecEqual({ a: 1, b: 1 }, { b: 1, a: 1 }); // false\n *     isIndexSpecEqual({ a: 1, b: -1 }, { a: 1, b: 1 }); // false\n *\n * @param {Object} spec1 The first index specification to compare.\n * @param {Object} spec2 The second index specification to compare.\n * @returns {Boolean} Returns true if the index specifications are equal, otherwise returns false.\n */\n\nmodule.exports = function isIndexSpecEqual(spec1, spec2) {\n  const spec1Keys = Object.keys(spec1);\n  const spec2Keys = Object.keys(spec2);\n\n  if (spec1Keys.length !== spec2Keys.length) {\n    return false;\n  }\n\n  for (let i = 0; i < spec1Keys.length; i++) {\n    const key = spec1Keys[i];\n    if (key !== spec2Keys[i] || spec1[key] !== spec2[key]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n"],"names":[],"mappings":"AAEA;;;;;;;;;;;CAWC,GAED,OAAO,OAAO,GAAG,SAAS,iBAAiB,KAAK,EAAE,KAAK;IACrD,MAAM,YAAY,OAAO,IAAI,CAAC;IAC9B,MAAM,YAAY,OAAO,IAAI,CAAC;IAE9B,IAAI,UAAU,MAAM,KAAK,UAAU,MAAM,EAAE;QACzC,OAAO;IACT;IAEA,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,MAAM,EAAE,IAAK;QACzC,MAAM,MAAM,SAAS,CAAC,EAAE;QACxB,IAAI,QAAQ,SAAS,CAAC,EAAE,IAAI,KAAK,CAAC,IAAI,KAAK,KAAK,CAAC,IAAI,EAAE;YACrD,OAAO;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2741, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/setPopulatedVirtualValue.js"],"sourcesContent":["'use strict';\n\n/**\n * Set a populated virtual value on a document's `$$populatedVirtuals` value\n *\n * @param {*} populatedVirtuals A document's `$$populatedVirtuals`\n * @param {*} name The virtual name\n * @param {*} v The result of the populate query\n * @param {*} options The populate options. This function handles `justOne` and `count` options.\n * @returns {Array<Document>|Document|Object|Array<Object>} the populated virtual value that was set\n */\n\nmodule.exports = function setPopulatedVirtualValue(populatedVirtuals, name, v, options) {\n  if (options.justOne || options.count) {\n    populatedVirtuals[name] = Array.isArray(v) ?\n      v[0] :\n      v;\n\n    if (typeof populatedVirtuals[name] !== 'object') {\n      populatedVirtuals[name] = options.count ? v : null;\n    }\n  } else {\n    populatedVirtuals[name] = Array.isArray(v) ?\n      v :\n      v == null ? [] : [v];\n\n    populatedVirtuals[name] = populatedVirtuals[name].filter(function(doc) {\n      return doc && typeof doc === 'object';\n    });\n  }\n\n  return populatedVirtuals[name];\n};\n"],"names":[],"mappings":"AAEA;;;;;;;;CAQC,GAED,OAAO,OAAO,GAAG,SAAS,yBAAyB,iBAAiB,EAAE,IAAI,EAAE,CAAC,EAAE,OAAO;IACpF,IAAI,QAAQ,OAAO,IAAI,QAAQ,KAAK,EAAE;QACpC,iBAAiB,CAAC,KAAK,GAAG,MAAM,OAAO,CAAC,KACtC,CAAC,CAAC,EAAE,GACJ;QAEF,IAAI,OAAO,iBAAiB,CAAC,KAAK,KAAK,UAAU;YAC/C,iBAAiB,CAAC,KAAK,GAAG,QAAQ,KAAK,GAAG,IAAI;QAChD;IACF,OAAO;QACL,iBAAiB,CAAC,KAAK,GAAG,MAAM,OAAO,CAAC,KACtC,IACA,KAAK,OAAO,EAAE,GAAG;YAAC;SAAE;QAEtB,iBAAiB,CAAC,KAAK,GAAG,iBAAiB,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,GAAG;YACnE,OAAO,OAAO,OAAO,QAAQ;QAC/B;IACF;IAEA,OAAO,iBAAiB,CAAC,KAAK;AAChC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2769, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/cleanPositionalOperators.js"],"sourcesContent":["'use strict';\n\n/**\n * For consistency's sake, we replace positional operator `$` and array filters\n * `$[]` and `$[foo]` with `0` when looking up schema paths.\n */\n\nmodule.exports = function cleanPositionalOperators(path) {\n  return path.\n    replace(/\\.\\$(\\[[^\\]]*\\])?(?=\\.)/g, '.0').\n    replace(/\\.\\$(\\[[^\\]]*\\])?$/g, '.0');\n};\n"],"names":[],"mappings":"AAEA;;;CAGC,GAED,OAAO,OAAO,GAAG,SAAS,yBAAyB,IAAI;IACrD,OAAO,KACL,OAAO,CAAC,4BAA4B,MACpC,OAAO,CAAC,uBAAuB;AACnC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2779, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/handleTimestampOption.js"],"sourcesContent":["'use strict';\n\nmodule.exports = handleTimestampOption;\n\n/*!\n * ignore\n */\n\nfunction handleTimestampOption(arg, prop) {\n  if (arg == null) {\n    return null;\n  }\n\n  if (typeof arg === 'boolean') {\n    return prop;\n  }\n  if (typeof arg[prop] === 'boolean') {\n    return arg[prop] ? prop : null;\n  }\n  if (!(prop in arg)) {\n    return prop;\n  }\n  return arg[prop];\n}\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG;AAEjB;;CAEC,GAED,SAAS,sBAAsB,GAAG,EAAE,IAAI;IACtC,IAAI,OAAO,MAAM;QACf,OAAO;IACT;IAEA,IAAI,OAAO,QAAQ,WAAW;QAC5B,OAAO;IACT;IACA,IAAI,OAAO,GAAG,CAAC,KAAK,KAAK,WAAW;QAClC,OAAO,GAAG,CAAC,KAAK,GAAG,OAAO;IAC5B;IACA,IAAI,CAAC,CAAC,QAAQ,GAAG,GAAG;QAClB,OAAO;IACT;IACA,OAAO,GAAG,CAAC,KAAK;AAClB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2801, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToChildren.js"],"sourcesContent":["'use strict';\n\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst handleTimestampOption = require('../schema/handleTimestampOption');\n\nmodule.exports = applyTimestampsToChildren;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToChildren(now, update, schema) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  const hasDollarKey = keys.some(key => key[0] === '$');\n\n  if (hasDollarKey) {\n    if (update.$push) {\n      _applyTimestampToUpdateOperator(update.$push);\n    }\n    if (update.$addToSet) {\n      _applyTimestampToUpdateOperator(update.$addToSet);\n    }\n    if (update.$set != null) {\n      const keys = Object.keys(update.$set);\n      for (const key of keys) {\n        applyTimestampsToUpdateKey(schema, key, update.$set, now);\n      }\n    }\n    if (update.$setOnInsert != null) {\n      const keys = Object.keys(update.$setOnInsert);\n      for (const key of keys) {\n        applyTimestampsToUpdateKey(schema, key, update.$setOnInsert, now);\n      }\n    }\n  }\n\n  const updateKeys = Object.keys(update).filter(key => key[0] !== '$');\n  for (const key of updateKeys) {\n    applyTimestampsToUpdateKey(schema, key, update, now);\n  }\n\n  function _applyTimestampToUpdateOperator(op) {\n    for (const key of Object.keys(op)) {\n      const $path = schema.path(key.replace(/\\.\\$\\./i, '.').replace(/.\\$$/, ''));\n      if (op[key] &&\n          $path &&\n          $path.$isMongooseDocumentArray &&\n          $path.schema.options.timestamps) {\n        const timestamps = $path.schema.options.timestamps;\n        const createdAt = handleTimestampOption(timestamps, 'createdAt');\n        const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n        if (op[key].$each) {\n          op[key].$each.forEach(function(subdoc) {\n            if (updatedAt != null) {\n              subdoc[updatedAt] = now;\n            }\n            if (createdAt != null) {\n              subdoc[createdAt] = now;\n            }\n\n            applyTimestampsToChildren(now, subdoc, $path.schema);\n          });\n        } else {\n          if (updatedAt != null) {\n            op[key][updatedAt] = now;\n          }\n          if (createdAt != null) {\n            op[key][createdAt] = now;\n          }\n\n          applyTimestampsToChildren(now, op[key], $path.schema);\n        }\n      }\n    }\n  }\n}\n\nfunction applyTimestampsToDocumentArray(arr, schematype, now) {\n  const timestamps = schematype.schema.options.timestamps;\n\n  const len = arr.length;\n\n  if (!timestamps) {\n    for (let i = 0; i < len; ++i) {\n      applyTimestampsToChildren(now, arr[i], schematype.schema);\n    }\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  for (let i = 0; i < len; ++i) {\n    if (updatedAt != null) {\n      arr[i][updatedAt] = now;\n    }\n    if (createdAt != null) {\n      arr[i][createdAt] = now;\n    }\n\n    applyTimestampsToChildren(now, arr[i], schematype.schema);\n  }\n}\n\nfunction applyTimestampsToSingleNested(subdoc, schematype, now) {\n  const timestamps = schematype.schema.options.timestamps;\n  if (!timestamps) {\n    applyTimestampsToChildren(now, subdoc, schematype.schema);\n    return;\n  }\n\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  if (updatedAt != null) {\n    subdoc[updatedAt] = now;\n  }\n  if (createdAt != null) {\n    subdoc[createdAt] = now;\n  }\n\n  applyTimestampsToChildren(now, subdoc, schematype.schema);\n}\n\nfunction applyTimestampsToUpdateKey(schema, key, update, now) {\n  // Replace positional operator `$` and array filters `$[]` and `$[.*]`\n  const keyToSearch = cleanPositionalOperators(key);\n  const path = schema.path(keyToSearch);\n  if (!path) {\n    return;\n  }\n\n  const parentSchemaTypes = [];\n  const pieces = keyToSearch.split('.');\n  for (let i = pieces.length - 1; i > 0; --i) {\n    const s = schema.path(pieces.slice(0, i).join('.'));\n    if (s != null &&\n      (s.$isMongooseDocumentArray || s.$isSingleNested)) {\n      parentSchemaTypes.push({ parentPath: key.split('.').slice(0, i).join('.'), parentSchemaType: s });\n    }\n  }\n\n  if (Array.isArray(update[key]) && path.$isMongooseDocumentArray) {\n    applyTimestampsToDocumentArray(update[key], path, now);\n  } else if (update[key] && path.$isSingleNested) {\n    applyTimestampsToSingleNested(update[key], path, now);\n  } else if (parentSchemaTypes.length > 0) {\n    for (const item of parentSchemaTypes) {\n      const parentPath = item.parentPath;\n      const parentSchemaType = item.parentSchemaType;\n      const timestamps = parentSchemaType.schema.options.timestamps;\n      const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n      if (!timestamps || updatedAt == null) {\n        continue;\n      }\n\n      if (parentSchemaType.$isSingleNested) {\n        // Single nested is easy\n        update[parentPath + '.' + updatedAt] = now;\n      } else if (parentSchemaType.$isMongooseDocumentArray) {\n        let childPath = key.substring(parentPath.length + 1);\n\n        if (/^\\d+$/.test(childPath)) {\n          update[parentPath + '.' + childPath][updatedAt] = now;\n          continue;\n        }\n\n        const firstDot = childPath.indexOf('.');\n        childPath = firstDot !== -1 ? childPath.substring(0, firstDot) : childPath;\n\n        update[parentPath + '.' + childPath + '.' + updatedAt] = now;\n      }\n    }\n  } else if (path.schema != null && path.schema != schema && update[key]) {\n    const timestamps = path.schema.options.timestamps;\n    const createdAt = handleTimestampOption(timestamps, 'createdAt');\n    const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n\n    if (!timestamps) {\n      return;\n    }\n\n    if (updatedAt != null) {\n      update[key][updatedAt] = now;\n    }\n    if (createdAt != null) {\n      update[key][createdAt] = now;\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2967, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/update/applyTimestampsToUpdate.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst get = require('../get');\n\nmodule.exports = applyTimestampsToUpdate;\n\n/*!\n * ignore\n */\n\nfunction applyTimestampsToUpdate(now, createdAt, updatedAt, currentUpdate, options, isReplace) {\n  const updates = currentUpdate;\n  let _updates = updates;\n  const timestamps = get(options, 'timestamps', true);\n\n  // Support skipping timestamps at the query level, see gh-6980\n  if (!timestamps || updates == null) {\n    return currentUpdate;\n  }\n\n  const skipCreatedAt = timestamps != null && timestamps.createdAt === false;\n  const skipUpdatedAt = timestamps != null && timestamps.updatedAt === false;\n\n  if (isReplace) {\n    if (currentUpdate && currentUpdate.$set) {\n      currentUpdate = currentUpdate.$set;\n      updates.$set = {};\n      _updates = updates.$set;\n    }\n    if (!skipUpdatedAt && updatedAt && !currentUpdate[updatedAt]) {\n      _updates[updatedAt] = now;\n    }\n    if (!skipCreatedAt && createdAt && !currentUpdate[createdAt]) {\n      _updates[createdAt] = now;\n    }\n    return updates;\n  }\n  currentUpdate = currentUpdate || {};\n\n  if (Array.isArray(updates)) {\n    // Update with aggregation pipeline\n    if (updatedAt == null) {\n      return updates;\n    }\n    updates.push({ $set: { [updatedAt]: now } });\n    return updates;\n  }\n  updates.$set = updates.$set || {};\n  if (!skipUpdatedAt && updatedAt &&\n      (!currentUpdate.$currentDate || !currentUpdate.$currentDate[updatedAt])) {\n    let timestampSet = false;\n    if (updatedAt.indexOf('.') !== -1) {\n      const pieces = updatedAt.split('.');\n      for (let i = 1; i < pieces.length; ++i) {\n        const remnant = pieces.slice(-i).join('.');\n        const start = pieces.slice(0, -i).join('.');\n        if (currentUpdate[start] != null) {\n          currentUpdate[start][remnant] = now;\n          timestampSet = true;\n          break;\n        } else if (currentUpdate.$set && currentUpdate.$set[start]) {\n          currentUpdate.$set[start][remnant] = now;\n          timestampSet = true;\n          break;\n        }\n      }\n    }\n\n    if (!timestampSet) {\n      updates.$set[updatedAt] = now;\n    }\n\n    if (updates.hasOwnProperty(updatedAt)) {\n      delete updates[updatedAt];\n    }\n  }\n\n  if (!skipCreatedAt && createdAt) {\n    if (currentUpdate[createdAt]) {\n      delete currentUpdate[createdAt];\n    }\n    if (currentUpdate.$set && currentUpdate.$set[createdAt]) {\n      delete currentUpdate.$set[createdAt];\n    }\n    let timestampSet = false;\n    if (createdAt.indexOf('.') !== -1) {\n      const pieces = createdAt.split('.');\n      for (let i = 1; i < pieces.length; ++i) {\n        const remnant = pieces.slice(-i).join('.');\n        const start = pieces.slice(0, -i).join('.');\n        if (currentUpdate[start] != null) {\n          currentUpdate[start][remnant] = now;\n          timestampSet = true;\n          break;\n        } else if (currentUpdate.$set && currentUpdate.$set[start]) {\n          currentUpdate.$set[start][remnant] = now;\n          timestampSet = true;\n          break;\n        }\n      }\n    }\n\n    if (!timestampSet) {\n      updates.$setOnInsert = updates.$setOnInsert || {};\n      updates.$setOnInsert[createdAt] = now;\n    }\n  }\n\n  if (Object.keys(updates.$set).length === 0) {\n    delete updates.$set;\n  }\n  return updates;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3074, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/timestamps/setDocumentTimestamps.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function setDocumentTimestamps(doc, timestampOption, currentTime, createdAt, updatedAt) {\n  const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;\n  const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;\n\n  const defaultTimestamp = currentTime != null ?\n    currentTime() :\n    doc.ownerDocument().constructor.base.now();\n\n  if (!skipCreatedAt &&\n      (doc.isNew || doc.$isSubdocument) &&\n      createdAt &&\n      !doc.$__getValue(createdAt) &&\n      doc.$__isSelected(createdAt)) {\n    doc.$set(createdAt, defaultTimestamp, undefined, { overwriteImmutable: true });\n  }\n\n  if (!skipUpdatedAt && updatedAt && (doc.isNew || doc.$isModified())) {\n    let ts = defaultTimestamp;\n    if (doc.isNew && createdAt != null) {\n      ts = doc.$__getValue(createdAt);\n    }\n    doc.$set(updatedAt, ts);\n  }\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,sBAAsB,GAAG,EAAE,eAAe,EAAE,WAAW,EAAE,SAAS,EAAE,SAAS;IACrG,MAAM,gBAAgB,mBAAmB,QAAQ,gBAAgB,SAAS,KAAK;IAC/E,MAAM,gBAAgB,mBAAmB,QAAQ,gBAAgB,SAAS,KAAK;IAE/E,MAAM,mBAAmB,eAAe,OACtC,gBACA,IAAI,aAAa,GAAG,WAAW,CAAC,IAAI,CAAC,GAAG;IAE1C,IAAI,CAAC,iBACD,CAAC,IAAI,KAAK,IAAI,IAAI,cAAc,KAChC,aACA,CAAC,IAAI,WAAW,CAAC,cACjB,IAAI,aAAa,CAAC,YAAY;QAChC,IAAI,IAAI,CAAC,WAAW,kBAAkB,WAAW;YAAE,oBAAoB;QAAK;IAC9E;IAEA,IAAI,CAAC,iBAAiB,aAAa,CAAC,IAAI,KAAK,IAAI,IAAI,WAAW,EAAE,GAAG;QACnE,IAAI,KAAK;QACT,IAAI,IAAI,KAAK,IAAI,aAAa,MAAM;YAClC,KAAK,IAAI,WAAW,CAAC;QACvB;QACA,IAAI,IAAI,CAAC,WAAW;IACtB;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3095, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/timestamps/setupTimestamps.js"],"sourcesContent":["'use strict';\n\nconst applyTimestampsToChildren = require('../update/applyTimestampsToChildren');\nconst applyTimestampsToUpdate = require('../update/applyTimestampsToUpdate');\nconst get = require('../get');\nconst handleTimestampOption = require('../schema/handleTimestampOption');\nconst setDocumentTimestamps = require('./setDocumentTimestamps');\nconst symbols = require('../../schema/symbols');\n\nconst replaceOps = new Set([\n  'replaceOne',\n  'findOneAndReplace'\n]);\n\nmodule.exports = function setupTimestamps(schema, timestamps) {\n  const childHasTimestamp = schema.childSchemas.find(withTimestamp);\n  function withTimestamp(s) {\n    const ts = s.schema.options.timestamps;\n    return !!ts;\n  }\n  if (!timestamps && !childHasTimestamp) {\n    return;\n  }\n  const createdAt = handleTimestampOption(timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');\n  const currentTime = timestamps != null && timestamps.hasOwnProperty('currentTime') ?\n    timestamps.currentTime :\n    null;\n  const schemaAdditions = {};\n\n  schema.$timestamps = { createdAt: createdAt, updatedAt: updatedAt };\n\n  if (createdAt && !schema.paths[createdAt]) {\n    const baseImmutableCreatedAt = schema.base != null ? schema.base.get('timestamps.createdAt.immutable') : null;\n    const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;\n    schemaAdditions[createdAt] = { [schema.options.typeKey || 'type']: Date, immutable };\n  }\n\n  if (updatedAt && !schema.paths[updatedAt]) {\n    schemaAdditions[updatedAt] = Date;\n  }\n\n  schema.add(schemaAdditions);\n\n  schema.pre('save', function timestampsPreSave(next) {\n    const timestampOption = get(this, '$__.saveOptions.timestamps');\n    if (timestampOption === false) {\n      return next();\n    }\n\n    setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);\n\n    next();\n  });\n\n  schema.methods.initializeTimestamps = function() {\n    const ts = currentTime != null ?\n      currentTime() : this.constructor.base.now();\n\n\n    if (createdAt && !this.get(createdAt)) {\n      this.$set(createdAt, ts);\n    }\n    if (updatedAt && !this.get(updatedAt)) {\n      this.$set(updatedAt, ts);\n    }\n    if (this.$isSubdocument) {\n      return this;\n    }\n\n    const subdocs = this.$getAllSubdocs();\n    for (const subdoc of subdocs) {\n      if (subdoc.initializeTimestamps) {\n        subdoc.initializeTimestamps();\n      }\n    }\n\n    return this;\n  };\n\n  _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;\n\n  const opts = { query: true, model: false };\n  schema.pre('findOneAndReplace', opts, _setTimestampsOnUpdate);\n  schema.pre('findOneAndUpdate', opts, _setTimestampsOnUpdate);\n  schema.pre('replaceOne', opts, _setTimestampsOnUpdate);\n  schema.pre('update', opts, _setTimestampsOnUpdate);\n  schema.pre('updateOne', opts, _setTimestampsOnUpdate);\n  schema.pre('updateMany', opts, _setTimestampsOnUpdate);\n\n  function _setTimestampsOnUpdate(next) {\n    const now = currentTime != null ?\n      currentTime() :\n      this.model.base.now();\n    // Replacing with null update should still trigger timestamps\n    if (replaceOps.has(this.op) && this.getUpdate() == null) {\n      this.setUpdate({});\n    }\n    applyTimestampsToUpdate(\n      now,\n      createdAt,\n      updatedAt,\n      this.getUpdate(),\n      this._mongooseOptions,\n      replaceOps.has(this.op)\n    );\n    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);\n    next();\n  }\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3187, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/validateRef.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/mongooseError');\nconst util = require('util');\n\nmodule.exports = validateRef;\n\nfunction validateRef(ref, path) {\n  if (typeof ref === 'string') {\n    return;\n  }\n\n  if (typeof ref === 'function') {\n    return;\n  }\n\n  throw new MongooseError('Invalid ref at path \"' + path + '\". Got ' +\n    util.inspect(ref, { depth: 0 }));\n}\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,OAAO,OAAO,GAAG;AAEjB,SAAS,YAAY,GAAG,EAAE,IAAI;IAC5B,IAAI,OAAO,QAAQ,UAAU;QAC3B;IACF;IAEA,IAAI,OAAO,QAAQ,YAAY;QAC7B;IACF;IAEA,MAAM,IAAI,cAAc,0BAA0B,OAAO,YACvD,KAAK,OAAO,CAAC,KAAK;QAAE,OAAO;IAAE;AACjC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3205, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/model/applyHooks.js"],"sourcesContent":["'use strict';\n\nconst symbols = require('../../schema/symbols');\nconst promiseOrCallback = require('../promiseOrCallback');\n\n/*!\n * ignore\n */\n\nmodule.exports = applyHooks;\n\n/*!\n * ignore\n */\n\napplyHooks.middlewareFunctions = [\n  'deleteOne',\n  'save',\n  'validate',\n  'remove',\n  'updateOne',\n  'init'\n];\n\n/*!\n * ignore\n */\n\nconst alreadyHookedFunctions = new Set(applyHooks.middlewareFunctions.flatMap(fn => ([fn, `$__${fn}`])));\n\n/**\n * Register hooks for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} options\n * @api private\n */\n\nfunction applyHooks(model, schema, options) {\n  options = options || {};\n\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1,\n    nullResultByDefault: true,\n    contextParameter: true\n  };\n  const objToDecorate = options.decorateDoc ? model : model.prototype;\n\n  model.$appliedHooks = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    let childModel = null;\n    if (type.$isSingleNested) {\n      childModel = type.caster;\n    } else if (type.$isMongooseDocumentArray) {\n      childModel = type.Constructor;\n    } else {\n      continue;\n    }\n\n    if (childModel.$appliedHooks) {\n      continue;\n    }\n\n    applyHooks(childModel, type.schema, { ...options, isChildSchema: true });\n    if (childModel.discriminators != null) {\n      const keys = Object.keys(childModel.discriminators);\n      for (const key of keys) {\n        applyHooks(childModel.discriminators[key],\n          childModel.discriminators[key].schema, options);\n      }\n    }\n  }\n\n  // Built-in hooks rely on hooking internal functions in order to support\n  // promises and make it so that `doc.save.toString()` provides meaningful\n  // information.\n\n  const middleware = schema.s.hooks.\n    filter(hook => {\n      if (hook.name === 'updateOne' || hook.name === 'deleteOne') {\n        return !!hook['document'];\n      }\n      if (hook.name === 'remove' || hook.name === 'init') {\n        return hook['document'] == null || !!hook['document'];\n      }\n      if (hook.query != null || hook.document != null) {\n        return hook.document !== false;\n      }\n      return true;\n    }).\n    filter(hook => {\n      // If user has overwritten the method, don't apply built-in middleware\n      if (schema.methods[hook.name]) {\n        return !hook.fn[symbols.builtInMiddleware];\n      }\n\n      return true;\n    });\n\n  model._middleware = middleware;\n\n  objToDecorate.$__originalValidate = objToDecorate.$__originalValidate || objToDecorate.$__validate;\n\n  const internalMethodsToWrap = options && options.isChildSchema ? ['save', 'validate', 'deleteOne'] : ['save', 'validate'];\n  for (const method of internalMethodsToWrap) {\n    const toWrap = method === 'validate' ? '$__originalValidate' : `$__${method}`;\n    const wrapped = middleware.\n      createWrapper(method, objToDecorate[toWrap], null, kareemOptions);\n    objToDecorate[`$__${method}`] = wrapped;\n  }\n  objToDecorate.$__init = middleware.\n    createWrapperSync('init', objToDecorate.$__init, null, kareemOptions);\n\n  // Support hooks for custom methods\n  const customMethods = Object.keys(schema.methods);\n  const customMethodOptions = Object.assign({}, kareemOptions, {\n    // Only use `checkForPromise` for custom methods, because mongoose\n    // query thunks are not as consistent as I would like about returning\n    // a nullish value rather than the query. If a query thunk returns\n    // a query, `checkForPromise` causes infinite recursion\n    checkForPromise: true\n  });\n  for (const method of customMethods) {\n    if (alreadyHookedFunctions.has(method)) {\n      continue;\n    }\n    if (!middleware.hasHooks(method)) {\n      // Don't wrap if there are no hooks for the custom method to avoid\n      // surprises. Also, `createWrapper()` enforces consistent async,\n      // so wrapping a sync method would break it.\n      continue;\n    }\n    const originalMethod = objToDecorate[method];\n    objToDecorate[method] = function() {\n      const args = Array.prototype.slice.call(arguments);\n      const cb = args.slice(-1).pop();\n      const argsWithoutCallback = typeof cb === 'function' ?\n        args.slice(0, args.length - 1) : args;\n      return promiseOrCallback(cb, callback => {\n        return this[`$__${method}`].apply(this,\n          argsWithoutCallback.concat([callback]));\n      }, model.events);\n    };\n    objToDecorate[`$__${method}`] = middleware.\n      createWrapper(method, originalMethod, null, customMethodOptions);\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3338, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/applyPlugins.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function applyPlugins(schema, plugins, options, cacheKey) {\n  if (schema[cacheKey]) {\n    return;\n  }\n  schema[cacheKey] = true;\n\n  if (!options || !options.skipTopLevel) {\n    let pluginTags = null;\n    for (const plugin of plugins) {\n      const tags = plugin[1] == null ? null : plugin[1].tags;\n      if (!Array.isArray(tags)) {\n        schema.plugin(plugin[0], plugin[1]);\n        continue;\n      }\n\n      pluginTags = pluginTags || new Set(schema.options.pluginTags || []);\n      if (!tags.find(tag => pluginTags.has(tag))) {\n        continue;\n      }\n      schema.plugin(plugin[0], plugin[1]);\n    }\n  }\n\n  options = Object.assign({}, options);\n  delete options.skipTopLevel;\n\n  if (options.applyPluginsToChildSchemas !== false) {\n    for (const path of Object.keys(schema.paths)) {\n      const type = schema.paths[path];\n      if (type.schema != null) {\n        applyPlugins(type.schema, plugins, options, cacheKey);\n\n        // Recompile schema because plugins may have changed it, see gh-7572\n        type.caster.prototype.$__setSchema(type.schema);\n      }\n    }\n  }\n\n  const discriminators = schema.discriminators;\n  if (discriminators == null) {\n    return;\n  }\n\n  const applyPluginsToDiscriminators = options.applyPluginsToDiscriminators;\n\n  const keys = Object.keys(discriminators);\n  for (const discriminatorKey of keys) {\n    const discriminatorSchema = discriminators[discriminatorKey];\n\n    applyPlugins(discriminatorSchema, plugins,\n      { skipTopLevel: !applyPluginsToDiscriminators }, cacheKey);\n  }\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,aAAa,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,QAAQ;IACvE,IAAI,MAAM,CAAC,SAAS,EAAE;QACpB;IACF;IACA,MAAM,CAAC,SAAS,GAAG;IAEnB,IAAI,CAAC,WAAW,CAAC,QAAQ,YAAY,EAAE;QACrC,IAAI,aAAa;QACjB,KAAK,MAAM,UAAU,QAAS;YAC5B,MAAM,OAAO,MAAM,CAAC,EAAE,IAAI,OAAO,OAAO,MAAM,CAAC,EAAE,CAAC,IAAI;YACtD,IAAI,CAAC,MAAM,OAAO,CAAC,OAAO;gBACxB,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE;gBAClC;YACF;YAEA,aAAa,cAAc,IAAI,IAAI,OAAO,OAAO,CAAC,UAAU,IAAI,EAAE;YAClE,IAAI,CAAC,KAAK,IAAI,CAAC,CAAA,MAAO,WAAW,GAAG,CAAC,OAAO;gBAC1C;YACF;YACA,OAAO,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,CAAC,EAAE;QACpC;IACF;IAEA,UAAU,OAAO,MAAM,CAAC,CAAC,GAAG;IAC5B,OAAO,QAAQ,YAAY;IAE3B,IAAI,QAAQ,0BAA0B,KAAK,OAAO;QAChD,KAAK,MAAM,QAAQ,OAAO,IAAI,CAAC,OAAO,KAAK,EAAG;YAC5C,MAAM,OAAO,OAAO,KAAK,CAAC,KAAK;YAC/B,IAAI,KAAK,MAAM,IAAI,MAAM;gBACvB,aAAa,KAAK,MAAM,EAAE,SAAS,SAAS;gBAE5C,oEAAoE;gBACpE,KAAK,MAAM,CAAC,SAAS,CAAC,YAAY,CAAC,KAAK,MAAM;YAChD;QACF;IACF;IAEA,MAAM,iBAAiB,OAAO,cAAc;IAC5C,IAAI,kBAAkB,MAAM;QAC1B;IACF;IAEA,MAAM,+BAA+B,QAAQ,4BAA4B;IAEzE,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,KAAK,MAAM,oBAAoB,KAAM;QACnC,MAAM,sBAAsB,cAAc,CAAC,iBAAiB;QAE5D,aAAa,qBAAqB,SAChC;YAAE,cAAc,CAAC;QAA6B,GAAG;IACrD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3387, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/getDefaultBulkwriteResult.js"],"sourcesContent":["'use strict';\n\nfunction getDefaultBulkwriteResult() {\n  return {\n    ok: 1,\n    nInserted: 0,\n    nUpserted: 0,\n    nMatched: 0,\n    nModified: 0,\n    nRemoved: 0,\n    upserted: [],\n    writeErrors: [],\n    insertedIds: [],\n    writeConcernErrors: []\n  };\n}\n\nmodule.exports = getDefaultBulkwriteResult;\n"],"names":[],"mappings":"AAEA,SAAS;IACP,OAAO;QACL,IAAI;QACJ,WAAW;QACX,WAAW;QACX,UAAU;QACV,WAAW;QACX,UAAU;QACV,UAAU,EAAE;QACZ,aAAa,EAAE;QACf,aAAa,EAAE;QACf,oBAAoB,EAAE;IACxB;AACF;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3406, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/update/modifiedPaths.js"],"sourcesContent":["'use strict';\n\nconst _modifiedPaths = require('../common').modifiedPaths;\n\n/**\n * Given an update document with potential update operators (`$set`, etc.)\n * returns an object whose keys are the directly modified paths.\n *\n * If there are any top-level keys that don't start with `$`, we assume those\n * will get wrapped in a `$set`. The Mongoose Query is responsible for wrapping\n * top-level keys in `$set`.\n *\n * @param {Object} update\n * @return {Object} modified\n */\n\nmodule.exports = function modifiedPaths(update) {\n  const keys = Object.keys(update);\n  const res = {};\n\n  const withoutDollarKeys = {};\n  for (const key of keys) {\n    if (key.startsWith('$')) {\n      _modifiedPaths(update[key], '', res);\n      continue;\n    }\n    withoutDollarKeys[key] = update[key];\n  }\n\n  _modifiedPaths(withoutDollarKeys, '', res);\n\n  return res;\n};\n"],"names":[],"mappings":"AAEA,MAAM,iBAAiB,4GAAqB,aAAa;AAEzD;;;;;;;;;;CAUC,GAED,OAAO,OAAO,GAAG,SAAS,cAAc,MAAM;IAC5C,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,MAAM,MAAM,CAAC;IAEb,MAAM,oBAAoB,CAAC;IAC3B,KAAK,MAAM,OAAO,KAAM;QACtB,IAAI,IAAI,UAAU,CAAC,MAAM;YACvB,eAAe,MAAM,CAAC,IAAI,EAAE,IAAI;YAChC;QACF;QACA,iBAAiB,CAAC,IAAI,GAAG,MAAM,CAAC,IAAI;IACtC;IAEA,eAAe,mBAAmB,IAAI;IAEtC,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3435, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/update/updatedPathsByArrayFilter.js"],"sourcesContent":["'use strict';\n\nconst modifiedPaths = require('./modifiedPaths');\n\nmodule.exports = function updatedPathsByArrayFilter(update) {\n  if (update == null) {\n    return {};\n  }\n  const updatedPaths = modifiedPaths(update);\n\n  return Object.keys(updatedPaths).reduce((cur, path) => {\n    const matches = path.match(/\\$\\[[^\\]]+\\]/g);\n    if (matches == null) {\n      return cur;\n    }\n    for (const match of matches) {\n      const firstMatch = path.indexOf(match);\n      if (firstMatch !== path.lastIndexOf(match)) {\n        throw new Error(`Path '${path}' contains the same array filter multiple times`);\n      }\n      cur[match.substring(2, match.length - 1)] = path.\n        substring(0, firstMatch - 1).\n        replace(/\\$\\[[^\\]]+\\]/g, '0');\n    }\n    return cur;\n  }, {});\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,0BAA0B,MAAM;IACxD,IAAI,UAAU,MAAM;QAClB,OAAO,CAAC;IACV;IACA,MAAM,eAAe,cAAc;IAEnC,OAAO,OAAO,IAAI,CAAC,cAAc,MAAM,CAAC,CAAC,KAAK;QAC5C,MAAM,UAAU,KAAK,KAAK,CAAC;QAC3B,IAAI,WAAW,MAAM;YACnB,OAAO;QACT;QACA,KAAK,MAAM,SAAS,QAAS;YAC3B,MAAM,aAAa,KAAK,OAAO,CAAC;YAChC,IAAI,eAAe,KAAK,WAAW,CAAC,QAAQ;gBAC1C,MAAM,IAAI,MAAM,CAAC,MAAM,EAAE,KAAK,+CAA+C,CAAC;YAChF;YACA,GAAG,CAAC,MAAM,SAAS,CAAC,GAAG,MAAM,MAAM,GAAG,GAAG,GAAG,KAC1C,SAAS,CAAC,GAAG,aAAa,GAC1B,OAAO,CAAC,iBAAiB;QAC7B;QACA,OAAO;IACT,GAAG,CAAC;AACN","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3460, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/getEmbeddedDiscriminatorPath.js"],"sourcesContent":["'use strict';\n\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst updatedPathsByArrayFilter = require('../update/updatedPathsByArrayFilter');\n\n/**\n * Like `schema.path()`, except with a document, because impossible to\n * determine path type without knowing the embedded discriminator key.\n * @param {Schema} schema\n * @param {Object} [update]\n * @param {Object} [filter]\n * @param {String} path\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function getEmbeddedDiscriminatorPath(schema, update, filter, path, options) {\n  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');\n  let schematype = null;\n  let type = 'adhocOrUndefined';\n\n  filter = filter || {};\n  update = update || {};\n  const arrayFilters = options != null && Array.isArray(options.arrayFilters) ?\n    options.arrayFilters : [];\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n  let startIndex = 0;\n\n  for (let i = 0; i < parts.length; ++i) {\n    const originalSubpath = parts.slice(startIndex, i + 1).join('.');\n    const subpath = cleanPositionalOperators(originalSubpath);\n    schematype = schema.path(subpath);\n    if (schematype == null) {\n      continue;\n    }\n\n    type = schema.pathType(subpath);\n    if ((schematype.$isSingleNested || schematype.$isMongooseDocumentArrayElement) &&\n        schematype.schema.discriminators != null) {\n      const key = get(schematype, 'schema.options.discriminatorKey');\n      const discriminatorValuePath = subpath + '.' + key;\n      const discriminatorFilterPath =\n        discriminatorValuePath.replace(/\\.\\d+\\./, '.');\n      let discriminatorKey = null;\n\n      if (discriminatorValuePath in filter) {\n        discriminatorKey = filter[discriminatorValuePath];\n      }\n      if (discriminatorFilterPath in filter) {\n        discriminatorKey = filter[discriminatorFilterPath];\n      }\n\n      const wrapperPath = subpath.replace(/\\.\\d+$/, '');\n      if (schematype.$isMongooseDocumentArrayElement &&\n          get(filter[wrapperPath], '$elemMatch.' + key) != null) {\n        discriminatorKey = filter[wrapperPath].$elemMatch[key];\n      }\n\n      const discriminatorKeyUpdatePath = originalSubpath + '.' + key;\n      if (discriminatorKeyUpdatePath in update) {\n        discriminatorKey = update[discriminatorKeyUpdatePath];\n      }\n\n      if (discriminatorValuePath in update) {\n        discriminatorKey = update[discriminatorValuePath];\n      }\n\n      for (const filterKey of Object.keys(updatedPathsByFilter)) {\n        const schemaKey = updatedPathsByFilter[filterKey] + '.' + key;\n        const arrayFilterKey = filterKey + '.' + key;\n        if (schemaKey === discriminatorFilterPath) {\n          const filter = arrayFilters.find(filter => filter.hasOwnProperty(arrayFilterKey));\n          if (filter != null) {\n            discriminatorKey = filter[arrayFilterKey];\n          }\n        }\n      }\n\n      if (discriminatorKey == null) {\n        continue;\n      }\n\n      const discriminator = getDiscriminatorByValue(schematype.caster.discriminators, discriminatorKey);\n      const discriminatorSchema = discriminator && discriminator.schema;\n      if (discriminatorSchema == null) {\n        continue;\n      }\n\n      const rest = parts.slice(i + 1).join('.');\n      schematype = discriminatorSchema.path(rest);\n      schema = discriminatorSchema;\n      startIndex = i + 1;\n      if (schematype != null) {\n        type = discriminatorSchema._getPathType(rest);\n        break;\n      }\n    }\n  }\n\n  return { type: type, schematype: schematype };\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN;;;;;;;;;CASC,GAED,OAAO,OAAO,GAAG,SAAS,6BAA6B,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,OAAO;IAC1F,MAAM,QAAQ,KAAK,OAAO,CAAC,SAAS,CAAC,IAAI;QAAC;KAAK,GAAG,KAAK,KAAK,CAAC;IAC7D,IAAI,aAAa;IACjB,IAAI,OAAO;IAEX,SAAS,UAAU,CAAC;IACpB,SAAS,UAAU,CAAC;IACpB,MAAM,eAAe,WAAW,QAAQ,MAAM,OAAO,CAAC,QAAQ,YAAY,IACxE,QAAQ,YAAY,GAAG,EAAE;IAC3B,MAAM,uBAAuB,0BAA0B;IACvD,IAAI,aAAa;IAEjB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,MAAM,EAAE,EAAE,EAAG;QACrC,MAAM,kBAAkB,MAAM,KAAK,CAAC,YAAY,IAAI,GAAG,IAAI,CAAC;QAC5D,MAAM,UAAU,yBAAyB;QACzC,aAAa,OAAO,IAAI,CAAC;QACzB,IAAI,cAAc,MAAM;YACtB;QACF;QAEA,OAAO,OAAO,QAAQ,CAAC;QACvB,IAAI,CAAC,WAAW,eAAe,IAAI,WAAW,+BAA+B,KACzE,WAAW,MAAM,CAAC,cAAc,IAAI,MAAM;YAC5C,MAAM,MAAM,IAAI,YAAY;YAC5B,MAAM,yBAAyB,UAAU,MAAM;YAC/C,MAAM,0BACJ,uBAAuB,OAAO,CAAC,WAAW;YAC5C,IAAI,mBAAmB;YAEvB,IAAI,0BAA0B,QAAQ;gBACpC,mBAAmB,MAAM,CAAC,uBAAuB;YACnD;YACA,IAAI,2BAA2B,QAAQ;gBACrC,mBAAmB,MAAM,CAAC,wBAAwB;YACpD;YAEA,MAAM,cAAc,QAAQ,OAAO,CAAC,UAAU;YAC9C,IAAI,WAAW,+BAA+B,IAC1C,IAAI,MAAM,CAAC,YAAY,EAAE,gBAAgB,QAAQ,MAAM;gBACzD,mBAAmB,MAAM,CAAC,YAAY,CAAC,UAAU,CAAC,IAAI;YACxD;YAEA,MAAM,6BAA6B,kBAAkB,MAAM;YAC3D,IAAI,8BAA8B,QAAQ;gBACxC,mBAAmB,MAAM,CAAC,2BAA2B;YACvD;YAEA,IAAI,0BAA0B,QAAQ;gBACpC,mBAAmB,MAAM,CAAC,uBAAuB;YACnD;YAEA,KAAK,MAAM,aAAa,OAAO,IAAI,CAAC,sBAAuB;gBACzD,MAAM,YAAY,oBAAoB,CAAC,UAAU,GAAG,MAAM;gBAC1D,MAAM,iBAAiB,YAAY,MAAM;gBACzC,IAAI,cAAc,yBAAyB;oBACzC,MAAM,SAAS,aAAa,IAAI,CAAC,CAAA,SAAU,OAAO,cAAc,CAAC;oBACjE,IAAI,UAAU,MAAM;wBAClB,mBAAmB,MAAM,CAAC,eAAe;oBAC3C;gBACF;YACF;YAEA,IAAI,oBAAoB,MAAM;gBAC5B;YACF;YAEA,MAAM,gBAAgB,wBAAwB,WAAW,MAAM,CAAC,cAAc,EAAE;YAChF,MAAM,sBAAsB,iBAAiB,cAAc,MAAM;YACjE,IAAI,uBAAuB,MAAM;gBAC/B;YACF;YAEA,MAAM,OAAO,MAAM,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;YACrC,aAAa,oBAAoB,IAAI,CAAC;YACtC,SAAS;YACT,aAAa,IAAI;YACjB,IAAI,cAAc,MAAM;gBACtB,OAAO,oBAAoB,YAAY,CAAC;gBACxC;YACF;QACF;IACF;IAEA,OAAO;QAAE,MAAM;QAAM,YAAY;IAAW;AAC9C","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3551, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/handleImmutable.js"],"sourcesContent":["'use strict';\n\nconst StrictModeError = require('../../error/strict');\n\n/**\n * Handle immutable option for a given path when casting updates based on options\n *\n * @param {SchemaType} schematype the resolved schematype for this path\n * @param {Boolean | 'throw' | null} strict whether strict mode is set for this query\n * @param {Object} obj the object containing the value being checked so we can delete\n * @param {String} key the key in `obj` which we are checking for immutability\n * @param {String} fullPath the full path being checked\n * @param {Object} options the query options\n * @param {Query} ctx the query. Passed as `this` and first param to the `immutable` option, if `immutable` is a function\n * @returns true if field was removed, false otherwise\n */\n\nmodule.exports = function handleImmutable(schematype, strict, obj, key, fullPath, options, ctx) {\n  if (schematype == null || !schematype.options || !schematype.options.immutable) {\n    return false;\n  }\n  let immutable = schematype.options.immutable;\n\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n  if (!immutable) {\n    return false;\n  }\n\n  if (options && options.overwriteImmutable) {\n    return false;\n  }\n  if (strict === false) {\n    return false;\n  }\n  if (strict === 'throw') {\n    throw new StrictModeError(null,\n      `Field ${fullPath} is immutable and strict = 'throw'`);\n  }\n\n  delete obj[key];\n  return true;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;;;;;;;;;;CAWC,GAED,OAAO,OAAO,GAAG,SAAS,gBAAgB,UAAU,EAAE,MAAM,EAAE,GAAG,EAAE,GAAG,EAAE,QAAQ,EAAE,OAAO,EAAE,GAAG;IAC5F,IAAI,cAAc,QAAQ,CAAC,WAAW,OAAO,IAAI,CAAC,WAAW,OAAO,CAAC,SAAS,EAAE;QAC9E,OAAO;IACT;IACA,IAAI,YAAY,WAAW,OAAO,CAAC,SAAS;IAE5C,IAAI,OAAO,cAAc,YAAY;QACnC,YAAY,UAAU,IAAI,CAAC,KAAK;IAClC;IACA,IAAI,CAAC,WAAW;QACd,OAAO;IACT;IAEA,IAAI,WAAW,QAAQ,kBAAkB,EAAE;QACzC,OAAO;IACT;IACA,IAAI,WAAW,OAAO;QACpB,OAAO;IACT;IACA,IAAI,WAAW,SAAS;QACtB,MAAM,IAAI,gBAAgB,MACxB,CAAC,MAAM,EAAE,SAAS,kCAAkC,CAAC;IACzD;IAEA,OAAO,GAAG,CAAC,IAAI;IACf,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3590, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/update/moveImmutableProperties.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\n\n/**\n * Given an update, move all $set on immutable properties to $setOnInsert.\n * This should only be called for upserts, because $setOnInsert bypasses the\n * strictness check for immutable properties.\n */\n\nmodule.exports = function moveImmutableProperties(schema, update, ctx) {\n  if (update == null) {\n    return;\n  }\n\n  const keys = Object.keys(update);\n  for (const key of keys) {\n    const isDollarKey = key.startsWith('$');\n\n    if (key === '$set') {\n      const updatedPaths = Object.keys(update[key]);\n      for (const path of updatedPaths) {\n        _walkUpdatePath(schema, update[key], path, update, ctx);\n      }\n    } else if (!isDollarKey) {\n      _walkUpdatePath(schema, update, key, update, ctx);\n    }\n\n  }\n};\n\nfunction _walkUpdatePath(schema, op, path, update, ctx) {\n  const schematype = schema.path(path);\n  if (schematype == null) {\n    return;\n  }\n\n  let immutable = get(schematype, 'options.immutable', null);\n  if (immutable == null) {\n    return;\n  }\n  if (typeof immutable === 'function') {\n    immutable = immutable.call(ctx, ctx);\n  }\n\n  if (!immutable) {\n    return;\n  }\n\n  update.$setOnInsert = update.$setOnInsert || {};\n  update.$setOnInsert[path] = op[path];\n  delete op[path];\n}\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;;;CAIC,GAED,OAAO,OAAO,GAAG,SAAS,wBAAwB,MAAM,EAAE,MAAM,EAAE,GAAG;IACnE,IAAI,UAAU,MAAM;QAClB;IACF;IAEA,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,KAAK,MAAM,OAAO,KAAM;QACtB,MAAM,cAAc,IAAI,UAAU,CAAC;QAEnC,IAAI,QAAQ,QAAQ;YAClB,MAAM,eAAe,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI;YAC5C,KAAK,MAAM,QAAQ,aAAc;gBAC/B,gBAAgB,QAAQ,MAAM,CAAC,IAAI,EAAE,MAAM,QAAQ;YACrD;QACF,OAAO,IAAI,CAAC,aAAa;YACvB,gBAAgB,QAAQ,QAAQ,KAAK,QAAQ;QAC/C;IAEF;AACF;AAEA,SAAS,gBAAgB,MAAM,EAAE,EAAE,EAAE,IAAI,EAAE,MAAM,EAAE,GAAG;IACpD,MAAM,aAAa,OAAO,IAAI,CAAC;IAC/B,IAAI,cAAc,MAAM;QACtB;IACF;IAEA,IAAI,YAAY,IAAI,YAAY,qBAAqB;IACrD,IAAI,aAAa,MAAM;QACrB;IACF;IACA,IAAI,OAAO,cAAc,YAAY;QACnC,YAAY,UAAU,IAAI,CAAC,KAAK;IAClC;IAEA,IAAI,CAAC,WAAW;QACd;IACF;IAEA,OAAO,YAAY,GAAG,OAAO,YAAY,IAAI,CAAC;IAC9C,OAAO,YAAY,CAAC,KAAK,GAAG,EAAE,CAAC,KAAK;IACpC,OAAO,EAAE,CAAC,KAAK;AACjB","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3635, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/path/setDottedPath.js"],"sourcesContent":["'use strict';\n\nconst specialProperties = require('../specialProperties');\n\n\nmodule.exports = function setDottedPath(obj, path, val) {\n  if (path.indexOf('.') === -1) {\n    if (specialProperties.has(path)) {\n      return;\n    }\n\n    obj[path] = val;\n    return;\n  }\n  const parts = path.split('.');\n\n  const last = parts.pop();\n  let cur = obj;\n  for (const part of parts) {\n    if (specialProperties.has(part)) {\n      continue;\n    }\n    if (cur[part] == null) {\n      cur[part] = {};\n    }\n\n    cur = cur[part];\n  }\n\n  if (!specialProperties.has(last)) {\n    cur[last] = val;\n  }\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAGN,OAAO,OAAO,GAAG,SAAS,cAAc,GAAG,EAAE,IAAI,EAAE,GAAG;IACpD,IAAI,KAAK,OAAO,CAAC,SAAS,CAAC,GAAG;QAC5B,IAAI,kBAAkB,GAAG,CAAC,OAAO;YAC/B;QACF;QAEA,GAAG,CAAC,KAAK,GAAG;QACZ;IACF;IACA,MAAM,QAAQ,KAAK,KAAK,CAAC;IAEzB,MAAM,OAAO,MAAM,GAAG;IACtB,IAAI,MAAM;IACV,KAAK,MAAM,QAAQ,MAAO;QACxB,IAAI,kBAAkB,GAAG,CAAC,OAAO;YAC/B;QACF;QACA,IAAI,GAAG,CAAC,KAAK,IAAI,MAAM;YACrB,GAAG,CAAC,KAAK,GAAG,CAAC;QACf;QAEA,MAAM,GAAG,CAAC,KAAK;IACjB;IAEA,IAAI,CAAC,kBAAkB,GAAG,CAAC,OAAO;QAChC,GAAG,CAAC,KAAK,GAAG;IACd;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3664, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/castUpdate.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst MongooseError = require('../../error/mongooseError');\nconst SchemaString = require('../../schema/string');\nconst StrictModeError = require('../../error/strict');\nconst ValidationError = require('../../error/validation');\nconst castNumber = require('../../cast/number');\nconst cast = require('../../cast');\nconst getConstructorName = require('../getConstructorName');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getEmbeddedDiscriminatorPath = require('./getEmbeddedDiscriminatorPath');\nconst handleImmutable = require('./handleImmutable');\nconst moveImmutableProperties = require('../update/moveImmutableProperties');\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst setDottedPath = require('../path/setDottedPath');\nconst utils = require('../../utils');\nconst { internalToObjectOptions } = require('../../options');\n\nconst mongodbUpdateOperators = new Set([\n  '$currentDate',\n  '$inc',\n  '$min',\n  '$max',\n  '$mul',\n  '$rename',\n  '$set',\n  '$setOnInsert',\n  '$unset',\n  '$addToSet',\n  '$pop',\n  '$pull',\n  '$push',\n  '$pullAll',\n  '$bit'\n]);\n\n/**\n * Casts an update op based on the given schema\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict] defaults to true\n * @param {Query} context passed to setters\n * @return {Boolean} true iff the update is non-empty\n * @api private\n */\nmodule.exports = function castUpdate(schema, obj, options, context, filter) {\n  if (obj == null) {\n    return undefined;\n  }\n  options = options || {};\n  // Update pipeline\n  if (Array.isArray(obj)) {\n    const len = obj.length;\n    for (let i = 0; i < len; ++i) {\n      const ops = Object.keys(obj[i]);\n      for (const op of ops) {\n        obj[i][op] = castPipelineOperator(op, obj[i][op]);\n      }\n    }\n    return obj;\n  }\n\n  if (schema != null &&\n      filter != null &&\n      utils.hasUserDefinedProperty(filter, schema.options.discriminatorKey) &&\n      typeof filter[schema.options.discriminatorKey] !== 'object' &&\n      schema.discriminators != null) {\n    const discriminatorValue = filter[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      (byValue && byValue.schema) ||\n      schema;\n  } else if (schema != null &&\n      options.overwriteDiscriminatorKey &&\n      utils.hasUserDefinedProperty(obj, schema.options.discriminatorKey) &&\n      schema.discriminators != null) {\n    const discriminatorValue = obj[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      (byValue && byValue.schema) ||\n      schema;\n  } else if (schema != null &&\n      options.overwriteDiscriminatorKey &&\n      obj.$set != null &&\n      utils.hasUserDefinedProperty(obj.$set, schema.options.discriminatorKey) &&\n      schema.discriminators != null) {\n    const discriminatorValue = obj.$set[schema.options.discriminatorKey];\n    const byValue = getDiscriminatorByValue(context.model.discriminators, discriminatorValue);\n    schema = schema.discriminators[discriminatorValue] ||\n      (byValue && byValue.schema) ||\n      schema;\n  }\n\n  if (options.upsert) {\n    moveImmutableProperties(schema, obj, context);\n  }\n\n  const ops = Object.keys(obj);\n  let i = ops.length;\n  const ret = {};\n  let val;\n  let hasDollarKey = false;\n\n  filter = filter || {};\n  while (i--) {\n    const op = ops[i];\n    if (!mongodbUpdateOperators.has(op)) {\n      // fix up $set sugar\n      if (!ret.$set) {\n        if (obj.$set) {\n          ret.$set = obj.$set;\n        } else {\n          ret.$set = {};\n        }\n      }\n      ret.$set[op] = obj[op];\n      ops.splice(i, 1);\n      if (!~ops.indexOf('$set')) ops.push('$set');\n    } else if (op === '$set') {\n      if (!ret.$set) {\n        ret[op] = obj[op];\n      }\n    } else {\n      ret[op] = obj[op];\n    }\n  }\n  // cast each value\n  i = ops.length;\n  while (i--) {\n    const op = ops[i];\n    val = ret[op];\n    hasDollarKey = hasDollarKey || op.startsWith('$');\n    if (val != null && val.$__) {\n      val = val.toObject(internalToObjectOptions);\n      ret[op] = val;\n    }\n    if (val &&\n        typeof val === 'object' &&\n        !Buffer.isBuffer(val) &&\n        mongodbUpdateOperators.has(op)) {\n      walkUpdatePath(schema, val, op, options, context, filter);\n    } else {\n      const msg = 'Invalid atomic update value for ' + op + '. '\n          + 'Expected an object, received ' + typeof val;\n      throw new Error(msg);\n    }\n\n    if (op.startsWith('$') && utils.isEmptyObject(val)) {\n      delete ret[op];\n    }\n  }\n\n  if (Object.keys(ret).length === 0 &&\n      options.upsert &&\n      Object.keys(filter).length > 0) {\n    // Trick the driver into allowing empty upserts to work around\n    // https://github.com/mongodb/node-mongodb-native/pull/2490\n    // Shallow clone to avoid passing defaults in re: gh-13962\n    return { $setOnInsert: { ...filter } };\n  }\n  return ret;\n};\n\n/*!\n * ignore\n */\n\nfunction castPipelineOperator(op, val) {\n  if (op === '$unset') {\n    if (typeof val !== 'string' && (!Array.isArray(val) || val.find(v => typeof v !== 'string'))) {\n      throw new MongooseError('Invalid $unset in pipeline, must be ' +\n        ' a string or an array of strings');\n    }\n    return val;\n  }\n  if (op === '$project') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid $project in pipeline, must be an object');\n    }\n    return val;\n  }\n  if (op === '$addFields' || op === '$set') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  } else if (op === '$replaceRoot' || op === '$replaceWith') {\n    if (val == null || typeof val !== 'object') {\n      throw new MongooseError('Invalid ' + op + ' in pipeline, must be an object');\n    }\n    return val;\n  }\n\n  throw new MongooseError('Invalid update pipeline operator: \"' + op + '\"');\n}\n\n/**\n * Walk each path of obj and cast its values\n * according to its schema.\n *\n * @param {Schema} schema\n * @param {Object} obj part of a query\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {Object} [options]\n * @param {Boolean|String} [options.strict]\n * @param {Query} context\n * @param {Object} filter\n * @param {String} pref path prefix (internal only)\n * @return {Bool} true if this path has keys to update\n * @api private\n */\n\nfunction walkUpdatePath(schema, obj, op, options, context, filter, prefix) {\n  const strict = options.strict;\n  prefix = prefix ? prefix + '.' : '';\n  const keys = Object.keys(obj);\n  let i = keys.length;\n  let hasKeys = false;\n  let schematype;\n  let key;\n  let val;\n\n  let aggregatedError = null;\n\n  const strictMode = strict != null ? strict : schema.options.strict;\n\n  while (i--) {\n    key = keys[i];\n    val = obj[key];\n\n    // `$pull` is special because we need to cast the RHS as a query, not as\n    // an update.\n    if (op === '$pull') {\n      schematype = schema._getSchema(prefix + key);\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n      if (schematype != null && schematype.schema != null) {\n        obj[key] = cast(schematype.schema, obj[key], options, context);\n        hasKeys = true;\n        continue;\n      }\n    }\n\n    const discriminatorKey = (prefix ? prefix + key : key);\n    if (\n      schema.discriminatorMapping != null &&\n      discriminatorKey === schema.options.discriminatorKey &&\n      schema.discriminatorMapping.value !== obj[key] &&\n      !options.overwriteDiscriminatorKey\n    ) {\n      if (strictMode === 'throw') {\n        const err = new Error('Can\\'t modify discriminator key \"' + discriminatorKey + '\" on discriminator model');\n        aggregatedError = _appendError(err, context, discriminatorKey, aggregatedError);\n        continue;\n      } else if (strictMode) {\n        delete obj[key];\n        continue;\n      }\n    }\n\n    if (getConstructorName(val) === 'Object') {\n      // watch for embedded doc schemas\n      schematype = schema._getSchema(prefix + key);\n\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, prefix + key, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n        }\n      }\n\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {\n        continue;\n      }\n\n      if (schematype && schematype.caster && op in castOps) {\n        // embedded doc schema\n        if ('$each' in val) {\n          hasKeys = true;\n          try {\n            obj[key] = {\n              $each: castUpdateVal(schematype, val.$each, op, key, context, prefix + key)\n            };\n          } catch (error) {\n            aggregatedError = _appendError(error, context, key, aggregatedError);\n          }\n\n          if (val.$slice != null) {\n            obj[key].$slice = val.$slice | 0;\n          }\n\n          if (val.$sort) {\n            obj[key].$sort = val.$sort;\n          }\n\n          if (val.$position != null) {\n            obj[key].$position = castNumber(val.$position);\n          }\n        } else {\n          if (schematype != null && schematype.$isSingleNested) {\n            const _strict = strict == null ? schematype.schema.options.strict : strict;\n            try {\n              obj[key] = schematype.castForQuery(null, val, context, { strict: _strict });\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          } else {\n            try {\n              obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n            } catch (error) {\n              aggregatedError = _appendError(error, context, key, aggregatedError);\n            }\n          }\n\n          if (obj[key] === void 0) {\n            delete obj[key];\n            continue;\n          }\n\n          hasKeys = true;\n        }\n      } else if ((op === '$currentDate') || (op in castOps && schematype)) {\n        // $currentDate can take an object\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else if (op === '$rename') {\n        const schematype = new SchemaString(`${prefix}${key}.$rename`);\n        try {\n          obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      } else {\n        const pathToCheck = (prefix + key);\n        const v = schema._getPathType(pathToCheck);\n        let _strict = strict;\n        if (v && v.schema && _strict == null) {\n          _strict = v.schema.options.strict;\n        }\n\n        if (v.pathType === 'undefined') {\n          if (_strict === 'throw') {\n            throw new StrictModeError(pathToCheck);\n          } else if (_strict) {\n            delete obj[key];\n            continue;\n          }\n        }\n\n        // gh-2314\n        // we should be able to set a schema-less field\n        // to an empty object literal\n        hasKeys |= walkUpdatePath(schema, val, op, options, context, filter, prefix + key) ||\n          (utils.isObject(val) && Object.keys(val).length === 0);\n      }\n    } else {\n      const isModifier = (key === '$each' || key === '$or' || key === '$and' || key === '$in');\n      if (isModifier && !prefix) {\n        throw new MongooseError('Invalid update: Unexpected modifier \"' + key + '\" as a key in operator. '\n          + 'Did you mean something like { $addToSet: { fieldName: { $each: [...] } } }? '\n          + 'Modifiers such as \"$each\", \"$or\", \"$and\", \"$in\" must appear under a valid field path.');\n      }\n      const checkPath = isModifier ? prefix : prefix + key;\n      schematype = schema._getSchema(checkPath);\n\n      // You can use `$setOnInsert` with immutable keys\n      if (op !== '$setOnInsert' &&\n          handleImmutable(schematype, strict, obj, key, prefix + key, options, context)) {\n        continue;\n      }\n\n      let pathDetails = schema._getPathType(checkPath);\n\n      // If no schema type, check for embedded discriminators because the\n      // filter or update may imply an embedded discriminator type. See #8378\n      if (schematype == null) {\n        const _res = getEmbeddedDiscriminatorPath(schema, obj, filter, checkPath, options);\n        if (_res.schematype != null) {\n          schematype = _res.schematype;\n          pathDetails = _res.type;\n        }\n      }\n\n      let isStrict = strict;\n      if (pathDetails && pathDetails.schema && strict == null) {\n        isStrict = pathDetails.schema.options.strict;\n      }\n\n      const skip = isStrict &&\n        !schematype &&\n        !/real|nested/.test(pathDetails.pathType);\n\n      if (skip) {\n        // Even if strict is `throw`, avoid throwing an error because of\n        // virtuals because of #6731\n        if (isStrict === 'throw' && schema.virtuals[checkPath] == null) {\n          throw new StrictModeError(prefix + key);\n        } else {\n          delete obj[key];\n        }\n      } else {\n        if (op === '$rename') {\n          if (obj[key] == null) {\n            throw new CastError('String', obj[key], `${prefix}${key}.$rename`);\n          }\n          const schematype = new SchemaString(`${prefix}${key}.$rename`);\n          obj[key] = schematype.castForQuery(null, obj[key], context);\n          continue;\n        }\n\n        try {\n          if (prefix.length === 0 || key.indexOf('.') === -1) {\n            obj[key] = castUpdateVal(schematype, val, op, key, context, prefix + key);\n          } else if (isStrict !== false || schematype != null) {\n            // Setting a nested dotted path that's in the schema. We don't allow paths with '.' in\n            // a schema, so replace the dotted path with a nested object to avoid ending up with\n            // dotted properties in the updated object. See (gh-10200)\n            setDottedPath(obj, key, castUpdateVal(schematype, val, op, key, context, prefix + key));\n            delete obj[key];\n          }\n        } catch (error) {\n          aggregatedError = _appendError(error, context, key, aggregatedError);\n        }\n\n        if (Array.isArray(obj[key]) && (op === '$addToSet' || op === '$push') && key !== '$each') {\n          if (schematype &&\n              schematype.caster &&\n              !schematype.caster.$isMongooseArray &&\n              !schematype.caster[schemaMixedSymbol]) {\n            obj[key] = { $each: obj[key] };\n          }\n        }\n\n        if (obj[key] === void 0) {\n          delete obj[key];\n          continue;\n        }\n\n        hasKeys = true;\n      }\n    }\n  }\n\n  if (aggregatedError != null) {\n    throw aggregatedError;\n  }\n\n  return hasKeys;\n}\n\n/*!\n * ignore\n */\n\nfunction _appendError(error, query, key, aggregatedError) {\n  if (typeof query !== 'object' || !query.options.multipleCastError) {\n    throw error;\n  }\n  aggregatedError = aggregatedError || new ValidationError();\n  aggregatedError.addError(key, error);\n  return aggregatedError;\n}\n\n/**\n * These operators should be cast to numbers instead\n * of their path schema type.\n * @api private\n */\n\nconst numberOps = {\n  $pop: 1,\n  $inc: 1\n};\n\n/**\n * These ops require no casting because the RHS doesn't do anything.\n * @api private\n */\n\nconst noCastOps = {\n  $unset: 1\n};\n\n/**\n * These operators require casting docs\n * to real Documents for Update operations.\n * @api private\n */\n\nconst castOps = {\n  $push: 1,\n  $addToSet: 1,\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/*!\n * ignore\n */\n\nconst overwriteOps = {\n  $set: 1,\n  $setOnInsert: 1\n};\n\n/**\n * Casts `val` according to `schema` and atomic `op`.\n *\n * @param {SchemaType} schema\n * @param {Object} val\n * @param {String} op the atomic operator ($pull, $set, etc)\n * @param {String} $conditional\n * @param {Query} context\n * @param {String} path\n * @api private\n */\n\nfunction castUpdateVal(schema, val, op, $conditional, context, path) {\n  if (!schema) {\n    // non-existing schema path\n    if (op in numberOps) {\n      try {\n        return castNumber(val);\n      } catch (err) {\n        throw new CastError('number', val, path);\n      }\n    }\n    return val;\n  }\n\n  // console.log('CastUpdateVal', path, op, val, schema);\n\n  const cond = schema.caster && op in castOps &&\n      (utils.isObject(val) || Array.isArray(val));\n  if (cond && !overwriteOps[op]) {\n    // Cast values for ops that add data to MongoDB.\n    // Ensures embedded documents get ObjectIds etc.\n    let schemaArrayDepth = 0;\n    let cur = schema;\n    while (cur.$isMongooseArray) {\n      ++schemaArrayDepth;\n      cur = cur.caster;\n    }\n    let arrayDepth = 0;\n    let _val = val;\n    while (Array.isArray(_val)) {\n      ++arrayDepth;\n      _val = _val[0];\n    }\n\n    const additionalNesting = schemaArrayDepth - arrayDepth;\n    while (arrayDepth < schemaArrayDepth) {\n      val = [val];\n      ++arrayDepth;\n    }\n\n    let tmp = schema.applySetters(Array.isArray(val) ? val : [val], context);\n\n    for (let i = 0; i < additionalNesting; ++i) {\n      tmp = tmp[0];\n    }\n    return tmp;\n  }\n\n  if (op in noCastOps) {\n    return val;\n  }\n  if (op in numberOps) {\n    // Null and undefined not allowed for $pop, $inc\n    if (val == null) {\n      throw new CastError('number', val, schema.path);\n    }\n    if (op === '$inc') {\n      // Support `$inc` with long, int32, etc. (gh-4283)\n      return schema.castForQuery(\n        null,\n        val,\n        context\n      );\n    }\n    try {\n      return castNumber(val);\n    } catch (error) {\n      throw new CastError('number', val, schema.path);\n    }\n  }\n  if (op === '$currentDate') {\n    if (typeof val === 'object') {\n      return { $type: val.$type };\n    }\n    return Boolean(val);\n  }\n\n  if (mongodbUpdateOperators.has($conditional)) {\n    return schema.castForQuery(\n      $conditional,\n      val,\n      context\n    );\n  }\n\n  if (overwriteOps[op]) {\n    const skipQueryCastForUpdate = val != null && schema.$isMongooseArray && schema.$fullPath != null && !schema.$fullPath.match(/\\d+$/);\n    const applySetters = schema[schemaMixedSymbol] != null;\n    if (skipQueryCastForUpdate || applySetters) {\n      return schema.applySetters(val, context);\n    }\n    return schema.castForQuery(\n      null,\n      val,\n      context\n    );\n  }\n\n  return schema.castForQuery(null, val, context);\n}\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM,oBAAoB,4GAAgC,iBAAiB;AAC3E,MAAM;AACN,MAAM;AACN,MAAM,EAAE,uBAAuB,EAAE;AAEjC,MAAM,yBAAyB,IAAI,IAAI;IACrC;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AAED;;;;;;;;;;CAUC,GACD,OAAO,OAAO,GAAG,SAAS,WAAW,MAAM,EAAE,GAAG,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM;IACxE,IAAI,OAAO,MAAM;QACf,OAAO;IACT;IACA,UAAU,WAAW,CAAC;IACtB,kBAAkB;IAClB,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,MAAM,MAAM,IAAI,MAAM;QACtB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE,EAAG;YAC5B,MAAM,MAAM,OAAO,IAAI,CAAC,GAAG,CAAC,EAAE;YAC9B,KAAK,MAAM,MAAM,IAAK;gBACpB,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,qBAAqB,IAAI,GAAG,CAAC,EAAE,CAAC,GAAG;YAClD;QACF;QACA,OAAO;IACT;IAEA,IAAI,UAAU,QACV,UAAU,QACV,MAAM,sBAAsB,CAAC,QAAQ,OAAO,OAAO,CAAC,gBAAgB,KACpE,OAAO,MAAM,CAAC,OAAO,OAAO,CAAC,gBAAgB,CAAC,KAAK,YACnD,OAAO,cAAc,IAAI,MAAM;QACjC,MAAM,qBAAqB,MAAM,CAAC,OAAO,OAAO,CAAC,gBAAgB,CAAC;QAClE,MAAM,UAAU,wBAAwB,QAAQ,KAAK,CAAC,cAAc,EAAE;QACtE,SAAS,OAAO,cAAc,CAAC,mBAAmB,IAC/C,WAAW,QAAQ,MAAM,IAC1B;IACJ,OAAO,IAAI,UAAU,QACjB,QAAQ,yBAAyB,IACjC,MAAM,sBAAsB,CAAC,KAAK,OAAO,OAAO,CAAC,gBAAgB,KACjE,OAAO,cAAc,IAAI,MAAM;QACjC,MAAM,qBAAqB,GAAG,CAAC,OAAO,OAAO,CAAC,gBAAgB,CAAC;QAC/D,MAAM,UAAU,wBAAwB,QAAQ,KAAK,CAAC,cAAc,EAAE;QACtE,SAAS,OAAO,cAAc,CAAC,mBAAmB,IAC/C,WAAW,QAAQ,MAAM,IAC1B;IACJ,OAAO,IAAI,UAAU,QACjB,QAAQ,yBAAyB,IACjC,IAAI,IAAI,IAAI,QACZ,MAAM,sBAAsB,CAAC,IAAI,IAAI,EAAE,OAAO,OAAO,CAAC,gBAAgB,KACtE,OAAO,cAAc,IAAI,MAAM;QACjC,MAAM,qBAAqB,IAAI,IAAI,CAAC,OAAO,OAAO,CAAC,gBAAgB,CAAC;QACpE,MAAM,UAAU,wBAAwB,QAAQ,KAAK,CAAC,cAAc,EAAE;QACtE,SAAS,OAAO,cAAc,CAAC,mBAAmB,IAC/C,WAAW,QAAQ,MAAM,IAC1B;IACJ;IAEA,IAAI,QAAQ,MAAM,EAAE;QAClB,wBAAwB,QAAQ,KAAK;IACvC;IAEA,MAAM,MAAM,OAAO,IAAI,CAAC;IACxB,IAAI,IAAI,IAAI,MAAM;IAClB,MAAM,MAAM,CAAC;IACb,IAAI;IACJ,IAAI,eAAe;IAEnB,SAAS,UAAU,CAAC;IACpB,MAAO,IAAK;QACV,MAAM,KAAK,GAAG,CAAC,EAAE;QACjB,IAAI,CAAC,uBAAuB,GAAG,CAAC,KAAK;YACnC,oBAAoB;YACpB,IAAI,CAAC,IAAI,IAAI,EAAE;gBACb,IAAI,IAAI,IAAI,EAAE;oBACZ,IAAI,IAAI,GAAG,IAAI,IAAI;gBACrB,OAAO;oBACL,IAAI,IAAI,GAAG,CAAC;gBACd;YACF;YACA,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG;YACtB,IAAI,MAAM,CAAC,GAAG;YACd,IAAI,CAAC,CAAC,IAAI,OAAO,CAAC,SAAS,IAAI,IAAI,CAAC;QACtC,OAAO,IAAI,OAAO,QAAQ;YACxB,IAAI,CAAC,IAAI,IAAI,EAAE;gBACb,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG;YACnB;QACF,OAAO;YACL,GAAG,CAAC,GAAG,GAAG,GAAG,CAAC,GAAG;QACnB;IACF;IACA,kBAAkB;IAClB,IAAI,IAAI,MAAM;IACd,MAAO,IAAK;QACV,MAAM,KAAK,GAAG,CAAC,EAAE;QACjB,MAAM,GAAG,CAAC,GAAG;QACb,eAAe,gBAAgB,GAAG,UAAU,CAAC;QAC7C,IAAI,OAAO,QAAQ,IAAI,GAAG,EAAE;YAC1B,MAAM,IAAI,QAAQ,CAAC;YACnB,GAAG,CAAC,GAAG,GAAG;QACZ;QACA,IAAI,OACA,OAAO,QAAQ,YACf,CAAC,OAAO,QAAQ,CAAC,QACjB,uBAAuB,GAAG,CAAC,KAAK;YAClC,eAAe,QAAQ,KAAK,IAAI,SAAS,SAAS;QACpD,OAAO;YACL,MAAM,MAAM,qCAAqC,KAAK,OAChD,kCAAkC,OAAO;YAC/C,MAAM,IAAI,MAAM;QAClB;QAEA,IAAI,GAAG,UAAU,CAAC,QAAQ,MAAM,aAAa,CAAC,MAAM;YAClD,OAAO,GAAG,CAAC,GAAG;QAChB;IACF;IAEA,IAAI,OAAO,IAAI,CAAC,KAAK,MAAM,KAAK,KAC5B,QAAQ,MAAM,IACd,OAAO,IAAI,CAAC,QAAQ,MAAM,GAAG,GAAG;QAClC,8DAA8D;QAC9D,2DAA2D;QAC3D,0DAA0D;QAC1D,OAAO;YAAE,cAAc;gBAAE,GAAG,MAAM;YAAC;QAAE;IACvC;IACA,OAAO;AACT;AAEA;;CAEC,GAED,SAAS,qBAAqB,EAAE,EAAE,GAAG;IACnC,IAAI,OAAO,UAAU;QACnB,IAAI,OAAO,QAAQ,YAAY,CAAC,CAAC,MAAM,OAAO,CAAC,QAAQ,IAAI,IAAI,CAAC,CAAA,IAAK,OAAO,MAAM,SAAS,GAAG;YAC5F,MAAM,IAAI,cAAc,yCACtB;QACJ;QACA,OAAO;IACT;IACA,IAAI,OAAO,YAAY;QACrB,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;YAC1C,MAAM,IAAI,cAAc;QAC1B;QACA,OAAO;IACT;IACA,IAAI,OAAO,gBAAgB,OAAO,QAAQ;QACxC,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;YAC1C,MAAM,IAAI,cAAc,aAAa,KAAK;QAC5C;QACA,OAAO;IACT,OAAO,IAAI,OAAO,kBAAkB,OAAO,gBAAgB;QACzD,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;YAC1C,MAAM,IAAI,cAAc,aAAa,KAAK;QAC5C;QACA,OAAO;IACT;IAEA,MAAM,IAAI,cAAc,wCAAwC,KAAK;AACvE;AAEA;;;;;;;;;;;;;;CAcC,GAED,SAAS,eAAe,MAAM,EAAE,GAAG,EAAE,EAAE,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM;IACvE,MAAM,SAAS,QAAQ,MAAM;IAC7B,SAAS,SAAS,SAAS,MAAM;IACjC,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,IAAI,IAAI,KAAK,MAAM;IACnB,IAAI,UAAU;IACd,IAAI;IACJ,IAAI;IACJ,IAAI;IAEJ,IAAI,kBAAkB;IAEtB,MAAM,aAAa,UAAU,OAAO,SAAS,OAAO,OAAO,CAAC,MAAM;IAElE,MAAO,IAAK;QACV,MAAM,IAAI,CAAC,EAAE;QACb,MAAM,GAAG,CAAC,IAAI;QAEd,wEAAwE;QACxE,aAAa;QACb,IAAI,OAAO,SAAS;YAClB,aAAa,OAAO,UAAU,CAAC,SAAS;YACxC,IAAI,cAAc,MAAM;gBACtB,MAAM,OAAO,6BAA6B,QAAQ,KAAK,QAAQ,SAAS,KAAK;gBAC7E,IAAI,KAAK,UAAU,IAAI,MAAM;oBAC3B,aAAa,KAAK,UAAU;gBAC9B;YACF;YACA,IAAI,cAAc,QAAQ,WAAW,MAAM,IAAI,MAAM;gBACnD,GAAG,CAAC,IAAI,GAAG,KAAK,WAAW,MAAM,EAAE,GAAG,CAAC,IAAI,EAAE,SAAS;gBACtD,UAAU;gBACV;YACF;QACF;QAEA,MAAM,mBAAoB,SAAS,SAAS,MAAM;QAClD,IACE,OAAO,oBAAoB,IAAI,QAC/B,qBAAqB,OAAO,OAAO,CAAC,gBAAgB,IACpD,OAAO,oBAAoB,CAAC,KAAK,KAAK,GAAG,CAAC,IAAI,IAC9C,CAAC,QAAQ,yBAAyB,EAClC;YACA,IAAI,eAAe,SAAS;gBAC1B,MAAM,MAAM,IAAI,MAAM,sCAAsC,mBAAmB;gBAC/E,kBAAkB,aAAa,KAAK,SAAS,kBAAkB;gBAC/D;YACF,OAAO,IAAI,YAAY;gBACrB,OAAO,GAAG,CAAC,IAAI;gBACf;YACF;QACF;QAEA,IAAI,mBAAmB,SAAS,UAAU;YACxC,iCAAiC;YACjC,aAAa,OAAO,UAAU,CAAC,SAAS;YAExC,IAAI,cAAc,MAAM;gBACtB,MAAM,OAAO,6BAA6B,QAAQ,KAAK,QAAQ,SAAS,KAAK;gBAC7E,IAAI,KAAK,UAAU,IAAI,MAAM;oBAC3B,aAAa,KAAK,UAAU;gBAC9B;YACF;YAEA,IAAI,OAAO,kBACP,gBAAgB,YAAY,QAAQ,KAAK,KAAK,SAAS,KAAK,SAAS,UAAU;gBACjF;YACF;YAEA,IAAI,cAAc,WAAW,MAAM,IAAI,MAAM,SAAS;gBACpD,sBAAsB;gBACtB,IAAI,WAAW,KAAK;oBAClB,UAAU;oBACV,IAAI;wBACF,GAAG,CAAC,IAAI,GAAG;4BACT,OAAO,cAAc,YAAY,IAAI,KAAK,EAAE,IAAI,KAAK,SAAS,SAAS;wBACzE;oBACF,EAAE,OAAO,OAAO;wBACd,kBAAkB,aAAa,OAAO,SAAS,KAAK;oBACtD;oBAEA,IAAI,IAAI,MAAM,IAAI,MAAM;wBACtB,GAAG,CAAC,IAAI,CAAC,MAAM,GAAG,IAAI,MAAM,GAAG;oBACjC;oBAEA,IAAI,IAAI,KAAK,EAAE;wBACb,GAAG,CAAC,IAAI,CAAC,KAAK,GAAG,IAAI,KAAK;oBAC5B;oBAEA,IAAI,IAAI,SAAS,IAAI,MAAM;wBACzB,GAAG,CAAC,IAAI,CAAC,SAAS,GAAG,WAAW,IAAI,SAAS;oBAC/C;gBACF,OAAO;oBACL,IAAI,cAAc,QAAQ,WAAW,eAAe,EAAE;wBACpD,MAAM,UAAU,UAAU,OAAO,WAAW,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG;wBACpE,IAAI;4BACF,GAAG,CAAC,IAAI,GAAG,WAAW,YAAY,CAAC,MAAM,KAAK,SAAS;gCAAE,QAAQ;4BAAQ;wBAC3E,EAAE,OAAO,OAAO;4BACd,kBAAkB,aAAa,OAAO,SAAS,KAAK;wBACtD;oBACF,OAAO;wBACL,IAAI;4BACF,GAAG,CAAC,IAAI,GAAG,cAAc,YAAY,KAAK,IAAI,KAAK,SAAS,SAAS;wBACvE,EAAE,OAAO,OAAO;4BACd,kBAAkB,aAAa,OAAO,SAAS,KAAK;wBACtD;oBACF;oBAEA,IAAI,GAAG,CAAC,IAAI,KAAK,KAAK,GAAG;wBACvB,OAAO,GAAG,CAAC,IAAI;wBACf;oBACF;oBAEA,UAAU;gBACZ;YACF,OAAO,IAAI,AAAC,OAAO,kBAAoB,MAAM,WAAW,YAAa;gBACnE,kCAAkC;gBAClC,IAAI;oBACF,GAAG,CAAC,IAAI,GAAG,cAAc,YAAY,KAAK,IAAI,KAAK,SAAS,SAAS;gBACvE,EAAE,OAAO,OAAO;oBACd,kBAAkB,aAAa,OAAO,SAAS,KAAK;gBACtD;gBAEA,IAAI,GAAG,CAAC,IAAI,KAAK,KAAK,GAAG;oBACvB,OAAO,GAAG,CAAC,IAAI;oBACf;gBACF;gBAEA,UAAU;YACZ,OAAO,IAAI,OAAO,WAAW;gBAC3B,MAAM,aAAa,IAAI,aAAa,GAAG,SAAS,IAAI,QAAQ,CAAC;gBAC7D,IAAI;oBACF,GAAG,CAAC,IAAI,GAAG,cAAc,YAAY,KAAK,IAAI,KAAK,SAAS,SAAS;gBACvE,EAAE,OAAO,OAAO;oBACd,kBAAkB,aAAa,OAAO,SAAS,KAAK;gBACtD;gBAEA,IAAI,GAAG,CAAC,IAAI,KAAK,KAAK,GAAG;oBACvB,OAAO,GAAG,CAAC,IAAI;oBACf;gBACF;gBAEA,UAAU;YACZ,OAAO;gBACL,MAAM,cAAe,SAAS;gBAC9B,MAAM,IAAI,OAAO,YAAY,CAAC;gBAC9B,IAAI,UAAU;gBACd,IAAI,KAAK,EAAE,MAAM,IAAI,WAAW,MAAM;oBACpC,UAAU,EAAE,MAAM,CAAC,OAAO,CAAC,MAAM;gBACnC;gBAEA,IAAI,EAAE,QAAQ,KAAK,aAAa;oBAC9B,IAAI,YAAY,SAAS;wBACvB,MAAM,IAAI,gBAAgB;oBAC5B,OAAO,IAAI,SAAS;wBAClB,OAAO,GAAG,CAAC,IAAI;wBACf;oBACF;gBACF;gBAEA,UAAU;gBACV,+CAA+C;gBAC/C,6BAA6B;gBAC7B,WAAW,eAAe,QAAQ,KAAK,IAAI,SAAS,SAAS,QAAQ,SAAS,QAC3E,MAAM,QAAQ,CAAC,QAAQ,OAAO,IAAI,CAAC,KAAK,MAAM,KAAK;YACxD;QACF,OAAO;YACL,MAAM,aAAc,QAAQ,WAAW,QAAQ,SAAS,QAAQ,UAAU,QAAQ;YAClF,IAAI,cAAc,CAAC,QAAQ;gBACzB,MAAM,IAAI,cAAc,0CAA0C,MAAM,6BACpE,iFACA;YACN;YACA,MAAM,YAAY,aAAa,SAAS,SAAS;YACjD,aAAa,OAAO,UAAU,CAAC;YAE/B,iDAAiD;YACjD,IAAI,OAAO,kBACP,gBAAgB,YAAY,QAAQ,KAAK,KAAK,SAAS,KAAK,SAAS,UAAU;gBACjF;YACF;YAEA,IAAI,cAAc,OAAO,YAAY,CAAC;YAEtC,mEAAmE;YACnE,uEAAuE;YACvE,IAAI,cAAc,MAAM;gBACtB,MAAM,OAAO,6BAA6B,QAAQ,KAAK,QAAQ,WAAW;gBAC1E,IAAI,KAAK,UAAU,IAAI,MAAM;oBAC3B,aAAa,KAAK,UAAU;oBAC5B,cAAc,KAAK,IAAI;gBACzB;YACF;YAEA,IAAI,WAAW;YACf,IAAI,eAAe,YAAY,MAAM,IAAI,UAAU,MAAM;gBACvD,WAAW,YAAY,MAAM,CAAC,OAAO,CAAC,MAAM;YAC9C;YAEA,MAAM,OAAO,YACX,CAAC,cACD,CAAC,cAAc,IAAI,CAAC,YAAY,QAAQ;YAE1C,IAAI,MAAM;gBACR,gEAAgE;gBAChE,4BAA4B;gBAC5B,IAAI,aAAa,WAAW,OAAO,QAAQ,CAAC,UAAU,IAAI,MAAM;oBAC9D,MAAM,IAAI,gBAAgB,SAAS;gBACrC,OAAO;oBACL,OAAO,GAAG,CAAC,IAAI;gBACjB;YACF,OAAO;gBACL,IAAI,OAAO,WAAW;oBACpB,IAAI,GAAG,CAAC,IAAI,IAAI,MAAM;wBACpB,MAAM,IAAI,UAAU,UAAU,GAAG,CAAC,IAAI,EAAE,GAAG,SAAS,IAAI,QAAQ,CAAC;oBACnE;oBACA,MAAM,aAAa,IAAI,aAAa,GAAG,SAAS,IAAI,QAAQ,CAAC;oBAC7D,GAAG,CAAC,IAAI,GAAG,WAAW,YAAY,CAAC,MAAM,GAAG,CAAC,IAAI,EAAE;oBACnD;gBACF;gBAEA,IAAI;oBACF,IAAI,OAAO,MAAM,KAAK,KAAK,IAAI,OAAO,CAAC,SAAS,CAAC,GAAG;wBAClD,GAAG,CAAC,IAAI,GAAG,cAAc,YAAY,KAAK,IAAI,KAAK,SAAS,SAAS;oBACvE,OAAO,IAAI,aAAa,SAAS,cAAc,MAAM;wBACnD,sFAAsF;wBACtF,oFAAoF;wBACpF,0DAA0D;wBAC1D,cAAc,KAAK,KAAK,cAAc,YAAY,KAAK,IAAI,KAAK,SAAS,SAAS;wBAClF,OAAO,GAAG,CAAC,IAAI;oBACjB;gBACF,EAAE,OAAO,OAAO;oBACd,kBAAkB,aAAa,OAAO,SAAS,KAAK;gBACtD;gBAEA,IAAI,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,KAAK,CAAC,OAAO,eAAe,OAAO,OAAO,KAAK,QAAQ,SAAS;oBACxF,IAAI,cACA,WAAW,MAAM,IACjB,CAAC,WAAW,MAAM,CAAC,gBAAgB,IACnC,CAAC,WAAW,MAAM,CAAC,kBAAkB,EAAE;wBACzC,GAAG,CAAC,IAAI,GAAG;4BAAE,OAAO,GAAG,CAAC,IAAI;wBAAC;oBAC/B;gBACF;gBAEA,IAAI,GAAG,CAAC,IAAI,KAAK,KAAK,GAAG;oBACvB,OAAO,GAAG,CAAC,IAAI;oBACf;gBACF;gBAEA,UAAU;YACZ;QACF;IACF;IAEA,IAAI,mBAAmB,MAAM;QAC3B,MAAM;IACR;IAEA,OAAO;AACT;AAEA;;CAEC,GAED,SAAS,aAAa,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,eAAe;IACtD,IAAI,OAAO,UAAU,YAAY,CAAC,MAAM,OAAO,CAAC,iBAAiB,EAAE;QACjE,MAAM;IACR;IACA,kBAAkB,mBAAmB,IAAI;IACzC,gBAAgB,QAAQ,CAAC,KAAK;IAC9B,OAAO;AACT;AAEA;;;;CAIC,GAED,MAAM,YAAY;IAChB,MAAM;IACN,MAAM;AACR;AAEA;;;CAGC,GAED,MAAM,YAAY;IAChB,QAAQ;AACV;AAEA;;;;CAIC,GAED,MAAM,UAAU;IACd,OAAO;IACP,WAAW;IACX,MAAM;IACN,cAAc;AAChB;AAEA;;CAEC,GAED,MAAM,eAAe;IACnB,MAAM;IACN,cAAc;AAChB;AAEA;;;;;;;;;;CAUC,GAED,SAAS,cAAc,MAAM,EAAE,GAAG,EAAE,EAAE,EAAE,YAAY,EAAE,OAAO,EAAE,IAAI;IACjE,IAAI,CAAC,QAAQ;QACX,2BAA2B;QAC3B,IAAI,MAAM,WAAW;YACnB,IAAI;gBACF,OAAO,WAAW;YACpB,EAAE,OAAO,KAAK;gBACZ,MAAM,IAAI,UAAU,UAAU,KAAK;YACrC;QACF;QACA,OAAO;IACT;IAEA,uDAAuD;IAEvD,MAAM,OAAO,OAAO,MAAM,IAAI,MAAM,WAChC,CAAC,MAAM,QAAQ,CAAC,QAAQ,MAAM,OAAO,CAAC,IAAI;IAC9C,IAAI,QAAQ,CAAC,YAAY,CAAC,GAAG,EAAE;QAC7B,gDAAgD;QAChD,gDAAgD;QAChD,IAAI,mBAAmB;QACvB,IAAI,MAAM;QACV,MAAO,IAAI,gBAAgB,CAAE;YAC3B,EAAE;YACF,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,aAAa;QACjB,IAAI,OAAO;QACX,MAAO,MAAM,OAAO,CAAC,MAAO;YAC1B,EAAE;YACF,OAAO,IAAI,CAAC,EAAE;QAChB;QAEA,MAAM,oBAAoB,mBAAmB;QAC7C,MAAO,aAAa,iBAAkB;YACpC,MAAM;gBAAC;aAAI;YACX,EAAE;QACJ;QAEA,IAAI,MAAM,OAAO,YAAY,CAAC,MAAM,OAAO,CAAC,OAAO,MAAM;YAAC;SAAI,EAAE;QAEhE,IAAK,IAAI,IAAI,GAAG,IAAI,mBAAmB,EAAE,EAAG;YAC1C,MAAM,GAAG,CAAC,EAAE;QACd;QACA,OAAO;IACT;IAEA,IAAI,MAAM,WAAW;QACnB,OAAO;IACT;IACA,IAAI,MAAM,WAAW;QACnB,gDAAgD;QAChD,IAAI,OAAO,MAAM;YACf,MAAM,IAAI,UAAU,UAAU,KAAK,OAAO,IAAI;QAChD;QACA,IAAI,OAAO,QAAQ;YACjB,kDAAkD;YAClD,OAAO,OAAO,YAAY,CACxB,MACA,KACA;QAEJ;QACA,IAAI;YACF,OAAO,WAAW;QACpB,EAAE,OAAO,OAAO;YACd,MAAM,IAAI,UAAU,UAAU,KAAK,OAAO,IAAI;QAChD;IACF;IACA,IAAI,OAAO,gBAAgB;QACzB,IAAI,OAAO,QAAQ,UAAU;YAC3B,OAAO;gBAAE,OAAO,IAAI,KAAK;YAAC;QAC5B;QACA,OAAO,QAAQ;IACjB;IAEA,IAAI,uBAAuB,GAAG,CAAC,eAAe;QAC5C,OAAO,OAAO,YAAY,CACxB,cACA,KACA;IAEJ;IAEA,IAAI,YAAY,CAAC,GAAG,EAAE;QACpB,MAAM,yBAAyB,OAAO,QAAQ,OAAO,gBAAgB,IAAI,OAAO,SAAS,IAAI,QAAQ,CAAC,OAAO,SAAS,CAAC,KAAK,CAAC;QAC7H,MAAM,eAAe,MAAM,CAAC,kBAAkB,IAAI;QAClD,IAAI,0BAA0B,cAAc;YAC1C,OAAO,OAAO,YAAY,CAAC,KAAK;QAClC;QACA,OAAO,OAAO,YAAY,CACxB,MACA,KACA;IAEJ;IAEA,OAAO,OAAO,YAAY,CAAC,MAAM,KAAK;AACxC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4194, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/update/decorateUpdateWithVersionKey.js"],"sourcesContent":["'use strict';\n\n/**\n * Decorate the update with a version key, if necessary\n * @api private\n */\n\nmodule.exports = function decorateUpdateWithVersionKey(update, options, versionKey) {\n  if (!versionKey || !(options && options.upsert || false)) {\n    return;\n  }\n\n  if (options.overwrite) {\n    if (!hasKey(update, versionKey)) {\n      update[versionKey] = 0;\n    }\n  } else if (\n    !hasKey(update, versionKey) &&\n    !hasKey(update?.$set, versionKey) &&\n    !hasKey(update?.$inc, versionKey) &&\n    !hasKey(update?.$setOnInsert, versionKey)\n  ) {\n    if (!update.$setOnInsert) {\n      update.$setOnInsert = {};\n    }\n    update.$setOnInsert[versionKey] = 0;\n  }\n};\n\nfunction hasKey(obj, key) {\n  if (obj == null || typeof obj !== 'object') {\n    return false;\n  }\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n"],"names":[],"mappings":"AAEA;;;CAGC,GAED,OAAO,OAAO,GAAG,SAAS,6BAA6B,MAAM,EAAE,OAAO,EAAE,UAAU;IAChF,IAAI,CAAC,cAAc,CAAC,CAAC,WAAW,QAAQ,MAAM,IAAI,KAAK,GAAG;QACxD;IACF;IAEA,IAAI,QAAQ,SAAS,EAAE;QACrB,IAAI,CAAC,OAAO,QAAQ,aAAa;YAC/B,MAAM,CAAC,WAAW,GAAG;QACvB;IACF,OAAO,IACL,CAAC,OAAO,QAAQ,eAChB,CAAC,OAAO,QAAQ,MAAM,eACtB,CAAC,OAAO,QAAQ,MAAM,eACtB,CAAC,OAAO,QAAQ,cAAc,aAC9B;QACA,IAAI,CAAC,OAAO,YAAY,EAAE;YACxB,OAAO,YAAY,GAAG,CAAC;QACzB;QACA,OAAO,YAAY,CAAC,WAAW,GAAG;IACpC;AACF;AAEA,SAAS,OAAO,GAAG,EAAE,GAAG;IACtB,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;QAC1C,OAAO;IACT;IACA,OAAO,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,KAAK;AACnD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4222, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/setDefaultsOnInsert.js"],"sourcesContent":["'use strict';\nconst get = require('./get');\n\n/**\n * Applies defaults to update and findOneAndUpdate operations.\n *\n * @param {Object} filter\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method setDefaultsOnInsert\n * @api private\n */\n\nmodule.exports = function(filter, schema, castedDoc, options) {\n  options = options || {};\n\n  const shouldSetDefaultsOnInsert =\n    options.setDefaultsOnInsert != null ?\n      options.setDefaultsOnInsert :\n      schema.base.options.setDefaultsOnInsert;\n\n  if (!options.upsert || shouldSetDefaultsOnInsert === false) {\n    return castedDoc;\n  }\n\n  const keys = Object.keys(castedDoc || {});\n  const updatedKeys = {};\n  const updatedValues = {};\n  const numKeys = keys.length;\n\n  let hasDollarUpdate = false;\n\n  for (let i = 0; i < numKeys; ++i) {\n    if (keys[i].charAt(0) === '$') {\n      hasDollarUpdate = true;\n      break;\n    }\n  }\n\n  const paths = Object.keys(filter);\n  const numPaths = paths.length;\n  for (let i = 0; i < numPaths; ++i) {\n    const path = paths[i];\n    const condition = filter[path];\n    if (condition && typeof condition === 'object') {\n      const conditionKeys = Object.keys(condition);\n      const numConditionKeys = conditionKeys.length;\n      let hasDollarKey = false;\n      for (let j = 0; j < numConditionKeys; ++j) {\n        if (conditionKeys[j].charAt(0) === '$') {\n          hasDollarKey = true;\n          break;\n        }\n      }\n      if (hasDollarKey) {\n        continue;\n      }\n    }\n    updatedKeys[path] = true;\n  }\n\n  if (options && options.overwrite && !hasDollarUpdate) {\n    // Defaults will be set later, since we're overwriting we'll cast\n    // the whole update to a document\n    return castedDoc;\n  }\n\n  schema.eachPath(function(path, schemaType) {\n    // Skip single nested paths if underneath a map\n    if (schemaType.path === '_id' && schemaType.options.auto) {\n      return;\n    }\n    const def = schemaType.getDefault(null, true);\n    if (typeof def === 'undefined') {\n      return;\n    }\n    const pathPieces = schemaType.splitPath();\n    if (pathPieces.includes('$*')) {\n      // Skip defaults underneath maps. We should never do `$setOnInsert` on a path with `$*`\n      return;\n    }\n    if (isModified(castedDoc, updatedKeys, path, pathPieces, hasDollarUpdate)) {\n      return;\n    }\n\n    castedDoc = castedDoc || {};\n    castedDoc.$setOnInsert = castedDoc.$setOnInsert || {};\n    if (get(castedDoc, path) == null) {\n      castedDoc.$setOnInsert[path] = def;\n    }\n    updatedValues[path] = def;\n  });\n\n  return castedDoc;\n};\n\nfunction isModified(castedDoc, updatedKeys, path, pathPieces, hasDollarUpdate) {\n  // Check if path is in filter (updatedKeys)\n  if (updatedKeys[path]) {\n    return true;\n  }\n\n  // Check if any parent path is in filter\n  let cur = pathPieces[0];\n  for (let i = 1; i < pathPieces.length; ++i) {\n    if (updatedKeys[cur]) {\n      return true;\n    }\n    cur += '.' + pathPieces[i];\n  }\n\n  // Check if path is modified in the update\n  if (hasDollarUpdate) {\n    // Check each update operator\n    for (const key in castedDoc) {\n      if (key.charAt(0) === '$') {\n        if (pathExistsInUpdate(castedDoc[key], path, pathPieces)) {\n          return true;\n        }\n      }\n    }\n  } else {\n    // No dollar operators, check the castedDoc directly\n    if (pathExistsInUpdate(castedDoc, path, pathPieces)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction pathExistsInUpdate(update, targetPath, pathPieces) {\n  if (update == null || typeof update !== 'object') {\n    return false;\n  }\n\n  // Check exact match\n  if (update.hasOwnProperty(targetPath)) {\n    return true;\n  }\n\n  // Check if any parent path exists\n  let cur = pathPieces[0];\n  for (let i = 1; i < pathPieces.length; ++i) {\n    if (update.hasOwnProperty(cur)) {\n      return true;\n    }\n    cur += '.' + pathPieces[i];\n  }\n\n  // Check if any child path exists (e.g., path is \"a\" and update has \"a.b\")\n  const prefix = targetPath + '.';\n  for (const key in update) {\n    if (key.startsWith(prefix)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4361, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/model/castBulkWrite.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/mongooseError');\nconst getDiscriminatorByValue = require('../../helpers/discriminator/getDiscriminatorByValue');\nconst applyTimestampsToChildren = require('../update/applyTimestampsToChildren');\nconst applyTimestampsToUpdate = require('../update/applyTimestampsToUpdate');\nconst cast = require('../../cast');\nconst castUpdate = require('../query/castUpdate');\nconst clone = require('../clone');\nconst decorateUpdateWithVersionKey = require('../update/decorateUpdateWithVersionKey');\nconst { inspect } = require('util');\nconst setDefaultsOnInsert = require('../setDefaultsOnInsert');\n\n/**\n * Given a model and a bulkWrite op, return a thunk that handles casting and\n * validating the individual op.\n * @param {Model} originalModel\n * @param {Object} op\n * @param {Object} [options]\n * @api private\n */\n\nmodule.exports = function castBulkWrite(originalModel, op, options) {\n  const now = originalModel.base.now();\n\n  if (op['insertOne']) {\n    return callback => module.exports.castInsertOne(originalModel, op['insertOne'], options).then(() => callback(null), err => callback(err));\n  } else if (op['updateOne']) {\n    return (callback) => {\n      try {\n        module.exports.castUpdateOne(originalModel, op['updateOne'], options, now);\n        callback(null);\n      } catch (err) {\n        callback(err);\n      }\n    };\n  } else if (op['updateMany']) {\n    return (callback) => {\n      try {\n        module.exports.castUpdateMany(originalModel, op['updateMany'], options, now);\n        callback(null);\n      } catch (err) {\n        callback(err);\n      }\n    };\n  } else if (op['replaceOne']) {\n    return (callback) => {\n      module.exports.castReplaceOne(originalModel, op['replaceOne'], options).then(() => callback(null), err => callback(err));\n    };\n  } else if (op['deleteOne']) {\n    return (callback) => {\n      try {\n        module.exports.castDeleteOne(originalModel, op['deleteOne']);\n        callback(null);\n      } catch (err) {\n        callback(err);\n      }\n    };\n  } else if (op['deleteMany']) {\n    return (callback) => {\n      try {\n        module.exports.castDeleteMany(originalModel, op['deleteMany']);\n        callback(null);\n      } catch (err) {\n        callback(err);\n      }\n    };\n  } else {\n    return (callback) => {\n      const error = new MongooseError(`Invalid op passed to \\`bulkWrite()\\`: ${inspect(op)}`);\n      callback(error, null);\n    };\n  }\n};\n\nmodule.exports.castInsertOne = async function castInsertOne(originalModel, insertOne, options) {\n  const model = decideModelByObject(originalModel, insertOne['document']);\n\n  const doc = new model(insertOne['document']);\n  if (model.schema.options.timestamps && getTimestampsOpt(insertOne, options)) {\n    doc.initializeTimestamps();\n  }\n  if (options.session != null) {\n    doc.$session(options.session);\n  }\n  const versionKey = model?.schema?.options?.versionKey;\n  if (versionKey && doc[versionKey] == null) {\n    doc[versionKey] = 0;\n  }\n  insertOne['document'] = doc;\n\n  if (options.skipValidation || insertOne.skipValidation) {\n    return insertOne;\n  }\n\n  await insertOne['document'].$validate();\n  return insertOne;\n};\n\nmodule.exports.castUpdateOne = function castUpdateOne(originalModel, updateOne, options, now) {\n  if (!updateOne['filter']) {\n    throw new Error('Must provide a filter object.');\n  }\n  if (!updateOne['update']) {\n    throw new Error('Must provide an update object.');\n  }\n\n  const model = decideModelByObject(originalModel, updateOne['filter']);\n  const schema = model.schema;\n  const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n  const update = clone(updateOne['update']);\n\n  _addDiscriminatorToObject(schema, updateOne['filter']);\n\n  const doInitTimestamps = getTimestampsOpt(updateOne, options);\n\n  if (model.schema.$timestamps != null && doInitTimestamps) {\n    const createdAt = model.schema.$timestamps.createdAt;\n    const updatedAt = model.schema.$timestamps.updatedAt;\n    applyTimestampsToUpdate(now, createdAt, updatedAt, update, {});\n  }\n\n  if (doInitTimestamps) {\n    applyTimestampsToChildren(now, update, model.schema);\n  }\n\n  const globalSetDefaultsOnInsert = originalModel.base.options.setDefaultsOnInsert;\n  const shouldSetDefaultsOnInsert = updateOne.setDefaultsOnInsert == null ?\n    globalSetDefaultsOnInsert :\n    updateOne.setDefaultsOnInsert;\n  if (shouldSetDefaultsOnInsert !== false) {\n    setDefaultsOnInsert(updateOne['filter'], model.schema, update, {\n      setDefaultsOnInsert: true,\n      upsert: updateOne.upsert\n    });\n  }\n\n  decorateUpdateWithVersionKey(\n    update,\n    updateOne,\n    model.schema.options.versionKey\n  );\n\n  updateOne['filter'] = cast(model.schema, updateOne['filter'], {\n    strict: strict,\n    upsert: updateOne.upsert\n  });\n  updateOne['update'] = castUpdate(model.schema, update, {\n    strict: strict,\n    upsert: updateOne.upsert,\n    arrayFilters: updateOne.arrayFilters,\n    overwriteDiscriminatorKey: updateOne.overwriteDiscriminatorKey\n  }, model, updateOne['filter']);\n\n  return updateOne;\n};\n\nmodule.exports.castUpdateMany = function castUpdateMany(originalModel, updateMany, options, now) {\n  if (!updateMany['filter']) {\n    throw new Error('Must provide a filter object.');\n  }\n  if (!updateMany['update']) {\n    throw new Error('Must provide an update object.');\n  }\n\n  const model = decideModelByObject(originalModel, updateMany['filter']);\n  const schema = model.schema;\n  const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n  const globalSetDefaultsOnInsert = originalModel.base.options.setDefaultsOnInsert;\n  const shouldSetDefaultsOnInsert = updateMany.setDefaultsOnInsert == null ?\n    globalSetDefaultsOnInsert :\n    updateMany.setDefaultsOnInsert;\n\n  if (shouldSetDefaultsOnInsert !== false) {\n    setDefaultsOnInsert(updateMany['filter'], model.schema, updateMany['update'], {\n      setDefaultsOnInsert: true,\n      upsert: updateMany.upsert\n    });\n  }\n\n  const doInitTimestamps = getTimestampsOpt(updateMany, options);\n\n  if (model.schema.$timestamps != null && doInitTimestamps) {\n    const createdAt = model.schema.$timestamps.createdAt;\n    const updatedAt = model.schema.$timestamps.updatedAt;\n    applyTimestampsToUpdate(now, createdAt, updatedAt, updateMany['update'], {});\n  }\n  if (doInitTimestamps) {\n    applyTimestampsToChildren(now, updateMany['update'], model.schema);\n  }\n\n  _addDiscriminatorToObject(schema, updateMany['filter']);\n\n  decorateUpdateWithVersionKey(\n    updateMany['update'],\n    updateMany,\n    model.schema.options.versionKey\n  );\n\n  updateMany['filter'] = cast(model.schema, updateMany['filter'], {\n    strict: strict,\n    upsert: updateMany.upsert\n  });\n\n  updateMany['update'] = castUpdate(model.schema, updateMany['update'], {\n    strict: strict,\n    upsert: updateMany.upsert,\n    arrayFilters: updateMany.arrayFilters,\n    overwriteDiscriminatorKey: updateMany.overwriteDiscriminatorKey\n  }, model, updateMany['filter']);\n};\n\nmodule.exports.castReplaceOne = async function castReplaceOne(originalModel, replaceOne, options) {\n  const model = decideModelByObject(originalModel, replaceOne['filter']);\n  const schema = model.schema;\n  const strict = options.strict != null ? options.strict : model.schema.options.strict;\n\n  _addDiscriminatorToObject(schema, replaceOne['filter']);\n  replaceOne['filter'] = cast(model.schema, replaceOne['filter'], {\n    strict: strict,\n    upsert: replaceOne.upsert\n  });\n\n  // set `skipId`, otherwise we get \"_id field cannot be changed\"\n  const doc = new model(replaceOne['replacement'], strict, true);\n  if (model.schema.options.timestamps && getTimestampsOpt(replaceOne, options)) {\n    doc.initializeTimestamps();\n  }\n  if (options.session != null) {\n    doc.$session(options.session);\n  }\n  const versionKey = model?.schema?.options?.versionKey;\n  if (versionKey && doc[versionKey] == null) {\n    doc[versionKey] = 0;\n  }\n  replaceOne['replacement'] = doc;\n\n  if (options.skipValidation || replaceOne.skipValidation) {\n    replaceOne['replacement'] = replaceOne['replacement'].toBSON();\n    return;\n  }\n\n  await replaceOne['replacement'].$validate();\n  replaceOne['replacement'] = replaceOne['replacement'].toBSON();\n};\n\nmodule.exports.castDeleteOne = function castDeleteOne(originalModel, deleteOne) {\n  const model = decideModelByObject(originalModel, deleteOne['filter']);\n  const schema = model.schema;\n\n  _addDiscriminatorToObject(schema, deleteOne['filter']);\n\n  deleteOne['filter'] = cast(model.schema, deleteOne['filter']);\n};\n\nmodule.exports.castDeleteMany = function castDeleteMany(originalModel, deleteMany) {\n  const model = decideModelByObject(originalModel, deleteMany['filter']);\n  const schema = model.schema;\n\n  _addDiscriminatorToObject(schema, deleteMany['filter']);\n\n  deleteMany['filter'] = cast(model.schema, deleteMany['filter']);\n};\n\nmodule.exports.cast = {\n  insertOne: module.exports.castInsertOne,\n  updateOne: module.exports.castUpdateOne,\n  updateMany: module.exports.castUpdateMany,\n  replaceOne: module.exports.castReplaceOne,\n  deleteOne: module.exports.castDeleteOne,\n  deleteMany: module.exports.castDeleteMany\n};\n\nfunction _addDiscriminatorToObject(schema, obj) {\n  if (schema == null) {\n    return;\n  }\n  if (schema.discriminatorMapping && !schema.discriminatorMapping.isRoot) {\n    obj[schema.discriminatorMapping.key] = schema.discriminatorMapping.value;\n  }\n}\n\n/**\n * gets discriminator model if discriminator key is present in object\n * @api private\n */\n\nfunction decideModelByObject(model, object) {\n  const discriminatorKey = model.schema.options.discriminatorKey;\n  if (object != null && object.hasOwnProperty(discriminatorKey)) {\n    model = getDiscriminatorByValue(model.discriminators, object[discriminatorKey]) || model;\n  }\n  return model;\n}\n\n\n/**\n * gets timestamps option for a given operation. If the option is set within an individual operation, use it. Otherwise, use the global timestamps option configured in the `bulkWrite` options. Overall default is `true`.\n * @api private\n */\n\nfunction getTimestampsOpt(opCommand, options) {\n  const opLevelOpt = opCommand.timestamps;\n  const bulkLevelOpt = options.timestamps;\n  if (opLevelOpt != null) {\n    return opLevelOpt;\n  } else if (bulkLevelOpt != null) {\n    return bulkLevelOpt;\n  }\n  return true;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4615, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/model/decorateBulkWriteResult.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function decorateBulkWriteResult(resultOrError, validationErrors, results) {\n  resultOrError.mongoose = resultOrError.mongoose || {};\n  resultOrError.mongoose.validationErrors = validationErrors;\n  resultOrError.mongoose.results = results;\n  return resultOrError;\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,wBAAwB,aAAa,EAAE,gBAAgB,EAAE,OAAO;IACxF,cAAc,QAAQ,GAAG,cAAc,QAAQ,IAAI,CAAC;IACpD,cAAc,QAAQ,CAAC,gBAAgB,GAAG;IAC1C,cAAc,QAAQ,CAAC,OAAO,GAAG;IACjC,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4625, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/processConnectionOptions.js"],"sourcesContent":["'use strict';\n\nconst clone = require('./clone');\nconst MongooseError = require('../error/index');\n\nfunction processConnectionOptions(uri, options) {\n  const opts = options ? options : {};\n  const readPreference = opts.readPreference\n    ? opts.readPreference\n    : getUriReadPreference(uri);\n\n  const clonedOpts = clone(opts);\n  const resolvedOpts = (readPreference && readPreference !== 'primary' && readPreference !== 'primaryPreferred')\n    ? resolveOptsConflicts(readPreference, clonedOpts)\n    : clonedOpts;\n\n  return resolvedOpts;\n}\n\nfunction resolveOptsConflicts(pref, opts) {\n  // don't silently override user-provided indexing options\n  if (setsIndexOptions(opts) && setsSecondaryRead(pref)) {\n    throwReadPreferenceError();\n  }\n\n  // if user has not explicitly set any auto-indexing options,\n  // we can silently default them all to false\n  else {\n    return defaultIndexOptsToFalse(opts);\n  }\n}\n\nfunction setsIndexOptions(opts) {\n  const configIdx = opts.config && opts.config.autoIndex;\n  const { autoCreate, autoIndex } = opts;\n  return !!(configIdx || autoCreate || autoIndex);\n}\n\nfunction setsSecondaryRead(prefString) {\n  return !!(prefString === 'secondary' || prefString === 'secondaryPreferred');\n}\n\nfunction getUriReadPreference(connectionString) {\n  const exp = /(?:&|\\?)readPreference=(\\w+)(?:&|$)/;\n  const match = exp.exec(connectionString);\n  return match ? match[1] : null;\n}\n\nfunction defaultIndexOptsToFalse(opts) {\n  opts.config = { autoIndex: false };\n  opts.autoCreate = false;\n  opts.autoIndex = false;\n  return opts;\n}\n\nfunction throwReadPreferenceError() {\n  throw new MongooseError(\n    'MongoDB prohibits index creation on connections that read from ' +\n            'non-primary replicas.  Connections that set \"readPreference\" to \"secondary\" or ' +\n            '\"secondaryPreferred\" may not opt-in to the following connection options: ' +\n            'autoCreate, autoIndex'\n  );\n}\n\nmodule.exports = processConnectionOptions;\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,SAAS,yBAAyB,GAAG,EAAE,OAAO;IAC5C,MAAM,OAAO,UAAU,UAAU,CAAC;IAClC,MAAM,iBAAiB,KAAK,cAAc,GACtC,KAAK,cAAc,GACnB,qBAAqB;IAEzB,MAAM,aAAa,MAAM;IACzB,MAAM,eAAe,AAAC,kBAAkB,mBAAmB,aAAa,mBAAmB,qBACvF,qBAAqB,gBAAgB,cACrC;IAEJ,OAAO;AACT;AAEA,SAAS,qBAAqB,IAAI,EAAE,IAAI;IACtC,yDAAyD;IACzD,IAAI,iBAAiB,SAAS,kBAAkB,OAAO;QACrD;IACF,OAIK;QACH,OAAO,wBAAwB;IACjC;AACF;AAEA,SAAS,iBAAiB,IAAI;IAC5B,MAAM,YAAY,KAAK,MAAM,IAAI,KAAK,MAAM,CAAC,SAAS;IACtD,MAAM,EAAE,UAAU,EAAE,SAAS,EAAE,GAAG;IAClC,OAAO,CAAC,CAAC,CAAC,aAAa,cAAc,SAAS;AAChD;AAEA,SAAS,kBAAkB,UAAU;IACnC,OAAO,CAAC,CAAC,CAAC,eAAe,eAAe,eAAe,oBAAoB;AAC7E;AAEA,SAAS,qBAAqB,gBAAgB;IAC5C,MAAM,MAAM;IACZ,MAAM,QAAQ,IAAI,IAAI,CAAC;IACvB,OAAO,QAAQ,KAAK,CAAC,EAAE,GAAG;AAC5B;AAEA,SAAS,wBAAwB,IAAI;IACnC,KAAK,MAAM,GAAG;QAAE,WAAW;IAAM;IACjC,KAAK,UAAU,GAAG;IAClB,KAAK,SAAS,GAAG;IACjB,OAAO;AACT;AAEA,SAAS;IACP,MAAM,IAAI,cACR,oEACQ,oFACA,8EACA;AAEZ;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4671, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/timers.js"],"sourcesContent":["'use strict';\n\nexports.setTimeout = setTimeout;\n"],"names":[],"mappings":"AAEA,QAAQ,UAAU,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4676, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/cursor/eachAsync.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst EachAsyncMultiError = require('../../error/eachAsyncMultiError');\nconst immediate = require('../immediate');\n\n/**\n * Execute `fn` for every document in the cursor. If `fn` returns a promise,\n * will wait for the promise to resolve before iterating on to the next one.\n * Returns a promise that resolves when done.\n *\n * @param {Function} next the thunk to call to get the next document\n * @param {Function} fn\n * @param {Object} options\n * @param {Number} [options.batchSize=null] if set, Mongoose will call `fn` with an array of at most `batchSize` documents, instead of a single document\n * @param {Number} [options.parallel=1] maximum number of `fn` calls that Mongoose will run in parallel\n * @param {AbortSignal} [options.signal] allow cancelling this eachAsync(). Once the abort signal is fired, `eachAsync()` will immediately fulfill the returned promise (or call the callback) and not fetch any more documents.\n * @return {Promise}\n * @api public\n * @method eachAsync\n */\n\nmodule.exports = async function eachAsync(next, fn, options) {\n  const parallel = options.parallel || 1;\n  const batchSize = options.batchSize;\n  const signal = options.signal;\n  const continueOnError = options.continueOnError;\n  const aggregatedErrors = [];\n  const enqueue = asyncQueue();\n\n  let aborted = false;\n\n  return new Promise((resolve, reject) => {\n    if (signal != null) {\n      if (signal.aborted) {\n        return resolve(null);\n      }\n\n      signal.addEventListener('abort', () => {\n        aborted = true;\n        return resolve(null);\n      }, { once: true });\n    }\n\n    if (batchSize != null) {\n      if (typeof batchSize !== 'number') {\n        throw new TypeError('batchSize must be a number');\n      } else if (!Number.isInteger(batchSize)) {\n        throw new TypeError('batchSize must be an integer');\n      } else if (batchSize < 1) {\n        throw new TypeError('batchSize must be at least 1');\n      }\n    }\n\n    iterate((err, res) => {\n      if (err != null) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n\n  function iterate(finalCallback) {\n    let handleResultsInProgress = 0;\n    let currentDocumentIndex = 0;\n\n    let error = null;\n    for (let i = 0; i < parallel; ++i) {\n      enqueue(createFetch());\n    }\n\n    function createFetch() {\n      let documentsBatch = [];\n      let drained = false;\n\n      return fetch;\n\n      function fetch(done) {\n        if (drained || aborted) {\n          return done();\n        } else if (error) {\n          return done();\n        }\n\n        next(function(err, doc) {\n          if (error != null) {\n            return done();\n          }\n          if (err != null) {\n            if (err.name === 'MongoCursorExhaustedError') {\n              // We may end up calling `next()` multiple times on an exhausted\n              // cursor, which leads to an error. In case cursor is exhausted,\n              // just treat it as if the cursor returned no document, which is\n              // how a cursor indicates it is exhausted.\n              doc = null;\n            } else if (continueOnError) {\n              aggregatedErrors.push(err);\n            } else {\n              error = err;\n              finalCallback(err);\n              return done();\n            }\n          }\n          if (doc == null) {\n            drained = true;\n            if (handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n\n              finalCallback(finalErr);\n            } else if (batchSize && documentsBatch.length) {\n              handleNextResult(documentsBatch, currentDocumentIndex++, handleNextResultCallBack);\n            }\n            return done();\n          }\n\n          ++handleResultsInProgress;\n\n          // Kick off the subsequent `next()` before handling the result, but\n          // make sure we know that we still have a result to handle re: #8422\n          immediate(() => done());\n\n          if (batchSize) {\n            documentsBatch.push(doc);\n          }\n\n          // If the current documents size is less than the provided batch size don't process the documents yet\n          if (batchSize && documentsBatch.length !== batchSize) {\n            immediate(() => enqueue(fetch));\n            return;\n          }\n\n          const docsToProcess = batchSize ? documentsBatch : doc;\n\n          function handleNextResultCallBack(err) {\n            if (batchSize) {\n              handleResultsInProgress -= documentsBatch.length;\n              documentsBatch = [];\n            } else {\n              --handleResultsInProgress;\n            }\n            if (err != null) {\n              if (continueOnError) {\n                aggregatedErrors.push(err);\n              } else {\n                error = err;\n                return finalCallback(err);\n              }\n            }\n            if ((drained || aborted) && handleResultsInProgress <= 0) {\n              const finalErr = continueOnError ?\n                createEachAsyncMultiError(aggregatedErrors) :\n                error;\n              return finalCallback(finalErr);\n            }\n\n            immediate(() => enqueue(fetch));\n          }\n\n          handleNextResult(docsToProcess, currentDocumentIndex++, handleNextResultCallBack);\n        });\n      }\n    }\n  }\n\n  function handleNextResult(doc, i, callback) {\n    let maybePromise;\n    try {\n      maybePromise = fn(doc, i);\n    } catch (err) {\n      return callback(err);\n    }\n    if (maybePromise && typeof maybePromise.then === 'function') {\n      maybePromise.then(\n        function() { callback(null); },\n        function(error) {\n          callback(error || new Error('`eachAsync()` promise rejected without error'));\n        });\n    } else {\n      callback(null);\n    }\n  }\n};\n\n// `next()` can only execute one at a time, so make sure we always execute\n// `next()` in series, while still allowing multiple `fn()` instances to run\n// in parallel.\nfunction asyncQueue() {\n  const _queue = [];\n  let inProgress = null;\n  let id = 0;\n\n  return function enqueue(fn) {\n    if (\n      inProgress === null &&\n      _queue.length === 0\n    ) {\n      inProgress = id++;\n      return fn(_step);\n    }\n    _queue.push(fn);\n  };\n\n  function _step() {\n    if (_queue.length !== 0) {\n      inProgress = id++;\n      const fn = _queue.shift();\n      fn(_step);\n    } else {\n      inProgress = null;\n    }\n  }\n}\n\nfunction createEachAsyncMultiError(aggregatedErrors) {\n  if (aggregatedErrors.length === 0) {\n    return null;\n  }\n\n  return new EachAsyncMultiError(aggregatedErrors);\n}\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,MAAM;AACN,MAAM;AAEN;;;;;;;;;;;;;;CAcC,GAED,OAAO,OAAO,GAAG,eAAe,UAAU,IAAI,EAAE,EAAE,EAAE,OAAO;IACzD,MAAM,WAAW,QAAQ,QAAQ,IAAI;IACrC,MAAM,YAAY,QAAQ,SAAS;IACnC,MAAM,SAAS,QAAQ,MAAM;IAC7B,MAAM,kBAAkB,QAAQ,eAAe;IAC/C,MAAM,mBAAmB,EAAE;IAC3B,MAAM,UAAU;IAEhB,IAAI,UAAU;IAEd,OAAO,IAAI,QAAQ,CAAC,SAAS;QAC3B,IAAI,UAAU,MAAM;YAClB,IAAI,OAAO,OAAO,EAAE;gBAClB,OAAO,QAAQ;YACjB;YAEA,OAAO,gBAAgB,CAAC,SAAS;gBAC/B,UAAU;gBACV,OAAO,QAAQ;YACjB,GAAG;gBAAE,MAAM;YAAK;QAClB;QAEA,IAAI,aAAa,MAAM;YACrB,IAAI,OAAO,cAAc,UAAU;gBACjC,MAAM,IAAI,UAAU;YACtB,OAAO,IAAI,CAAC,OAAO,SAAS,CAAC,YAAY;gBACvC,MAAM,IAAI,UAAU;YACtB,OAAO,IAAI,YAAY,GAAG;gBACxB,MAAM,IAAI,UAAU;YACtB;QACF;QAEA,QAAQ,CAAC,KAAK;YACZ,IAAI,OAAO,MAAM;gBACf,OAAO,OAAO;YAChB;YACA,QAAQ;QACV;IACF;;;IAEA,SAAS,QAAQ,aAAa;QAC5B,IAAI,0BAA0B;QAC9B,IAAI,uBAAuB;QAE3B,IAAI,QAAQ;QACZ,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,EAAE,EAAG;YACjC,QAAQ;QACV;QAEA,SAAS;YACP,IAAI,iBAAiB,EAAE;YACvB,IAAI,UAAU;YAEd,OAAO;;;YAEP,SAAS,MAAM,IAAI;gBACjB,IAAI,WAAW,SAAS;oBACtB,OAAO;gBACT,OAAO,IAAI,OAAO;oBAChB,OAAO;gBACT;gBAEA,KAAK,SAAS,GAAG,EAAE,GAAG;oBACpB,IAAI,SAAS,MAAM;wBACjB,OAAO;oBACT;oBACA,IAAI,OAAO,MAAM;wBACf,IAAI,IAAI,IAAI,KAAK,6BAA6B;4BAC5C,gEAAgE;4BAChE,gEAAgE;4BAChE,gEAAgE;4BAChE,0CAA0C;4BAC1C,MAAM;wBACR,OAAO,IAAI,iBAAiB;4BAC1B,iBAAiB,IAAI,CAAC;wBACxB,OAAO;4BACL,QAAQ;4BACR,cAAc;4BACd,OAAO;wBACT;oBACF;oBACA,IAAI,OAAO,MAAM;wBACf,UAAU;wBACV,IAAI,2BAA2B,GAAG;4BAChC,MAAM,WAAW,kBACf,0BAA0B,oBAC1B;4BAEF,cAAc;wBAChB,OAAO,IAAI,aAAa,eAAe,MAAM,EAAE;4BAC7C,iBAAiB,gBAAgB,wBAAwB;wBAC3D;wBACA,OAAO;oBACT;oBAEA,EAAE;oBAEF,mEAAmE;oBACnE,oEAAoE;oBACpE,UAAU,IAAM;oBAEhB,IAAI,WAAW;wBACb,eAAe,IAAI,CAAC;oBACtB;oBAEA,qGAAqG;oBACrG,IAAI,aAAa,eAAe,MAAM,KAAK,WAAW;wBACpD,UAAU,IAAM,QAAQ;wBACxB;oBACF;oBAEA,MAAM,gBAAgB,YAAY,iBAAiB;oBAEnD,SAAS,yBAAyB,GAAG;wBACnC,IAAI,WAAW;4BACb,2BAA2B,eAAe,MAAM;4BAChD,iBAAiB,EAAE;wBACrB,OAAO;4BACL,EAAE;wBACJ;wBACA,IAAI,OAAO,MAAM;4BACf,IAAI,iBAAiB;gCACnB,iBAAiB,IAAI,CAAC;4BACxB,OAAO;gCACL,QAAQ;gCACR,OAAO,cAAc;4BACvB;wBACF;wBACA,IAAI,CAAC,WAAW,OAAO,KAAK,2BAA2B,GAAG;4BACxD,MAAM,WAAW,kBACf,0BAA0B,oBAC1B;4BACF,OAAO,cAAc;wBACvB;wBAEA,UAAU,IAAM,QAAQ;oBAC1B;oBAEA,iBAAiB,eAAe,wBAAwB;gBAC1D;YACF;QACF;IACF;IAEA,SAAS,iBAAiB,GAAG,EAAE,CAAC,EAAE,QAAQ;QACxC,IAAI;QACJ,IAAI;YACF,eAAe,GAAG,KAAK;QACzB,EAAE,OAAO,KAAK;YACZ,OAAO,SAAS;QAClB;QACA,IAAI,gBAAgB,OAAO,aAAa,IAAI,KAAK,YAAY;YAC3D,aAAa,IAAI,CACf;gBAAa,SAAS;YAAO,GAC7B,SAAS,KAAK;gBACZ,SAAS,SAAS,IAAI,MAAM;YAC9B;QACJ,OAAO;YACL,SAAS;QACX;IACF;AACF;AAEA,0EAA0E;AAC1E,4EAA4E;AAC5E,eAAe;AACf,SAAS;IACP,MAAM,SAAS,EAAE;IACjB,IAAI,aAAa;IACjB,IAAI,KAAK;IAET,OAAO,SAAS,QAAQ,EAAE;QACxB,IACE,eAAe,QACf,OAAO,MAAM,KAAK,GAClB;YACA,aAAa;YACb,OAAO,GAAG;QACZ;QACA,OAAO,IAAI,CAAC;IACd;;;IAEA,SAAS;QACP,IAAI,OAAO,MAAM,KAAK,GAAG;YACvB,aAAa;YACb,MAAM,KAAK,OAAO,KAAK;YACvB,GAAG;QACL,OAAO;YACL,aAAa;QACf;IACF;AACF;AAEA,SAAS,0BAA0B,gBAAgB;IACjD,IAAI,iBAAiB,MAAM,KAAK,GAAG;QACjC,OAAO;IACT;IAEA,OAAO,IAAI,oBAAoB;AACjC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4873, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/applyGlobalOption.js"],"sourcesContent":["'use strict';\n\nconst utils = require('../../utils');\n\nfunction applyGlobalMaxTimeMS(options, connectionOptions, baseOptions) {\n  applyGlobalOption(options, connectionOptions, baseOptions, 'maxTimeMS');\n}\n\nfunction applyGlobalDiskUse(options, connectionOptions, baseOptions) {\n  applyGlobalOption(options, connectionOptions, baseOptions, 'allowDiskUse');\n}\n\nmodule.exports = {\n  applyGlobalMaxTimeMS,\n  applyGlobalDiskUse\n};\n\n\nfunction applyGlobalOption(options, connectionOptions, baseOptions, optionName) {\n  if (utils.hasUserDefinedProperty(options, optionName)) {\n    return;\n  }\n\n  if (utils.hasUserDefinedProperty(connectionOptions, optionName)) {\n    options[optionName] = connectionOptions[optionName];\n  } else if (utils.hasUserDefinedProperty(baseOptions, optionName)) {\n    options[optionName] = baseOptions[optionName];\n  }\n}\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,SAAS,qBAAqB,OAAO,EAAE,iBAAiB,EAAE,WAAW;IACnE,kBAAkB,SAAS,mBAAmB,aAAa;AAC7D;AAEA,SAAS,mBAAmB,OAAO,EAAE,iBAAiB,EAAE,WAAW;IACjE,kBAAkB,SAAS,mBAAmB,aAAa;AAC7D;AAEA,OAAO,OAAO,GAAG;IACf;IACA;AACF;AAGA,SAAS,kBAAkB,OAAO,EAAE,iBAAiB,EAAE,WAAW,EAAE,UAAU;IAC5E,IAAI,MAAM,sBAAsB,CAAC,SAAS,aAAa;QACrD;IACF;IAEA,IAAI,MAAM,sBAAsB,CAAC,mBAAmB,aAAa;QAC/D,OAAO,CAAC,WAAW,GAAG,iBAAiB,CAAC,WAAW;IACrD,OAAO,IAAI,MAAM,sBAAsB,CAAC,aAAa,aAAa;QAChE,OAAO,CAAC,WAAW,GAAG,WAAW,CAAC,WAAW;IAC/C;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4898, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/applyReadConcern.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function applyReadConcern(schema, options) {\n  if (options.readConcern !== undefined) {\n    return;\n  }\n\n  // Don't apply default read concern to operations in transactions,\n  // because you shouldn't set read concern on individual operations\n  // within a transaction.\n  // See: https://www.mongodb.com/docs/manual/reference/read-concern/\n  if (options && options.session && options.session.transaction) {\n    return;\n  }\n\n  const level = schema.options?.readConcern?.level;\n  if (level != null) {\n    options.readConcern = { level };\n  }\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,iBAAiB,MAAM,EAAE,OAAO;IACxD,IAAI,QAAQ,WAAW,KAAK,WAAW;QACrC;IACF;IAEA,kEAAkE;IAClE,kEAAkE;IAClE,wBAAwB;IACxB,mEAAmE;IACnE,IAAI,WAAW,QAAQ,OAAO,IAAI,QAAQ,OAAO,CAAC,WAAW,EAAE;QAC7D;IACF;IAEA,MAAM,QAAQ,OAAO,OAAO,EAAE,aAAa;IAC3C,IAAI,SAAS,MAAM;QACjB,QAAQ,WAAW,GAAG;YAAE;QAAM;IAChC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4920, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/applyWriteConcern.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function applyWriteConcern(schema, options) {\n  if (options.writeConcern != null) {\n    return;\n  }\n  // Don't apply default write concern to operations in transactions,\n  // because setting write concern on an operation in a transaction is an error\n  // See: https://www.mongodb.com/docs/manual/reference/write-concern/\n  if (options && options.session && options.session.transaction) {\n    return;\n  }\n  const writeConcern = schema.options.writeConcern ?? {};\n  if (Object.keys(writeConcern).length != 0) {\n    options.writeConcern = {};\n    if (!('w' in options) && writeConcern.w != null) {\n      options.writeConcern.w = writeConcern.w;\n    }\n    if (!('j' in options) && writeConcern.j != null) {\n      options.writeConcern.j = writeConcern.j;\n    }\n    if (!('wtimeout' in options) && writeConcern.wtimeout != null) {\n      options.writeConcern.wtimeout = writeConcern.wtimeout;\n    }\n  }\n  else {\n    if (!('w' in options) && writeConcern.w != null) {\n      options.w = writeConcern.w;\n    }\n    if (!('j' in options) && writeConcern.j != null) {\n      options.j = writeConcern.j;\n    }\n    if (!('wtimeout' in options) && writeConcern.wtimeout != null) {\n      options.wtimeout = writeConcern.wtimeout;\n    }\n  }\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,kBAAkB,MAAM,EAAE,OAAO;IACzD,IAAI,QAAQ,YAAY,IAAI,MAAM;QAChC;IACF;IACA,mEAAmE;IACnE,6EAA6E;IAC7E,oEAAoE;IACpE,IAAI,WAAW,QAAQ,OAAO,IAAI,QAAQ,OAAO,CAAC,WAAW,EAAE;QAC7D;IACF;IACA,MAAM,eAAe,OAAO,OAAO,CAAC,YAAY,IAAI,CAAC;IACrD,IAAI,OAAO,IAAI,CAAC,cAAc,MAAM,IAAI,GAAG;QACzC,QAAQ,YAAY,GAAG,CAAC;QACxB,IAAI,CAAC,CAAC,OAAO,OAAO,KAAK,aAAa,CAAC,IAAI,MAAM;YAC/C,QAAQ,YAAY,CAAC,CAAC,GAAG,aAAa,CAAC;QACzC;QACA,IAAI,CAAC,CAAC,OAAO,OAAO,KAAK,aAAa,CAAC,IAAI,MAAM;YAC/C,QAAQ,YAAY,CAAC,CAAC,GAAG,aAAa,CAAC;QACzC;QACA,IAAI,CAAC,CAAC,cAAc,OAAO,KAAK,aAAa,QAAQ,IAAI,MAAM;YAC7D,QAAQ,YAAY,CAAC,QAAQ,GAAG,aAAa,QAAQ;QACvD;IACF,OACK;QACH,IAAI,CAAC,CAAC,OAAO,OAAO,KAAK,aAAa,CAAC,IAAI,MAAM;YAC/C,QAAQ,CAAC,GAAG,aAAa,CAAC;QAC5B;QACA,IAAI,CAAC,CAAC,OAAO,OAAO,KAAK,aAAa,CAAC,IAAI,MAAM;YAC/C,QAAQ,CAAC,GAAG,aAAa,CAAC;QAC5B;QACA,IAAI,CAAC,CAAC,cAAc,OAAO,KAAK,aAAa,QAAQ,IAAI,MAAM;YAC7D,QAAQ,QAAQ,GAAG,aAAa,QAAQ;QAC1C;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4958, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/castFilterPath.js"],"sourcesContent":["'use strict';\n\nconst isOperator = require('./isOperator');\n\nmodule.exports = function castFilterPath(ctx, schematype, val) {\n  const any$conditionals = Object.keys(val).some(isOperator);\n\n  if (!any$conditionals) {\n    return schematype.castForQuery(\n      null,\n      val,\n      ctx\n    );\n  }\n\n  const ks = Object.keys(val);\n\n  let k = ks.length;\n\n  while (k--) {\n    const $cond = ks[k];\n    const nested = val[$cond];\n\n    if ($cond === '$not') {\n      if (nested && schematype && !schematype.caster) {\n        const _keys = Object.keys(nested);\n        if (_keys.length && isOperator(_keys[0])) {\n          for (const key of Object.keys(nested)) {\n            nested[key] = schematype.castForQuery(\n              key,\n              nested[key],\n              ctx\n            );\n          }\n        } else {\n          val[$cond] = schematype.castForQuery(\n            $cond,\n            nested,\n            ctx\n          );\n        }\n        continue;\n      }\n    } else {\n      val[$cond] = schematype.castForQuery(\n        $cond,\n        nested,\n        ctx\n      );\n    }\n  }\n\n  return val;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,eAAe,GAAG,EAAE,UAAU,EAAE,GAAG;IAC3D,MAAM,mBAAmB,OAAO,IAAI,CAAC,KAAK,IAAI,CAAC;IAE/C,IAAI,CAAC,kBAAkB;QACrB,OAAO,WAAW,YAAY,CAC5B,MACA,KACA;IAEJ;IAEA,MAAM,KAAK,OAAO,IAAI,CAAC;IAEvB,IAAI,IAAI,GAAG,MAAM;IAEjB,MAAO,IAAK;QACV,MAAM,QAAQ,EAAE,CAAC,EAAE;QACnB,MAAM,SAAS,GAAG,CAAC,MAAM;QAEzB,IAAI,UAAU,QAAQ;YACpB,IAAI,UAAU,cAAc,CAAC,WAAW,MAAM,EAAE;gBAC9C,MAAM,QAAQ,OAAO,IAAI,CAAC;gBAC1B,IAAI,MAAM,MAAM,IAAI,WAAW,KAAK,CAAC,EAAE,GAAG;oBACxC,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,QAAS;wBACrC,MAAM,CAAC,IAAI,GAAG,WAAW,YAAY,CACnC,KACA,MAAM,CAAC,IAAI,EACX;oBAEJ;gBACF,OAAO;oBACL,GAAG,CAAC,MAAM,GAAG,WAAW,YAAY,CAClC,OACA,QACA;gBAEJ;gBACA;YACF;QACF,OAAO;YACL,GAAG,CAAC,MAAM,GAAG,WAAW,YAAY,CAClC,OACA,QACA;QAEJ;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4991, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/schema/getPath.js"],"sourcesContent":["'use strict';\n\nconst numberRE = /^\\d+$/;\n\n/**\n * Behaves like `Schema#path()`, except for it also digs into arrays without\n * needing to put `.0.`, so `getPath(schema, 'docArr.elProp')` works.\n * @api private\n */\n\nmodule.exports = function getPath(schema, path, discriminatorValueMap) {\n  let schematype = schema.path(path);\n  if (schematype != null) {\n    return schematype;\n  }\n  const pieces = path.split('.');\n  let cur = '';\n  let isArray = false;\n\n  for (const piece of pieces) {\n    if (isArray && numberRE.test(piece)) {\n      continue;\n    }\n    cur = cur.length === 0 ? piece : cur + '.' + piece;\n\n    schematype = schema.path(cur);\n    if (schematype?.schema) {\n      schema = schematype.schema;\n      if (!isArray && schematype.$isMongooseDocumentArray) {\n        isArray = true;\n      }\n      if (discriminatorValueMap && discriminatorValueMap[cur]) {\n        schema = schema.discriminators[discriminatorValueMap[cur]] ?? schema;\n      }\n      cur = '';\n    } else if (schematype?.instance === 'Mixed') {\n      // If we found a mixed path, no point in digging further, the end result is always Mixed\n      break;\n    }\n  }\n\n  return schematype;\n};\n"],"names":[],"mappings":"AAEA,MAAM,WAAW;AAEjB;;;;CAIC,GAED,OAAO,OAAO,GAAG,SAAS,QAAQ,MAAM,EAAE,IAAI,EAAE,qBAAqB;IACnE,IAAI,aAAa,OAAO,IAAI,CAAC;IAC7B,IAAI,cAAc,MAAM;QACtB,OAAO;IACT;IACA,MAAM,SAAS,KAAK,KAAK,CAAC;IAC1B,IAAI,MAAM;IACV,IAAI,UAAU;IAEd,KAAK,MAAM,SAAS,OAAQ;QAC1B,IAAI,WAAW,SAAS,IAAI,CAAC,QAAQ;YACnC;QACF;QACA,MAAM,IAAI,MAAM,KAAK,IAAI,QAAQ,MAAM,MAAM;QAE7C,aAAa,OAAO,IAAI,CAAC;QACzB,IAAI,YAAY,QAAQ;YACtB,SAAS,WAAW,MAAM;YAC1B,IAAI,CAAC,WAAW,WAAW,wBAAwB,EAAE;gBACnD,UAAU;YACZ;YACA,IAAI,yBAAyB,qBAAqB,CAAC,IAAI,EAAE;gBACvD,SAAS,OAAO,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI;YAChE;YACA,MAAM;QACR,OAAO,IAAI,YAAY,aAAa,SAAS;YAE3C;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5029, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/update/castArrayFilters.js"],"sourcesContent":["'use strict';\n\nconst castFilterPath = require('../query/castFilterPath');\nconst cleanPositionalOperators = require('../schema/cleanPositionalOperators');\nconst getPath = require('../schema/getPath');\nconst updatedPathsByArrayFilter = require('./updatedPathsByArrayFilter');\n\nmodule.exports = function castArrayFilters(query) {\n  const arrayFilters = query.options.arrayFilters;\n  if (!Array.isArray(arrayFilters)) {\n    return;\n  }\n  const update = query.getUpdate();\n  const schema = query.schema;\n  const updatedPathsByFilter = updatedPathsByArrayFilter(update);\n\n  let strictQuery = schema.options.strict;\n  if (query._mongooseOptions.strict != null) {\n    strictQuery = query._mongooseOptions.strict;\n  }\n  if (query.model && query.model.base.options.strictQuery != null) {\n    strictQuery = query.model.base.options.strictQuery;\n  }\n  if (schema._userProvidedOptions.strictQuery != null) {\n    strictQuery = schema._userProvidedOptions.strictQuery;\n  }\n  if (query._mongooseOptions.strictQuery != null) {\n    strictQuery = query._mongooseOptions.strictQuery;\n  }\n\n  _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query);\n};\n\nfunction _castArrayFilters(arrayFilters, schema, strictQuery, updatedPathsByFilter, query) {\n  // Map to store discriminator values for embedded documents in the array filters.\n  // This is used to handle cases where array filters target specific embedded document types.\n  const discriminatorValueMap = {};\n\n  for (const filter of arrayFilters) {\n    if (filter == null) {\n      throw new Error(`Got null array filter in ${arrayFilters}`);\n    }\n    const keys = Object.keys(filter).filter(key => filter[key] != null);\n    if (keys.length === 0) {\n      continue;\n    }\n\n    const firstKey = keys[0];\n    if (firstKey === '$and' || firstKey === '$or') {\n      for (const key of keys) {\n        _castArrayFilters(filter[key], schema, strictQuery, updatedPathsByFilter, query);\n      }\n      continue;\n    }\n    const dot = firstKey.indexOf('.');\n    const filterWildcardPath = dot === -1 ? firstKey : firstKey.substring(0, dot);\n    if (updatedPathsByFilter[filterWildcardPath] == null) {\n      continue;\n    }\n    const baseFilterPath = cleanPositionalOperators(\n      updatedPathsByFilter[filterWildcardPath]\n    );\n\n    const baseSchematype = getPath(schema, baseFilterPath, discriminatorValueMap);\n    let filterBaseSchema = baseSchematype != null ? baseSchematype.schema : null;\n    if (filterBaseSchema != null &&\n        filterBaseSchema.discriminators != null &&\n        filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]) {\n      filterBaseSchema = filterBaseSchema.discriminators[filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey]] || filterBaseSchema;\n      discriminatorValueMap[baseFilterPath] = filter[filterWildcardPath + '.' + filterBaseSchema.options.discriminatorKey];\n    }\n\n    for (const key of keys) {\n      if (updatedPathsByFilter[key] === null) {\n        continue;\n      }\n      if (Object.keys(updatedPathsByFilter).length === 0) {\n        continue;\n      }\n      const dot = key.indexOf('.');\n\n      let filterPathRelativeToBase = dot === -1 ? null : key.substring(dot);\n      let schematype;\n      if (filterPathRelativeToBase == null || filterBaseSchema == null) {\n        schematype = baseSchematype;\n      } else {\n        // If there are multiple array filters in the path being updated, make sure\n        // to replace them so we can get the schema path.\n        filterPathRelativeToBase = cleanPositionalOperators(filterPathRelativeToBase);\n        schematype = getPath(filterBaseSchema, filterPathRelativeToBase, discriminatorValueMap);\n      }\n\n      if (schematype == null) {\n        if (!strictQuery) {\n          return;\n        }\n        const filterPath = filterPathRelativeToBase == null ?\n          baseFilterPath + '.0' :\n          baseFilterPath + '.0' + filterPathRelativeToBase;\n        // For now, treat `strictQuery = true` and `strictQuery = 'throw'` as\n        // equivalent for casting array filters. `strictQuery = true` doesn't\n        // quite work in this context because we never want to silently strip out\n        // array filters, even if the path isn't in the schema.\n        throw new Error(`Could not find path \"${filterPath}\" in schema`);\n      }\n      if (typeof filter[key] === 'object') {\n        filter[key] = castFilterPath(query, schematype, filter[key]);\n      } else {\n        filter[key] = schematype.castForQuery(null, filter[key]);\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5128, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/projection/isInclusive.js"],"sourcesContent":["'use strict';\n\nconst isDefiningProjection = require('./isDefiningProjection');\nconst isPOJO = require('../isPOJO');\n\n/*!\n * ignore\n */\n\nmodule.exports = function isInclusive(projection) {\n  if (projection == null) {\n    return false;\n  }\n\n  const props = Object.keys(projection);\n  const numProps = props.length;\n  if (numProps === 0) {\n    return false;\n  }\n\n  for (let i = 0; i < numProps; ++i) {\n    const prop = props[i];\n    // Plus paths can't define the projection (see gh-7050)\n    if (prop.startsWith('+')) {\n      continue;\n    }\n    // If field is truthy (1, true, etc.) and not an object, then this\n    // projection must be inclusive. If object, assume its $meta, $slice, etc.\n    if (isDefiningProjection(projection[prop]) && !!projection[prop]) {\n      if (isPOJO(projection[prop])) {\n        return isInclusive(projection[prop]);\n      } else {\n        return !!projection[prop];\n      }\n    }\n  }\n\n  return false;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,YAAY,UAAU;IAC9C,IAAI,cAAc,MAAM;QACtB,OAAO;IACT;IAEA,MAAM,QAAQ,OAAO,IAAI,CAAC;IAC1B,MAAM,WAAW,MAAM,MAAM;IAC7B,IAAI,aAAa,GAAG;QAClB,OAAO;IACT;IAEA,IAAK,IAAI,IAAI,GAAG,IAAI,UAAU,EAAE,EAAG;QACjC,MAAM,OAAO,KAAK,CAAC,EAAE;QACrB,uDAAuD;QACvD,IAAI,KAAK,UAAU,CAAC,MAAM;YACxB;QACF;QACA,kEAAkE;QAClE,0EAA0E;QAC1E,IAAI,qBAAqB,UAAU,CAAC,KAAK,KAAK,CAAC,CAAC,UAAU,CAAC,KAAK,EAAE;YAChE,IAAI,OAAO,UAAU,CAAC,KAAK,GAAG;gBAC5B,OAAO,YAAY,UAAU,CAAC,KAAK;YACrC,OAAO;gBACL,OAAO,CAAC,CAAC,UAAU,CAAC,KAAK;YAC3B;QACF;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5163, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/projection/isSubpath.js"],"sourcesContent":["'use strict';\n\n/**\n * Determines if `path2` is a subpath of or equal to `path1`\n *\n * @param {string} path1\n * @param {string} path2\n * @return {Boolean}\n * @api private\n */\n\nmodule.exports = function isSubpath(path1, path2) {\n  return path1 === path2 || path2.startsWith(path1 + '.');\n};\n"],"names":[],"mappings":"AAEA;;;;;;;CAOC,GAED,OAAO,OAAO,GAAG,SAAS,UAAU,KAAK,EAAE,KAAK;IAC9C,OAAO,UAAU,SAAS,MAAM,UAAU,CAAC,QAAQ;AACrD","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5177, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/projection/parseProjection.js"],"sourcesContent":["'use strict';\n\n/**\n * Convert a string or array into a projection object, retaining all\n * `-` and `+` paths.\n */\n\nmodule.exports = function parseProjection(v, retainMinusPaths) {\n  const type = typeof v;\n\n  if (type === 'string') {\n    v = v.split(/\\s+/);\n  }\n  if (!Array.isArray(v) && Object.prototype.toString.call(v) !== '[object Arguments]') {\n    return v;\n  }\n\n  const len = v.length;\n  const ret = {};\n  for (let i = 0; i < len; ++i) {\n    let field = v[i];\n    if (!field) {\n      continue;\n    }\n    const include = '-' == field[0] ? 0 : 1;\n    if (!retainMinusPaths && include === 0) {\n      field = field.substring(1);\n    }\n    ret[field] = include;\n  }\n\n  return ret;\n};\n"],"names":[],"mappings":"AAEA;;;CAGC,GAED,OAAO,OAAO,GAAG,SAAS,gBAAgB,CAAC,EAAE,gBAAgB;IAC3D,MAAM,OAAO,OAAO;IAEpB,IAAI,SAAS,UAAU;QACrB,IAAI,EAAE,KAAK,CAAC;IACd;IACA,IAAI,CAAC,MAAM,OAAO,CAAC,MAAM,OAAO,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,sBAAsB;QACnF,OAAO;IACT;IAEA,MAAM,MAAM,EAAE,MAAM;IACpB,MAAM,MAAM,CAAC;IACb,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE,EAAG;QAC5B,IAAI,QAAQ,CAAC,CAAC,EAAE;QAChB,IAAI,CAAC,OAAO;YACV;QACF;QACA,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE,GAAG,IAAI;QACtC,IAAI,CAAC,oBAAoB,YAAY,GAAG;YACtC,QAAQ,MAAM,SAAS,CAAC;QAC1B;QACA,GAAG,CAAC,MAAM,GAAG;IACf;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5207, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/update/removeUnusedArrayFilters.js"],"sourcesContent":["'use strict';\n\n/**\n * MongoDB throws an error if there's unused array filters. That is, if `options.arrayFilters` defines\n * a filter, but none of the `update` keys use it. This should be enough to filter out all unused array\n * filters.\n */\n\nmodule.exports = function removeUnusedArrayFilters(update, arrayFilters) {\n  const updateKeys = Object.keys(update).\n    map(key => Object.keys(update[key])).\n    reduce((cur, arr) => cur.concat(arr), []);\n  return arrayFilters.filter(obj => {\n    return _checkSingleFilterKey(obj, updateKeys);\n  });\n};\n\nfunction _checkSingleFilterKey(arrayFilter, updateKeys) {\n  const firstKey = Object.keys(arrayFilter)[0];\n\n  if (firstKey === '$and' || firstKey === '$or') {\n    if (!Array.isArray(arrayFilter[firstKey])) {\n      return false;\n    }\n    return arrayFilter[firstKey].find(filter => _checkSingleFilterKey(filter, updateKeys)) != null;\n  }\n\n  const firstDot = firstKey.indexOf('.');\n  const arrayFilterKey = firstDot === -1 ? firstKey : firstKey.slice(0, firstDot);\n\n  return updateKeys.find(key => key.includes('$[' + arrayFilterKey + ']')) != null;\n}\n"],"names":[],"mappings":"AAEA;;;;CAIC,GAED,OAAO,OAAO,GAAG,SAAS,yBAAyB,MAAM,EAAE,YAAY;IACrE,MAAM,aAAa,OAAO,IAAI,CAAC,QAC7B,GAAG,CAAC,CAAA,MAAO,OAAO,IAAI,CAAC,MAAM,CAAC,IAAI,GAClC,MAAM,CAAC,CAAC,KAAK,MAAQ,IAAI,MAAM,CAAC,MAAM,EAAE;IAC1C,OAAO,aAAa,MAAM,CAAC,CAAA;QACzB,OAAO,sBAAsB,KAAK;IACpC;AACF;AAEA,SAAS,sBAAsB,WAAW,EAAE,UAAU;IACpD,MAAM,WAAW,OAAO,IAAI,CAAC,YAAY,CAAC,EAAE;IAE5C,IAAI,aAAa,UAAU,aAAa,OAAO;QAC7C,IAAI,CAAC,MAAM,OAAO,CAAC,WAAW,CAAC,SAAS,GAAG;YACzC,OAAO;QACT;QACA,OAAO,WAAW,CAAC,SAAS,CAAC,IAAI,CAAC,CAAA,SAAU,sBAAsB,QAAQ,gBAAgB;IAC5F;IAEA,MAAM,WAAW,SAAS,OAAO,CAAC;IAClC,MAAM,iBAAiB,aAAa,CAAC,IAAI,WAAW,SAAS,KAAK,CAAC,GAAG;IAEtE,OAAO,WAAW,IAAI,CAAC,CAAA,MAAO,IAAI,QAAQ,CAAC,OAAO,iBAAiB,SAAS;AAC9E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5233, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/hasDollarKeys.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function hasDollarKeys(obj) {\n\n  if (typeof obj !== 'object' || obj === null) {\n    return false;\n  }\n\n  const keys = Object.keys(obj);\n  const len = keys.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (keys[i][0] === '$') {\n      return true;\n    }\n  }\n\n  return false;\n};\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,cAAc,GAAG;IAEzC,IAAI,OAAO,QAAQ,YAAY,QAAQ,MAAM;QAC3C,OAAO;IACT;IAEA,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,MAAM,MAAM,KAAK,MAAM;IAEvB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE,EAAG;QAC5B,IAAI,IAAI,CAAC,EAAE,CAAC,EAAE,KAAK,KAAK;YACtB,OAAO;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5252, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/sanitizeFilter.js"],"sourcesContent":["'use strict';\n\nconst hasDollarKeys = require('./hasDollarKeys');\nconst { trustedSymbol } = require('./trusted');\n\nmodule.exports = function sanitizeFilter(filter) {\n  if (filter == null || typeof filter !== 'object') {\n    return filter;\n  }\n  if (Array.isArray(filter)) {\n    for (const subfilter of filter) {\n      sanitizeFilter(subfilter);\n    }\n    return filter;\n  }\n\n  const filterKeys = Object.keys(filter);\n  for (const key of filterKeys) {\n    const value = filter[key];\n    if (value != null && value[trustedSymbol]) {\n      continue;\n    }\n    if (key === '$and' || key === '$or') {\n      sanitizeFilter(value);\n      continue;\n    }\n\n    if (hasDollarKeys(value)) {\n      const keys = Object.keys(value);\n      if (keys.length === 1 && keys[0] === '$eq') {\n        continue;\n      }\n      filter[key] = { $eq: filter[key] };\n    }\n  }\n\n  return filter;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM,EAAE,aAAa,EAAE;AAEvB,OAAO,OAAO,GAAG,SAAS,eAAe,MAAM;IAC7C,IAAI,UAAU,QAAQ,OAAO,WAAW,UAAU;QAChD,OAAO;IACT;IACA,IAAI,MAAM,OAAO,CAAC,SAAS;QACzB,KAAK,MAAM,aAAa,OAAQ;YAC9B,eAAe;QACjB;QACA,OAAO;IACT;IAEA,MAAM,aAAa,OAAO,IAAI,CAAC;IAC/B,KAAK,MAAM,OAAO,WAAY;QAC5B,MAAM,QAAQ,MAAM,CAAC,IAAI;QACzB,IAAI,SAAS,QAAQ,KAAK,CAAC,cAAc,EAAE;YACzC;QACF;QACA,IAAI,QAAQ,UAAU,QAAQ,OAAO;YACnC,eAAe;YACf;QACF;QAEA,IAAI,cAAc,QAAQ;YACxB,MAAM,OAAO,OAAO,IAAI,CAAC;YACzB,IAAI,KAAK,MAAM,KAAK,KAAK,IAAI,CAAC,EAAE,KAAK,OAAO;gBAC1C;YACF;YACA,MAAM,CAAC,IAAI,GAAG;gBAAE,KAAK,MAAM,CAAC,IAAI;YAAC;QACnC;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5290, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/sanitizeProjection.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function sanitizeProjection(projection) {\n  if (projection == null) {\n    return;\n  }\n\n  const keys = Object.keys(projection);\n  for (let i = 0; i < keys.length; ++i) {\n    if (typeof projection[keys[i]] === 'string') {\n      projection[keys[i]] = 1;\n    }\n  }\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,mBAAmB,UAAU;IACrD,IAAI,cAAc,MAAM;QACtB;IACF;IAEA,MAAM,OAAO,OAAO,IAAI,CAAC;IACzB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,MAAM,EAAE,EAAE,EAAG;QACpC,IAAI,OAAO,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,UAAU;YAC3C,UAAU,CAAC,IAAI,CAAC,EAAE,CAAC,GAAG;QACxB;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5305, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/query/selectPopulatedFields.js"],"sourcesContent":["'use strict';\n\nconst isExclusive = require('../projection/isExclusive');\nconst isInclusive = require('../projection/isInclusive');\n\n/*!\n * ignore\n */\n\nmodule.exports = function selectPopulatedFields(fields, userProvidedFields, populateOptions) {\n  if (populateOptions == null) {\n    return;\n  }\n\n  const paths = Object.keys(populateOptions);\n  userProvidedFields = userProvidedFields || {};\n  if (isInclusive(fields)) {\n    for (const path of paths) {\n      if (!isPathInFields(userProvidedFields, path)) {\n        fields[path] = 1;\n      } else if (userProvidedFields[path] === 0) {\n        delete fields[path];\n      }\n\n      const refPath = populateOptions[path]?.refPath;\n      if (typeof refPath === 'string') {\n        if (!isPathInFields(userProvidedFields, refPath)) {\n          fields[refPath] = 1;\n        } else if (userProvidedFields[refPath] === 0) {\n          delete fields[refPath];\n        }\n      }\n    }\n  } else if (isExclusive(fields)) {\n    for (const path of paths) {\n      if (userProvidedFields[path] == null) {\n        delete fields[path];\n      }\n      const refPath = populateOptions[path]?.refPath;\n      if (typeof refPath === 'string' && userProvidedFields[refPath] == null) {\n        delete fields[refPath];\n      }\n    }\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction isPathInFields(userProvidedFields, path) {\n  const pieces = path.split('.');\n  const len = pieces.length;\n  let cur = pieces[0];\n  for (let i = 1; i < len; ++i) {\n    if (userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null) {\n      return true;\n    }\n    cur += '.' + pieces[i];\n  }\n  return userProvidedFields[cur] != null || userProvidedFields[cur + '.$'] != null;\n}\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,sBAAsB,MAAM,EAAE,kBAAkB,EAAE,eAAe;IACzF,IAAI,mBAAmB,MAAM;QAC3B;IACF;IAEA,MAAM,QAAQ,OAAO,IAAI,CAAC;IAC1B,qBAAqB,sBAAsB,CAAC;IAC5C,IAAI,YAAY,SAAS;QACvB,KAAK,MAAM,QAAQ,MAAO;YACxB,IAAI,CAAC,eAAe,oBAAoB,OAAO;gBAC7C,MAAM,CAAC,KAAK,GAAG;YACjB,OAAO,IAAI,kBAAkB,CAAC,KAAK,KAAK,GAAG;gBACzC,OAAO,MAAM,CAAC,KAAK;YACrB;YAEA,MAAM,UAAU,eAAe,CAAC,KAAK,EAAE;YACvC,IAAI,OAAO,YAAY,UAAU;gBAC/B,IAAI,CAAC,eAAe,oBAAoB,UAAU;oBAChD,MAAM,CAAC,QAAQ,GAAG;gBACpB,OAAO,IAAI,kBAAkB,CAAC,QAAQ,KAAK,GAAG;oBAC5C,OAAO,MAAM,CAAC,QAAQ;gBACxB;YACF;QACF;IACF,OAAO,IAAI,YAAY,SAAS;QAC9B,KAAK,MAAM,QAAQ,MAAO;YACxB,IAAI,kBAAkB,CAAC,KAAK,IAAI,MAAM;gBACpC,OAAO,MAAM,CAAC,KAAK;YACrB;YACA,MAAM,UAAU,eAAe,CAAC,KAAK,EAAE;YACvC,IAAI,OAAO,YAAY,YAAY,kBAAkB,CAAC,QAAQ,IAAI,MAAM;gBACtE,OAAO,MAAM,CAAC,QAAQ;YACxB;QACF;IACF;AACF;AAEA;;CAEC,GAED,SAAS,eAAe,kBAAkB,EAAE,IAAI;IAC9C,MAAM,SAAS,KAAK,KAAK,CAAC;IAC1B,MAAM,MAAM,OAAO,MAAM;IACzB,IAAI,MAAM,MAAM,CAAC,EAAE;IACnB,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE,EAAG;QAC5B,IAAI,kBAAkB,CAAC,IAAI,IAAI,QAAQ,kBAAkB,CAAC,MAAM,KAAK,IAAI,MAAM;YAC7E,OAAO;QACT;QACA,OAAO,MAAM,MAAM,CAAC,EAAE;IACxB;IACA,OAAO,kBAAkB,CAAC,IAAI,IAAI,QAAQ,kBAAkB,CAAC,MAAM,KAAK,IAAI;AAC9E","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5361, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/updateValidators.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst ValidationError = require('../error/validation');\nconst cleanPositionalOperators = require('./schema/cleanPositionalOperators');\nconst flatten = require('./common').flatten;\n\n/**\n * Applies validators and defaults to update and findOneAndUpdate operations,\n * specifically passing a null doc as `this` to validators and defaults\n *\n * @param {Query} query\n * @param {Schema} schema\n * @param {Object} castedDoc\n * @param {Object} options\n * @method runValidatorsOnUpdate\n * @api private\n */\n\nmodule.exports = function(query, schema, castedDoc, options, callback) {\n  const keys = Object.keys(castedDoc || {});\n  let updatedKeys = {};\n  let updatedValues = {};\n  const isPull = {};\n  const arrayAtomicUpdates = {};\n  const numKeys = keys.length;\n  let hasDollarUpdate = false;\n  let currentUpdate;\n  let key;\n  let i;\n\n  for (i = 0; i < numKeys; ++i) {\n    if (keys[i].startsWith('$')) {\n      hasDollarUpdate = true;\n      if (keys[i] === '$push' || keys[i] === '$addToSet') {\n        const _keys = Object.keys(castedDoc[keys[i]]);\n        for (let ii = 0; ii < _keys.length; ++ii) {\n          currentUpdate = castedDoc[keys[i]][_keys[ii]];\n          if (currentUpdate && currentUpdate.$each) {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat(currentUpdate.$each);\n          } else {\n            arrayAtomicUpdates[_keys[ii]] = (arrayAtomicUpdates[_keys[ii]] || []).\n              concat([currentUpdate]);\n          }\n        }\n        continue;\n      }\n      const flat = flatten(castedDoc[keys[i]], null, null, schema);\n      const paths = Object.keys(flat);\n      const numPaths = paths.length;\n      for (let j = 0; j < numPaths; ++j) {\n        const updatedPath = cleanPositionalOperators(paths[j]);\n        key = keys[i];\n        // With `$pull` we might flatten `$in`. Skip stuff nested under `$in`\n        // for the rest of the logic, it will get handled later.\n        if (updatedPath.includes('$')) {\n          continue;\n        }\n        if (key === '$set' || key === '$setOnInsert' ||\n            key === '$pull' || key === '$pullAll') {\n          updatedValues[updatedPath] = flat[paths[j]];\n          isPull[updatedPath] = key === '$pull' || key === '$pullAll';\n        } else if (key === '$unset') {\n          updatedValues[updatedPath] = undefined;\n        }\n        updatedKeys[updatedPath] = true;\n      }\n    }\n  }\n\n  if (!hasDollarUpdate) {\n    updatedValues = flatten(castedDoc, null, null, schema);\n    updatedKeys = Object.keys(updatedValues);\n  }\n\n  const updates = Object.keys(updatedValues);\n  const numUpdates = updates.length;\n  const validatorsToExecute = [];\n  const validationErrors = [];\n\n  const alreadyValidated = [];\n\n  const context = query;\n  function iter(i, v) {\n    const schemaPath = schema._getSchema(updates[i]);\n    if (schemaPath == null) {\n      return;\n    }\n    if (schemaPath.instance === 'Mixed' && schemaPath.path !== updates[i]) {\n      return;\n    }\n\n    if (v && Array.isArray(v.$in)) {\n      v.$in.forEach((v, i) => {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            v,\n            function(err) {\n              if (err) {\n                err.path = updates[i] + '.$in.' + i;\n                validationErrors.push(err);\n              }\n              callback(null);\n            },\n            context,\n            { updateValidator: true });\n        });\n      });\n    } else {\n      if (isPull[updates[i]] &&\n          schemaPath.$isMongooseArray) {\n        return;\n      }\n\n      if (schemaPath.$isMongooseDocumentArrayElement && v != null && v.$__ != null) {\n        alreadyValidated.push(updates[i]);\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(v, function(err) {\n            if (err) {\n              if (err.errors) {\n                for (const key of Object.keys(err.errors)) {\n                  const _err = err.errors[key];\n                  _err.path = updates[i] + '.' + key;\n                  validationErrors.push(_err);\n                }\n              } else {\n                err.path = updates[i];\n                validationErrors.push(err);\n              }\n            }\n\n            return callback(null);\n          }, context, { updateValidator: true });\n        });\n      } else {\n        validatorsToExecute.push(function(callback) {\n          for (const path of alreadyValidated) {\n            if (updates[i].startsWith(path + '.')) {\n              return callback(null);\n            }\n          }\n          if (schemaPath.$isSingleNested) {\n            alreadyValidated.push(updates[i]);\n          }\n\n          schemaPath.doValidate(v, function(err) {\n            if (schemaPath.schema != null &&\n                schemaPath.schema.options.storeSubdocValidationError === false &&\n                err instanceof ValidationError) {\n              return callback(null);\n            }\n\n            if (err) {\n              err.path = updates[i];\n              validationErrors.push(err);\n            }\n            callback(null);\n          }, context, { updateValidator: true });\n        });\n      }\n    }\n  }\n  for (i = 0; i < numUpdates; ++i) {\n    iter(i, updatedValues[updates[i]]);\n  }\n\n  const arrayUpdates = Object.keys(arrayAtomicUpdates);\n  for (const arrayUpdate of arrayUpdates) {\n    let schemaPath = schema._getSchema(arrayUpdate);\n    if (schemaPath && schemaPath.$isMongooseDocumentArray) {\n      validatorsToExecute.push(function(callback) {\n        schemaPath.doValidate(\n          arrayAtomicUpdates[arrayUpdate],\n          getValidationCallback(arrayUpdate, validationErrors, callback),\n          options && options.context === 'query' ? query : null);\n      });\n    } else {\n      schemaPath = schema._getSchema(arrayUpdate + '.0');\n      for (const atomicUpdate of arrayAtomicUpdates[arrayUpdate]) {\n        validatorsToExecute.push(function(callback) {\n          schemaPath.doValidate(\n            atomicUpdate,\n            getValidationCallback(arrayUpdate, validationErrors, callback),\n            options && options.context === 'query' ? query : null,\n            { updateValidator: true });\n        });\n      }\n    }\n  }\n\n  if (callback != null) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n\n    return;\n  }\n\n  return function(callback) {\n    let numValidators = validatorsToExecute.length;\n    if (numValidators === 0) {\n      return _done(callback);\n    }\n    for (const validator of validatorsToExecute) {\n      validator(function() {\n        if (--numValidators <= 0) {\n          _done(callback);\n        }\n      });\n    }\n  };\n\n  function _done(callback) {\n    if (validationErrors.length) {\n      const err = new ValidationError(null);\n\n      for (const validationError of validationErrors) {\n        err.addError(validationError.path, validationError);\n      }\n\n      return callback(err);\n    }\n    callback(null);\n  }\n\n  function getValidationCallback(arrayUpdate, validationErrors, callback) {\n    return function(err) {\n      if (err) {\n        err.path = arrayUpdate;\n        validationErrors.push(err);\n      }\n      callback(null);\n    };\n  }\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5582, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/aggregate/prepareDiscriminatorPipeline.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function prepareDiscriminatorPipeline(pipeline, schema, prefix) {\n  const discriminatorMapping = schema && schema.discriminatorMapping;\n  prefix = prefix || '';\n\n  if (discriminatorMapping && !discriminatorMapping.isRoot) {\n    const originalPipeline = pipeline;\n    const filterKey = (prefix.length > 0 ? prefix + '.' : prefix) + discriminatorMapping.key;\n    const discriminatorValue = discriminatorMapping.value;\n\n    // If the first pipeline stage is a match and it doesn't specify a `__t`\n    // key, add the discriminator key to it. This allows for potential\n    // aggregation query optimizations not to be disturbed by this feature.\n    if (originalPipeline[0] != null &&\n        originalPipeline[0].$match &&\n        (originalPipeline[0].$match[filterKey] === undefined || originalPipeline[0].$match[filterKey] === discriminatorValue)) {\n      originalPipeline[0].$match[filterKey] = discriminatorValue;\n      // `originalPipeline` is a ref, so there's no need for\n      // aggregate._pipeline = originalPipeline\n    } else if (originalPipeline[0] != null && originalPipeline[0].$geoNear) {\n      originalPipeline[0].$geoNear.query =\n          originalPipeline[0].$geoNear.query || {};\n      originalPipeline[0].$geoNear.query[filterKey] = discriminatorValue;\n    } else if (originalPipeline[0] != null && originalPipeline[0].$search) {\n      if (originalPipeline[1] && originalPipeline[1].$match != null) {\n        originalPipeline[1].$match[filterKey] = originalPipeline[1].$match[filterKey] || discriminatorValue;\n      } else {\n        const match = {};\n        match[filterKey] = discriminatorValue;\n        originalPipeline.splice(1, 0, { $match: match });\n      }\n    } else {\n      const match = {};\n      match[filterKey] = discriminatorValue;\n      originalPipeline.unshift({ $match: match });\n    }\n  }\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,6BAA6B,QAAQ,EAAE,MAAM,EAAE,MAAM;IAC7E,MAAM,uBAAuB,UAAU,OAAO,oBAAoB;IAClE,SAAS,UAAU;IAEnB,IAAI,wBAAwB,CAAC,qBAAqB,MAAM,EAAE;QACxD,MAAM,mBAAmB;QACzB,MAAM,YAAY,CAAC,OAAO,MAAM,GAAG,IAAI,SAAS,MAAM,MAAM,IAAI,qBAAqB,GAAG;QACxF,MAAM,qBAAqB,qBAAqB,KAAK;QAErD,wEAAwE;QACxE,kEAAkE;QAClE,uEAAuE;QACvE,IAAI,gBAAgB,CAAC,EAAE,IAAI,QACvB,gBAAgB,CAAC,EAAE,CAAC,MAAM,IAC1B,CAAC,gBAAgB,CAAC,EAAE,CAAC,MAAM,CAAC,UAAU,KAAK,aAAa,gBAAgB,CAAC,EAAE,CAAC,MAAM,CAAC,UAAU,KAAK,kBAAkB,GAAG;YACzH,gBAAgB,CAAC,EAAE,CAAC,MAAM,CAAC,UAAU,GAAG;QACxC,sDAAsD;QACtD,yCAAyC;QAC3C,OAAO,IAAI,gBAAgB,CAAC,EAAE,IAAI,QAAQ,gBAAgB,CAAC,EAAE,CAAC,QAAQ,EAAE;YACtE,gBAAgB,CAAC,EAAE,CAAC,QAAQ,CAAC,KAAK,GAC9B,gBAAgB,CAAC,EAAE,CAAC,QAAQ,CAAC,KAAK,IAAI,CAAC;YAC3C,gBAAgB,CAAC,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,UAAU,GAAG;QAClD,OAAO,IAAI,gBAAgB,CAAC,EAAE,IAAI,QAAQ,gBAAgB,CAAC,EAAE,CAAC,OAAO,EAAE;YACrE,IAAI,gBAAgB,CAAC,EAAE,IAAI,gBAAgB,CAAC,EAAE,CAAC,MAAM,IAAI,MAAM;gBAC7D,gBAAgB,CAAC,EAAE,CAAC,MAAM,CAAC,UAAU,GAAG,gBAAgB,CAAC,EAAE,CAAC,MAAM,CAAC,UAAU,IAAI;YACnF,OAAO;gBACL,MAAM,QAAQ,CAAC;gBACf,KAAK,CAAC,UAAU,GAAG;gBACnB,iBAAiB,MAAM,CAAC,GAAG,GAAG;oBAAE,QAAQ;gBAAM;YAChD;QACF,OAAO;YACL,MAAM,QAAQ,CAAC;YACf,KAAK,CAAC,UAAU,GAAG;YACnB,iBAAiB,OAAO,CAAC;gBAAE,QAAQ;YAAM;QAC3C;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5622, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/aggregate/stringifyFunctionOperators.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function stringifyFunctionOperators(pipeline) {\n  if (!Array.isArray(pipeline)) {\n    return;\n  }\n\n  for (const stage of pipeline) {\n    if (stage == null) {\n      continue;\n    }\n\n    const canHaveAccumulator = stage.$group || stage.$bucket || stage.$bucketAuto;\n    if (canHaveAccumulator != null) {\n      for (const key of Object.keys(canHaveAccumulator)) {\n        handleAccumulator(canHaveAccumulator[key]);\n      }\n    }\n\n    const stageType = Object.keys(stage)[0];\n    if (stageType && typeof stage[stageType] === 'object') {\n      const stageOptions = stage[stageType];\n      for (const key of Object.keys(stageOptions)) {\n        if (stageOptions[key] != null &&\n            stageOptions[key].$function != null &&\n            typeof stageOptions[key].$function.body === 'function') {\n          stageOptions[key].$function.body = stageOptions[key].$function.body.toString();\n        }\n      }\n    }\n\n    if (stage.$facet != null) {\n      for (const key of Object.keys(stage.$facet)) {\n        stringifyFunctionOperators(stage.$facet[key]);\n      }\n    }\n  }\n};\n\nfunction handleAccumulator(operator) {\n  if (operator == null || operator.$accumulator == null) {\n    return;\n  }\n\n  for (const key of ['init', 'accumulate', 'merge', 'finalize']) {\n    if (typeof operator.$accumulator[key] === 'function') {\n      operator.$accumulator[key] = String(operator.$accumulator[key]);\n    }\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,2BAA2B,QAAQ;IAC3D,IAAI,CAAC,MAAM,OAAO,CAAC,WAAW;QAC5B;IACF;IAEA,KAAK,MAAM,SAAS,SAAU;QAC5B,IAAI,SAAS,MAAM;YACjB;QACF;QAEA,MAAM,qBAAqB,MAAM,MAAM,IAAI,MAAM,OAAO,IAAI,MAAM,WAAW;QAC7E,IAAI,sBAAsB,MAAM;YAC9B,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,oBAAqB;gBACjD,kBAAkB,kBAAkB,CAAC,IAAI;YAC3C;QACF;QAEA,MAAM,YAAY,OAAO,IAAI,CAAC,MAAM,CAAC,EAAE;QACvC,IAAI,aAAa,OAAO,KAAK,CAAC,UAAU,KAAK,UAAU;YACrD,MAAM,eAAe,KAAK,CAAC,UAAU;YACrC,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,cAAe;gBAC3C,IAAI,YAAY,CAAC,IAAI,IAAI,QACrB,YAAY,CAAC,IAAI,CAAC,SAAS,IAAI,QAC/B,OAAO,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,KAAK,YAAY;oBAC1D,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,QAAQ;gBAC9E;YACF;QACF;QAEA,IAAI,MAAM,MAAM,IAAI,MAAM;YACxB,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,MAAM,MAAM,EAAG;gBAC3C,2BAA2B,MAAM,MAAM,CAAC,IAAI;YAC9C;QACF;IACF;AACF;AAEA,SAAS,kBAAkB,QAAQ;IACjC,IAAI,YAAY,QAAQ,SAAS,YAAY,IAAI,MAAM;QACrD;IACF;IAEA,KAAK,MAAM,OAAO;QAAC;QAAQ;QAAc;QAAS;KAAW,CAAE;QAC7D,IAAI,OAAO,SAAS,YAAY,CAAC,IAAI,KAAK,YAAY;YACpD,SAAS,YAAY,CAAC,IAAI,GAAG,OAAO,SAAS,YAAY,CAAC,IAAI;QAChE;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5671, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/model/applyDefaultsToPOJO.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function applyDefaultsToPOJO(doc, schema) {\n  const paths = Object.keys(schema.paths);\n  const plen = paths.length;\n\n  for (let i = 0; i < plen; ++i) {\n    let curPath = '';\n    const p = paths[i];\n\n    const type = schema.paths[p];\n    const path = type.splitPath();\n    const len = path.length;\n    let doc_ = doc;\n    for (let j = 0; j < len; ++j) {\n      if (doc_ == null) {\n        break;\n      }\n\n      const piece = path[j];\n      curPath += (!curPath.length ? '' : '.') + piece;\n\n      if (j === len - 1) {\n        if (typeof doc_[piece] !== 'undefined') {\n          if (type.$isSingleNested) {\n            applyDefaultsToPOJO(doc_[piece], type.caster.schema);\n          } else if (type.$isMongooseDocumentArray && Array.isArray(doc_[piece])) {\n            doc_[piece].forEach(el => applyDefaultsToPOJO(el, type.schema));\n          }\n\n          break;\n        }\n\n        const def = type.getDefault(doc, false, { skipCast: true });\n        if (typeof def !== 'undefined') {\n          doc_[piece] = def;\n\n          if (type.$isSingleNested) {\n            applyDefaultsToPOJO(def, type.caster.schema);\n          } else if (type.$isMongooseDocumentArray && Array.isArray(def)) {\n            def.forEach(el => applyDefaultsToPOJO(el, type.schema));\n          }\n        }\n      } else {\n        if (doc_[piece] == null) {\n          doc_[piece] = {};\n        }\n        doc_ = doc_[piece];\n      }\n    }\n  }\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,oBAAoB,GAAG,EAAE,MAAM;IACvD,MAAM,QAAQ,OAAO,IAAI,CAAC,OAAO,KAAK;IACtC,MAAM,OAAO,MAAM,MAAM;IAEzB,IAAK,IAAI,IAAI,GAAG,IAAI,MAAM,EAAE,EAAG;QAC7B,IAAI,UAAU;QACd,MAAM,IAAI,KAAK,CAAC,EAAE;QAElB,MAAM,OAAO,OAAO,KAAK,CAAC,EAAE;QAC5B,MAAM,OAAO,KAAK,SAAS;QAC3B,MAAM,MAAM,KAAK,MAAM;QACvB,IAAI,OAAO;QACX,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,EAAE,EAAG;YAC5B,IAAI,QAAQ,MAAM;gBAChB;YACF;YAEA,MAAM,QAAQ,IAAI,CAAC,EAAE;YACrB,WAAW,CAAC,CAAC,QAAQ,MAAM,GAAG,KAAK,GAAG,IAAI;YAE1C,IAAI,MAAM,MAAM,GAAG;gBACjB,IAAI,OAAO,IAAI,CAAC,MAAM,KAAK,aAAa;oBACtC,IAAI,KAAK,eAAe,EAAE;wBACxB,oBAAoB,IAAI,CAAC,MAAM,EAAE,KAAK,MAAM,CAAC,MAAM;oBACrD,OAAO,IAAI,KAAK,wBAAwB,IAAI,MAAM,OAAO,CAAC,IAAI,CAAC,MAAM,GAAG;wBACtE,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA,KAAM,oBAAoB,IAAI,KAAK,MAAM;oBAC/D;oBAEA;gBACF;gBAEA,MAAM,MAAM,KAAK,UAAU,CAAC,KAAK,OAAO;oBAAE,UAAU;gBAAK;gBACzD,IAAI,OAAO,QAAQ,aAAa;oBAC9B,IAAI,CAAC,MAAM,GAAG;oBAEd,IAAI,KAAK,eAAe,EAAE;wBACxB,oBAAoB,KAAK,KAAK,MAAM,CAAC,MAAM;oBAC7C,OAAO,IAAI,KAAK,wBAAwB,IAAI,MAAM,OAAO,CAAC,MAAM;wBAC9D,IAAI,OAAO,CAAC,CAAA,KAAM,oBAAoB,IAAI,KAAK,MAAM;oBACvD;gBACF;YACF,OAAO;gBACL,IAAI,IAAI,CAAC,MAAM,IAAI,MAAM;oBACvB,IAAI,CAAC,MAAM,GAAG,CAAC;gBACjB;gBACA,OAAO,IAAI,CAAC,MAAM;YACpB;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5720, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/discriminator/applyEmbeddedDiscriminators.js"],"sourcesContent":["'use strict';\n\nmodule.exports = applyEmbeddedDiscriminators;\n\nfunction applyEmbeddedDiscriminators(schema, seen = new WeakSet(), overwriteExisting = false) {\n  if (seen.has(schema)) {\n    return;\n  }\n  seen.add(schema);\n  for (const path of Object.keys(schema.paths)) {\n    const schemaType = schema.paths[path];\n    if (!schemaType.schema) {\n      continue;\n    }\n    applyEmbeddedDiscriminators(schemaType.schema, seen);\n    if (!schemaType.schema._applyDiscriminators) {\n      continue;\n    }\n    if (schemaType._appliedDiscriminators && !overwriteExisting) {\n      continue;\n    }\n    for (const discriminatorKey of schemaType.schema._applyDiscriminators.keys()) {\n      const {\n        schema: discriminatorSchema,\n        options\n      } = schemaType.schema._applyDiscriminators.get(discriminatorKey);\n      applyEmbeddedDiscriminators(discriminatorSchema, seen);\n      schemaType.discriminator(\n        discriminatorKey,\n        discriminatorSchema,\n        overwriteExisting ? { ...options, overwriteExisting: true } : options\n      );\n    }\n    schemaType._appliedDiscriminators = true;\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG;AAEjB,SAAS,4BAA4B,MAAM,EAAE,OAAO,IAAI,SAAS,EAAE,oBAAoB,KAAK;IAC1F,IAAI,KAAK,GAAG,CAAC,SAAS;QACpB;IACF;IACA,KAAK,GAAG,CAAC;IACT,KAAK,MAAM,QAAQ,OAAO,IAAI,CAAC,OAAO,KAAK,EAAG;QAC5C,MAAM,aAAa,OAAO,KAAK,CAAC,KAAK;QACrC,IAAI,CAAC,WAAW,MAAM,EAAE;YACtB;QACF;QACA,4BAA4B,WAAW,MAAM,EAAE;QAC/C,IAAI,CAAC,WAAW,MAAM,CAAC,oBAAoB,EAAE;YAC3C;QACF;QACA,IAAI,WAAW,sBAAsB,IAAI,CAAC,mBAAmB;YAC3D;QACF;QACA,KAAK,MAAM,oBAAoB,WAAW,MAAM,CAAC,oBAAoB,CAAC,IAAI,GAAI;YAC5E,MAAM,EACJ,QAAQ,mBAAmB,EAC3B,OAAO,EACR,GAAG,WAAW,MAAM,CAAC,oBAAoB,CAAC,GAAG,CAAC;YAC/C,4BAA4B,qBAAqB;YACjD,WAAW,aAAa,CACtB,kBACA,qBACA,oBAAoB;gBAAE,GAAG,OAAO;gBAAE,mBAAmB;YAAK,IAAI;QAElE;QACA,WAAW,sBAAsB,GAAG;IACtC;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5753, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/model/applyMethods.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\nconst utils = require('../../utils');\n\n/**\n * Register methods for this model\n *\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\n\nmodule.exports = function applyMethods(model, schema) {\n  const Model = require('../../model');\n\n  function apply(method, schema) {\n    Object.defineProperty(model.prototype, method, {\n      get: function() {\n        const h = {};\n        for (const k in schema.methods[method]) {\n          h[k] = schema.methods[method][k].bind(this);\n        }\n        return h;\n      },\n      configurable: true\n    });\n  }\n  for (const method of Object.keys(schema.methods)) {\n    const fn = schema.methods[method];\n    if (schema.tree.hasOwnProperty(method)) {\n      throw new Error('You have a method and a property in your schema both ' +\n        'named \"' + method + '\"');\n    }\n\n    // Avoid making custom methods if user sets a method to itself, e.g.\n    // `schema.method(save, Document.prototype.save)`. Can happen when\n    // calling `loadClass()` with a class that `extends Document`. See gh-12254\n    if (typeof fn === 'function' &&\n        Model.prototype[method] === fn) {\n      delete schema.methods[method];\n      continue;\n    }\n\n    if (schema.reserved[method] &&\n        !get(schema, `methodOptions.${method}.suppressWarning`, false)) {\n      utils.warn(`mongoose: the method name \"${method}\" is used by mongoose ` +\n        'internally, overwriting it may cause bugs. If you\\'re sure you know ' +\n        'what you\\'re doing, you can suppress this error by using ' +\n        `\\`schema.method('${method}', fn, { suppressWarning: true })\\`.`);\n    }\n    if (typeof fn === 'function') {\n      model.prototype[method] = fn;\n    } else {\n      apply(method, schema);\n    }\n  }\n\n  // Recursively call `applyMethods()` on child schemas\n  model.$appliedMethods = true;\n  for (const key of Object.keys(schema.paths)) {\n    const type = schema.paths[key];\n    if (type.$isSingleNested && !type.caster.$appliedMethods) {\n      applyMethods(type.caster, type.schema);\n    }\n    if (type.$isMongooseDocumentArray && !type.Constructor.$appliedMethods) {\n      applyMethods(type.Constructor, type.schema);\n    }\n  }\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN;;;;;;CAMC,GAED,OAAO,OAAO,GAAG,SAAS,aAAa,KAAK,EAAE,MAAM;IAClD,MAAM;IAEN,SAAS,MAAM,MAAM,EAAE,MAAM;QAC3B,OAAO,cAAc,CAAC,MAAM,SAAS,EAAE,QAAQ;YAC7C,KAAK;gBACH,MAAM,IAAI,CAAC;gBACX,IAAK,MAAM,KAAK,OAAO,OAAO,CAAC,OAAO,CAAE;oBACtC,CAAC,CAAC,EAAE,GAAG,OAAO,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI;gBAC5C;gBACA,OAAO;YACT;YACA,cAAc;QAChB;IACF;IACA,KAAK,MAAM,UAAU,OAAO,IAAI,CAAC,OAAO,OAAO,EAAG;QAChD,MAAM,KAAK,OAAO,OAAO,CAAC,OAAO;QACjC,IAAI,OAAO,IAAI,CAAC,cAAc,CAAC,SAAS;YACtC,MAAM,IAAI,MAAM,0DACd,YAAY,SAAS;QACzB;QAEA,oEAAoE;QACpE,kEAAkE;QAClE,2EAA2E;QAC3E,IAAI,OAAO,OAAO,cACd,MAAM,SAAS,CAAC,OAAO,KAAK,IAAI;YAClC,OAAO,OAAO,OAAO,CAAC,OAAO;YAC7B;QACF;QAEA,IAAI,OAAO,QAAQ,CAAC,OAAO,IACvB,CAAC,IAAI,QAAQ,CAAC,cAAc,EAAE,OAAO,gBAAgB,CAAC,EAAE,QAAQ;YAClE,MAAM,IAAI,CAAC,CAAC,2BAA2B,EAAE,OAAO,sBAAsB,CAAC,GACrE,yEACA,8DACA,CAAC,iBAAiB,EAAE,OAAO,oCAAoC,CAAC;QACpE;QACA,IAAI,OAAO,OAAO,YAAY;YAC5B,MAAM,SAAS,CAAC,OAAO,GAAG;QAC5B,OAAO;YACL,MAAM,QAAQ;QAChB;IACF;IAEA,qDAAqD;IACrD,MAAM,eAAe,GAAG;IACxB,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,OAAO,KAAK,EAAG;QAC3C,MAAM,OAAO,OAAO,KAAK,CAAC,IAAI;QAC9B,IAAI,KAAK,eAAe,IAAI,CAAC,KAAK,MAAM,CAAC,eAAe,EAAE;YACxD,aAAa,KAAK,MAAM,EAAE,KAAK,MAAM;QACvC;QACA,IAAI,KAAK,wBAAwB,IAAI,CAAC,KAAK,WAAW,CAAC,eAAe,EAAE;YACtE,aAAa,KAAK,WAAW,EAAE,KAAK,MAAM;QAC5C;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5812, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/projection/applyProjection.js"],"sourcesContent":["'use strict';\n\nconst hasIncludedChildren = require('./hasIncludedChildren');\nconst isExclusive = require('./isExclusive');\nconst isInclusive = require('./isInclusive');\nconst isPOJO = require('../../utils').isPOJO;\n\nmodule.exports = function applyProjection(doc, projection, _hasIncludedChildren) {\n  if (projection == null) {\n    return doc;\n  }\n  if (doc == null) {\n    return doc;\n  }\n\n  let exclude = null;\n  if (isInclusive(projection)) {\n    exclude = false;\n  } else if (isExclusive(projection)) {\n    exclude = true;\n  }\n\n  if (exclude == null) {\n    return doc;\n  } else if (exclude) {\n    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);\n    return applyExclusiveProjection(doc, projection, _hasIncludedChildren);\n  } else {\n    _hasIncludedChildren = _hasIncludedChildren || hasIncludedChildren(projection);\n    return applyInclusiveProjection(doc, projection, _hasIncludedChildren);\n  }\n};\n\nfunction applyExclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {\n  if (doc == null || typeof doc !== 'object') {\n    return doc;\n  }\n  if (Array.isArray(doc)) {\n    return doc.map(el => applyExclusiveProjection(el, projection, hasIncludedChildren, projectionLimb, prefix));\n  }\n  const ret = { ...doc };\n  projectionLimb = prefix ? (projectionLimb || {}) : projection;\n\n  for (const key of Object.keys(ret)) {\n    const fullPath = prefix ? prefix + '.' + key : key;\n    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {\n      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {\n        ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n      } else {\n        delete ret[key];\n      }\n    } else if (hasIncludedChildren[fullPath]) {\n      ret[key] = applyExclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n    }\n  }\n  return ret;\n}\n\nfunction applyInclusiveProjection(doc, projection, hasIncludedChildren, projectionLimb, prefix) {\n  if (doc == null || typeof doc !== 'object') {\n    return doc;\n  }\n  if (Array.isArray(doc)) {\n    return doc.map(el => applyInclusiveProjection(el, projection, hasIncludedChildren, projectionLimb, prefix));\n  }\n  const ret = { ...doc };\n  projectionLimb = prefix ? (projectionLimb || {}) : projection;\n\n  for (const key of Object.keys(ret)) {\n    const fullPath = prefix ? prefix + '.' + key : key;\n    if (projection.hasOwnProperty(fullPath) || projectionLimb.hasOwnProperty(key)) {\n      if (isPOJO(projection[fullPath]) || isPOJO(projectionLimb[key])) {\n        ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n      }\n      continue;\n    } else if (hasIncludedChildren[fullPath]) {\n      ret[key] = applyInclusiveProjection(ret[key], projection, hasIncludedChildren, projectionLimb[key], fullPath);\n    } else {\n      delete ret[key];\n    }\n  }\n  return ret;\n}\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM,SAAS,mGAAuB,MAAM;AAE5C,OAAO,OAAO,GAAG,SAAS,gBAAgB,GAAG,EAAE,UAAU,EAAE,oBAAoB;IAC7E,IAAI,cAAc,MAAM;QACtB,OAAO;IACT;IACA,IAAI,OAAO,MAAM;QACf,OAAO;IACT;IAEA,IAAI,UAAU;IACd,IAAI,YAAY,aAAa;QAC3B,UAAU;IACZ,OAAO,IAAI,YAAY,aAAa;QAClC,UAAU;IACZ;IAEA,IAAI,WAAW,MAAM;QACnB,OAAO;IACT,OAAO,IAAI,SAAS;QAClB,uBAAuB,wBAAwB,oBAAoB;QACnE,OAAO,yBAAyB,KAAK,YAAY;IACnD,OAAO;QACL,uBAAuB,wBAAwB,oBAAoB;QACnE,OAAO,yBAAyB,KAAK,YAAY;IACnD;AACF;AAEA,SAAS,yBAAyB,GAAG,EAAE,UAAU,EAAE,mBAAmB,EAAE,cAAc,EAAE,MAAM;IAC5F,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;QAC1C,OAAO;IACT;IACA,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,OAAO,IAAI,GAAG,CAAC,CAAA,KAAM,yBAAyB,IAAI,YAAY,qBAAqB,gBAAgB;IACrG;IACA,MAAM,MAAM;QAAE,GAAG,GAAG;IAAC;IACrB,iBAAiB,SAAU,kBAAkB,CAAC,IAAK;IAEnD,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,KAAM;QAClC,MAAM,WAAW,SAAS,SAAS,MAAM,MAAM;QAC/C,IAAI,WAAW,cAAc,CAAC,aAAa,eAAe,cAAc,CAAC,MAAM;YAC7E,IAAI,OAAO,UAAU,CAAC,SAAS,KAAK,OAAO,cAAc,CAAC,IAAI,GAAG;gBAC/D,GAAG,CAAC,IAAI,GAAG,yBAAyB,GAAG,CAAC,IAAI,EAAE,YAAY,qBAAqB,cAAc,CAAC,IAAI,EAAE;YACtG,OAAO;gBACL,OAAO,GAAG,CAAC,IAAI;YACjB;QACF,OAAO,IAAI,mBAAmB,CAAC,SAAS,EAAE;YACxC,GAAG,CAAC,IAAI,GAAG,yBAAyB,GAAG,CAAC,IAAI,EAAE,YAAY,qBAAqB,cAAc,CAAC,IAAI,EAAE;QACtG;IACF;IACA,OAAO;AACT;AAEA,SAAS,yBAAyB,GAAG,EAAE,UAAU,EAAE,mBAAmB,EAAE,cAAc,EAAE,MAAM;IAC5F,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;QAC1C,OAAO;IACT;IACA,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,OAAO,IAAI,GAAG,CAAC,CAAA,KAAM,yBAAyB,IAAI,YAAY,qBAAqB,gBAAgB;IACrG;IACA,MAAM,MAAM;QAAE,GAAG,GAAG;IAAC;IACrB,iBAAiB,SAAU,kBAAkB,CAAC,IAAK;IAEnD,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,KAAM;QAClC,MAAM,WAAW,SAAS,SAAS,MAAM,MAAM;QAC/C,IAAI,WAAW,cAAc,CAAC,aAAa,eAAe,cAAc,CAAC,MAAM;YAC7E,IAAI,OAAO,UAAU,CAAC,SAAS,KAAK,OAAO,cAAc,CAAC,IAAI,GAAG;gBAC/D,GAAG,CAAC,IAAI,GAAG,yBAAyB,GAAG,CAAC,IAAI,EAAE,YAAY,qBAAqB,cAAc,CAAC,IAAI,EAAE;YACtG;YACA;QACF,OAAO,IAAI,mBAAmB,CAAC,SAAS,EAAE;YACxC,GAAG,CAAC,IAAI,GAAG,yBAAyB,GAAG,CAAC,IAAI,EAAE,YAAY,qBAAqB,cAAc,CAAC,IAAI,EAAE;QACtG,OAAO;YACL,OAAO,GAAG,CAAC,IAAI;QACjB;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5894, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/indexes/isTextIndex.js"],"sourcesContent":["'use strict';\n\n/**\n * Returns `true` if the given index options have a `text` option.\n */\n\nmodule.exports = function isTextIndex(indexKeys) {\n  let isTextIndex = false;\n  for (const key of Object.keys(indexKeys)) {\n    if (indexKeys[key] === 'text') {\n      isTextIndex = true;\n    }\n  }\n\n  return isTextIndex;\n};\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,YAAY,SAAS;IAC7C,IAAI,cAAc;IAClB,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,WAAY;QACxC,IAAI,SAAS,CAAC,IAAI,KAAK,QAAQ;YAC7B,cAAc;QAChB;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5909, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/indexes/applySchemaCollation.js"],"sourcesContent":["'use strict';\n\nconst isTextIndex = require('./isTextIndex');\n\nmodule.exports = function applySchemaCollation(indexKeys, indexOptions, schemaOptions) {\n  if (isTextIndex(indexKeys)) {\n    return;\n  }\n\n  if (schemaOptions.hasOwnProperty('collation') && !indexOptions.hasOwnProperty('collation')) {\n    indexOptions.collation = schemaOptions.collation;\n  }\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,qBAAqB,SAAS,EAAE,YAAY,EAAE,aAAa;IACnF,IAAI,YAAY,YAAY;QAC1B;IACF;IAEA,IAAI,cAAc,cAAc,CAAC,gBAAgB,CAAC,aAAa,cAAc,CAAC,cAAc;QAC1F,aAAa,SAAS,GAAG,cAAc,SAAS;IAClD;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5922, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/model/applyStaticHooks.js"],"sourcesContent":["'use strict';\n\nconst promiseOrCallback = require('../promiseOrCallback');\nconst { queryMiddlewareFunctions, aggregateMiddlewareFunctions, modelMiddlewareFunctions, documentMiddlewareFunctions } = require('../../constants');\n\nconst middlewareFunctions = Array.from(\n  new Set([\n    ...queryMiddlewareFunctions,\n    ...aggregateMiddlewareFunctions,\n    ...modelMiddlewareFunctions,\n    ...documentMiddlewareFunctions\n  ])\n);\n\nmodule.exports = function applyStaticHooks(model, hooks, statics) {\n  const kareemOptions = {\n    useErrorHandlers: true,\n    numCallbackParams: 1\n  };\n\n  model.$__insertMany = hooks.createWrapper('insertMany',\n    model.$__insertMany, model, kareemOptions);\n\n  hooks = hooks.filter(hook => {\n    // If the custom static overwrites an existing middleware, don't apply\n    // middleware to it by default. This avoids a potential backwards breaking\n    // change with plugins like `mongoose-delete` that use statics to overwrite\n    // built-in Mongoose functions.\n    if (middlewareFunctions.indexOf(hook.name) !== -1) {\n      return !!hook.model;\n    }\n    return hook.model !== false;\n  });\n\n  for (const key of Object.keys(statics)) {\n    if (hooks.hasHooks(key)) {\n      const original = model[key];\n\n      model[key] = function() {\n        const numArgs = arguments.length;\n        const lastArg = numArgs > 0 ? arguments[numArgs - 1] : null;\n        const cb = typeof lastArg === 'function' ? lastArg : null;\n        const args = Array.prototype.slice.\n          call(arguments, 0, cb == null ? numArgs : numArgs - 1);\n        // Special case: can't use `Kareem#wrap()` because it doesn't currently\n        // support wrapped functions that return a promise.\n        return promiseOrCallback(cb, callback => {\n          hooks.execPre(key, model, args, function(err) {\n            if (err != null) {\n              return callback(err);\n            }\n\n            let postCalled = 0;\n            const ret = original.apply(model, args.concat(post));\n            if (ret != null && typeof ret.then === 'function') {\n              ret.then(res => post(null, res), err => post(err));\n            }\n\n            function post(error, res) {\n              if (postCalled++ > 0) {\n                return;\n              }\n\n              if (error != null) {\n                return callback(error);\n              }\n\n              hooks.execPost(key, model, [res], function(error) {\n                if (error != null) {\n                  return callback(error);\n                }\n                callback(null, res);\n              });\n            }\n          });\n        }, model.events);\n      };\n    }\n  }\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM,EAAE,wBAAwB,EAAE,4BAA4B,EAAE,wBAAwB,EAAE,2BAA2B,EAAE;AAEvH,MAAM,sBAAsB,MAAM,IAAI,CACpC,IAAI,IAAI;OACH;OACA;OACA;OACA;CACJ;AAGH,OAAO,OAAO,GAAG,SAAS,iBAAiB,KAAK,EAAE,KAAK,EAAE,OAAO;IAC9D,MAAM,gBAAgB;QACpB,kBAAkB;QAClB,mBAAmB;IACrB;IAEA,MAAM,aAAa,GAAG,MAAM,aAAa,CAAC,cACxC,MAAM,aAAa,EAAE,OAAO;IAE9B,QAAQ,MAAM,MAAM,CAAC,CAAA;QACnB,sEAAsE;QACtE,0EAA0E;QAC1E,2EAA2E;QAC3E,+BAA+B;QAC/B,IAAI,oBAAoB,OAAO,CAAC,KAAK,IAAI,MAAM,CAAC,GAAG;YACjD,OAAO,CAAC,CAAC,KAAK,KAAK;QACrB;QACA,OAAO,KAAK,KAAK,KAAK;IACxB;IAEA,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,SAAU;QACtC,IAAI,MAAM,QAAQ,CAAC,MAAM;YACvB,MAAM,WAAW,KAAK,CAAC,IAAI;YAE3B,KAAK,CAAC,IAAI,GAAG;gBACX,MAAM,UAAU,UAAU,MAAM;gBAChC,MAAM,UAAU,UAAU,IAAI,SAAS,CAAC,UAAU,EAAE,GAAG;gBACvD,MAAM,KAAK,OAAO,YAAY,aAAa,UAAU;gBACrD,MAAM,OAAO,MAAM,SAAS,CAAC,KAAK,CAChC,IAAI,CAAC,WAAW,GAAG,MAAM,OAAO,UAAU,UAAU;gBACtD,uEAAuE;gBACvE,mDAAmD;gBACnD,OAAO,kBAAkB,IAAI,CAAA;oBAC3B,MAAM,OAAO,CAAC,KAAK,OAAO,MAAM,SAAS,GAAG;wBAC1C,IAAI,OAAO,MAAM;4BACf,OAAO,SAAS;wBAClB;wBAEA,IAAI,aAAa;wBACjB,MAAM,MAAM,SAAS,KAAK,CAAC,OAAO,KAAK,MAAM,CAAC;wBAC9C,IAAI,OAAO,QAAQ,OAAO,IAAI,IAAI,KAAK,YAAY;4BACjD,IAAI,IAAI,CAAC,CAAA,MAAO,KAAK,MAAM,MAAM,CAAA,MAAO,KAAK;wBAC/C;wBAEA,SAAS,KAAK,KAAK,EAAE,GAAG;4BACtB,IAAI,eAAe,GAAG;gCACpB;4BACF;4BAEA,IAAI,SAAS,MAAM;gCACjB,OAAO,SAAS;4BAClB;4BAEA,MAAM,QAAQ,CAAC,KAAK,OAAO;gCAAC;6BAAI,EAAE,SAAS,KAAK;gCAC9C,IAAI,SAAS,MAAM;oCACjB,OAAO,SAAS;gCAClB;gCACA,SAAS,MAAM;4BACjB;wBACF;oBACF;gBACF,GAAG,MAAM,MAAM;YACjB;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5992, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/model/applyStatics.js"],"sourcesContent":["'use strict';\n\n/**\n * Register statics for this model\n * @param {Model} model\n * @param {Schema} schema\n * @api private\n */\nmodule.exports = function applyStatics(model, schema) {\n  for (const i in schema.statics) {\n    model[i] = schema.statics[i];\n  }\n};\n"],"names":[],"mappings":"AAEA;;;;;CAKC,GACD,OAAO,OAAO,GAAG,SAAS,aAAa,KAAK,EAAE,MAAM;IAClD,IAAK,MAAM,KAAK,OAAO,OAAO,CAAE;QAC9B,KAAK,CAAC,EAAE,GAAG,OAAO,OAAO,CAAC,EAAE;IAC9B;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6006, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/document/applyTimestamps.js"],"sourcesContent":["'use strict';\n\nconst handleTimestampOption = require('../schema/handleTimestampOption');\nconst mpath = require('mpath');\n\nmodule.exports = applyTimestamps;\n\n/**\n * Apply a given schema's timestamps to the given POJO\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean} [options.isUpdate=false] if true, treat this as an update: just set updatedAt, skip setting createdAt. If false, set both createdAt and updatedAt\n * @param {Function} [options.currentTime] if set, Mongoose will call this function to get the current time.\n */\n\nfunction applyTimestamps(schema, obj, options) {\n  if (obj == null) {\n    return obj;\n  }\n\n  applyTimestampsToChildren(schema, obj, options);\n  return applyTimestampsToDoc(schema, obj, options);\n}\n\n/**\n * Apply timestamps to any subdocuments\n *\n * @param {Schema} schema subdocument schema\n * @param {Object} res subdocument\n * @param {Object} [options]\n * @param {Boolean} [options.isUpdate=false] if true, treat this as an update: just set updatedAt, skip setting createdAt. If false, set both createdAt and updatedAt\n * @param {Function} [options.currentTime] if set, Mongoose will call this function to get the current time.\n */\n\nfunction applyTimestampsToChildren(schema, res, options) {\n  for (const childSchema of schema.childSchemas) {\n    const _path = childSchema.model.path;\n    const _schema = childSchema.schema;\n    if (!_path) {\n      continue;\n    }\n    const _obj = mpath.get(_path, res);\n    if (_obj == null || (Array.isArray(_obj) && _obj.flat(Infinity).length === 0)) {\n      continue;\n    }\n\n    applyTimestamps(_schema, _obj, options);\n  }\n}\n\n/**\n * Apply timestamps to a given document. Does not apply timestamps to subdocuments: use `applyTimestampsToChildren` instead\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Object} [options]\n * @param {Boolean} [options.isUpdate=false] if true, treat this as an update: just set updatedAt, skip setting createdAt. If false, set both createdAt and updatedAt\n * @param {Function} [options.currentTime] if set, Mongoose will call this function to get the current time.\n */\n\nfunction applyTimestampsToDoc(schema, obj, options) {\n  if (obj == null || typeof obj !== 'object') {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (const el of obj) {\n      applyTimestampsToDoc(schema, el, options);\n    }\n    return;\n  }\n\n  if (schema.discriminators && Object.keys(schema.discriminators).length > 0) {\n    for (const discriminatorKey of Object.keys(schema.discriminators)) {\n      const discriminator = schema.discriminators[discriminatorKey];\n      const key = discriminator.discriminatorMapping.key;\n      const value = discriminator.discriminatorMapping.value;\n      if (obj[key] == value) {\n        schema = discriminator;\n        break;\n      }\n    }\n  }\n\n  const createdAt = handleTimestampOption(schema.options.timestamps, 'createdAt');\n  const updatedAt = handleTimestampOption(schema.options.timestamps, 'updatedAt');\n  const currentTime = options?.currentTime;\n\n  let ts = null;\n  if (currentTime != null) {\n    ts = currentTime();\n  } else if (schema.base?.now) {\n    ts = schema.base.now();\n  } else {\n    ts = new Date();\n  }\n\n  if (createdAt && obj[createdAt] == null && !options?.isUpdate) {\n    obj[createdAt] = ts;\n  }\n  if (updatedAt) {\n    obj[updatedAt] = ts;\n  }\n}\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AAEN,OAAO,OAAO,GAAG;AAEjB;;;;;;;;CAQC,GAED,SAAS,gBAAgB,MAAM,EAAE,GAAG,EAAE,OAAO;IAC3C,IAAI,OAAO,MAAM;QACf,OAAO;IACT;IAEA,0BAA0B,QAAQ,KAAK;IACvC,OAAO,qBAAqB,QAAQ,KAAK;AAC3C;AAEA;;;;;;;;CAQC,GAED,SAAS,0BAA0B,MAAM,EAAE,GAAG,EAAE,OAAO;IACrD,KAAK,MAAM,eAAe,OAAO,YAAY,CAAE;QAC7C,MAAM,QAAQ,YAAY,KAAK,CAAC,IAAI;QACpC,MAAM,UAAU,YAAY,MAAM;QAClC,IAAI,CAAC,OAAO;YACV;QACF;QACA,MAAM,OAAO,MAAM,GAAG,CAAC,OAAO;QAC9B,IAAI,QAAQ,QAAS,MAAM,OAAO,CAAC,SAAS,KAAK,IAAI,CAAC,UAAU,MAAM,KAAK,GAAI;YAC7E;QACF;QAEA,gBAAgB,SAAS,MAAM;IACjC;AACF;AAEA;;;;;;;;CAQC,GAED,SAAS,qBAAqB,MAAM,EAAE,GAAG,EAAE,OAAO;IAChD,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;QAC1C;IACF;IACA,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,KAAK,MAAM,MAAM,IAAK;YACpB,qBAAqB,QAAQ,IAAI;QACnC;QACA;IACF;IAEA,IAAI,OAAO,cAAc,IAAI,OAAO,IAAI,CAAC,OAAO,cAAc,EAAE,MAAM,GAAG,GAAG;QAC1E,KAAK,MAAM,oBAAoB,OAAO,IAAI,CAAC,OAAO,cAAc,EAAG;YACjE,MAAM,gBAAgB,OAAO,cAAc,CAAC,iBAAiB;YAC7D,MAAM,MAAM,cAAc,oBAAoB,CAAC,GAAG;YAClD,MAAM,QAAQ,cAAc,oBAAoB,CAAC,KAAK;YACtD,IAAI,GAAG,CAAC,IAAI,IAAI,OAAO;gBACrB,SAAS;gBACT;YACF;QACF;IACF;IAEA,MAAM,YAAY,sBAAsB,OAAO,OAAO,CAAC,UAAU,EAAE;IACnE,MAAM,YAAY,sBAAsB,OAAO,OAAO,CAAC,UAAU,EAAE;IACnE,MAAM,cAAc,SAAS;IAE7B,IAAI,KAAK;IACT,IAAI,eAAe,MAAM;QACvB,KAAK;IACP,OAAO,IAAI,OAAO,IAAI,EAAE,KAAK;QAC3B,KAAK,OAAO,IAAI,CAAC,GAAG;IACtB,OAAO;QACL,KAAK,IAAI;IACX;IAEA,IAAI,aAAa,GAAG,CAAC,UAAU,IAAI,QAAQ,CAAC,SAAS,UAAU;QAC7D,GAAG,CAAC,UAAU,GAAG;IACnB;IACA,IAAI,WAAW;QACb,GAAG,CAAC,UAAU,GAAG;IACnB;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6097, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/document/applyVirtuals.js"],"sourcesContent":["'use strict';\n\nconst mpath = require('mpath');\n\nmodule.exports = applyVirtuals;\n\n/**\n * Apply a given schema's virtuals to a given POJO\n *\n * @param {Schema} schema\n * @param {Object} obj\n * @param {Array<string>} [virtuals] optional whitelist of virtuals to apply\n * @returns\n */\n\nfunction applyVirtuals(schema, obj, virtuals) {\n  if (obj == null) {\n    return obj;\n  }\n\n  let virtualsForChildren = virtuals;\n  let toApply = null;\n\n  if (Array.isArray(virtuals)) {\n    virtualsForChildren = [];\n    toApply = [];\n    for (const virtual of virtuals) {\n      if (virtual.length === 1) {\n        toApply.push(virtual[0]);\n      } else {\n        virtualsForChildren.push(virtual);\n      }\n    }\n  }\n\n  applyVirtualsToChildren(schema, obj, virtualsForChildren);\n  return applyVirtualsToDoc(schema, obj, toApply);\n}\n\n/**\n * Apply virtuals to any subdocuments\n *\n * @param {Schema} schema subdocument schema\n * @param {Object} res subdocument\n * @param {Array<String>} [virtuals] optional whitelist of virtuals to apply\n */\n\nfunction applyVirtualsToChildren(schema, res, virtuals) {\n  let attachedVirtuals = false;\n  for (const childSchema of schema.childSchemas) {\n    const _path = childSchema.model.path;\n    const _schema = childSchema.schema;\n    if (!_path) {\n      continue;\n    }\n    const _obj = mpath.get(_path, res);\n    if (_obj == null || (Array.isArray(_obj) && _obj.flat(Infinity).length === 0)) {\n      continue;\n    }\n\n    let virtualsForChild = null;\n    if (Array.isArray(virtuals)) {\n      virtualsForChild = [];\n      for (const virtual of virtuals) {\n        if (virtual[0] == _path) {\n          virtualsForChild.push(virtual.slice(1));\n        }\n      }\n\n      if (virtualsForChild.length === 0) {\n        continue;\n      }\n    }\n\n    applyVirtuals(_schema, _obj, virtualsForChild);\n    attachedVirtuals = true;\n  }\n\n  if (virtuals && virtuals.length && !attachedVirtuals) {\n    applyVirtualsToDoc(schema, res, virtuals);\n  }\n}\n\n/**\n * Apply virtuals to a given document. Does not apply virtuals to subdocuments: use `applyVirtualsToChildren` instead\n *\n * @param {Schema} schema\n * @param {Object} doc\n * @param {Array<String>} [virtuals] optional whitelist of virtuals to apply\n * @returns\n */\n\nfunction applyVirtualsToDoc(schema, obj, virtuals) {\n  if (obj == null || typeof obj !== 'object') {\n    return;\n  }\n  if (Array.isArray(obj)) {\n    for (const el of obj) {\n      applyVirtualsToDoc(schema, el, virtuals);\n    }\n    return;\n  }\n\n  if (schema.discriminators && Object.keys(schema.discriminators).length > 0) {\n    for (const discriminatorKey of Object.keys(schema.discriminators)) {\n      const discriminator = schema.discriminators[discriminatorKey];\n      const key = discriminator.discriminatorMapping.key;\n      const value = discriminator.discriminatorMapping.value;\n      if (obj[key] == value) {\n        schema = discriminator;\n        break;\n      }\n    }\n  }\n\n  if (virtuals == null) {\n    virtuals = Object.keys(schema.virtuals);\n  }\n  for (const virtual of virtuals) {\n    if (schema.virtuals[virtual] == null) {\n      continue;\n    }\n    const virtualType = schema.virtuals[virtual];\n    const sp = Array.isArray(virtual)\n      ? virtual\n      : virtual.indexOf('.') === -1\n        ? [virtual]\n        : virtual.split('.');\n    let cur = obj;\n    for (let i = 0; i < sp.length - 1; ++i) {\n      cur[sp[i]] = sp[i] in cur ? cur[sp[i]] : {};\n      cur = cur[sp[i]];\n    }\n    let val = virtualType.applyGetters(cur[sp[sp.length - 1]], obj);\n    const isPopulateVirtual =\n      virtualType.options && (virtualType.options.ref || virtualType.options.refPath);\n    if (isPopulateVirtual && val === undefined) {\n      if (virtualType.options.justOne) {\n        val = null;\n      } else {\n        val = [];\n      }\n    }\n    cur[sp[sp.length - 1]] = val;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6223, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/skipPopulateValue.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function SkipPopulateValue(val) {\n  if (!(this instanceof SkipPopulateValue)) {\n    return new SkipPopulateValue(val);\n  }\n\n  this.val = val;\n  return this;\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,kBAAkB,GAAG;IAC7C,IAAI,CAAC,CAAC,IAAI,YAAY,iBAAiB,GAAG;QACxC,OAAO,IAAI,kBAAkB;IAC/B;IAEA,IAAI,CAAC,GAAG,GAAG;IACX,OAAO,IAAI;AACb","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6234, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/leanPopulateMap.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = new WeakMap();\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,OAAO,OAAO,GAAG,IAAI","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6241, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/assignRawDocsToIdStructure.js"],"sourcesContent":["'use strict';\n\nconst clone = require('../../helpers/clone');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst modelSymbol = require('../symbols').modelSymbol;\nconst utils = require('../../utils');\n\nmodule.exports = assignRawDocsToIdStructure;\n\nconst kHasArray = Symbol('mongoose#assignRawDocsToIdStructure#hasArray');\n\n/**\n * Assign `vals` returned by mongo query to the `rawIds`\n * structure returned from utils.getVals() honoring\n * query sort order if specified by user.\n *\n * This can be optimized.\n *\n * Rules:\n *\n *   if the value of the path is not an array, use findOne rules, else find.\n *   for findOne the results are assigned directly to doc path (including null results).\n *   for find, if user specified sort order, results are assigned directly\n *   else documents are put back in original order of array if found in results\n *\n * @param {Array} rawIds\n * @param {Array} resultDocs\n * @param {Array} resultOrder\n * @param {Object} options\n * @param {Boolean} recursed\n * @api private\n */\n\nfunction assignRawDocsToIdStructure(rawIds, resultDocs, resultOrder, options, recursed) {\n  // honor user specified sort order, unless we're populating a single\n  // virtual underneath an array (e.g. populating `employees.mostRecentShift` where\n  // `mostRecentShift` is a virtual with `justOne`)\n  const newOrder = [];\n  const sorting = options.isVirtual && options.justOne && rawIds.length > 1\n    ? false :\n    options.sort && rawIds.length > 1;\n  const nullIfNotFound = options.$nullIfNotFound;\n  let doc;\n  let sid;\n  let id;\n\n  if (utils.isMongooseArray(rawIds)) {\n    rawIds = rawIds.__array;\n  }\n\n  let i = 0;\n  const len = rawIds.length;\n\n  if (sorting && recursed && options[kHasArray] === undefined) {\n    options[kHasArray] = false;\n    for (const key in resultOrder) {\n      if (Array.isArray(resultOrder[key])) {\n        options[kHasArray] = true;\n        break;\n      }\n    }\n  }\n\n  for (i = 0; i < len; ++i) {\n    id = rawIds[i];\n\n    if (Array.isArray(id)) {\n      // handle [ [id0, id2], [id3] ]\n      assignRawDocsToIdStructure(id, resultDocs, resultOrder, options, true);\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id === null && sorting === false) {\n      // keep nulls for findOne unless sorting, which always\n      // removes them (backward compat)\n      newOrder.push(id);\n      continue;\n    }\n\n    if (id?.constructor?.name === 'Binary' && id.sub_type === 4 && typeof id.toUUID === 'function') {\n      // Workaround for gh-15315 because Mongoose UUIDs don't use BSON UUIDs yet.\n      sid = String(id.toUUID());\n    } else if (id?.constructor?.name === 'Buffer' && id._subtype === 4 && typeof id.toUUID === 'function') {\n      sid = String(id.toUUID());\n    } else {\n      sid = String(id);\n    }\n    doc = resultDocs[sid];\n    // If user wants separate copies of same doc, use this option\n    if (options.clone && doc != null) {\n      if (options.lean) {\n        const _model = leanPopulateMap.get(doc);\n        doc = clone(doc);\n        leanPopulateMap.set(doc, _model);\n      } else {\n        doc = doc.constructor.hydrate(doc._doc);\n      }\n    }\n\n    if (recursed) {\n      if (doc) {\n        if (sorting) {\n          const _resultOrder = resultOrder[sid];\n          if (options[kHasArray]) {\n            // If result arrays, rely on the MongoDB server response for ordering\n            newOrder.push(doc);\n          } else {\n            newOrder[_resultOrder] = doc;\n          }\n        } else {\n          newOrder.push(doc);\n        }\n      } else if (id != null && id[modelSymbol] != null) {\n        newOrder.push(id);\n      } else {\n        newOrder.push(options.retainNullValues || nullIfNotFound ? null : id);\n      }\n    } else {\n      // apply findOne behavior - if document in results, assign, else assign null\n      newOrder[i] = doc || null;\n    }\n  }\n\n  rawIds.length = 0;\n  if (newOrder.length) {\n    // reassign the documents based on corrected order\n\n    // forEach skips over sparse entries in arrays so we\n    // can safely use this to our advantage dealing with sorted\n    // result sets too.\n    newOrder.forEach(function(doc, i) {\n      rawIds[i] = doc;\n    });\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6362, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/getVirtual.js"],"sourcesContent":["'use strict';\n\nmodule.exports = getVirtual;\n\n/*!\n * ignore\n */\n\nfunction getVirtual(schema, name) {\n  if (schema.virtuals[name]) {\n    return { virtual: schema.virtuals[name], path: void 0 };\n  }\n\n  const parts = name.split('.');\n  let cur = '';\n  let nestedSchemaPath = '';\n  for (let i = 0; i < parts.length; ++i) {\n    cur += (cur.length > 0 ? '.' : '') + parts[i];\n    if (schema.virtuals[cur]) {\n      if (i === parts.length - 1) {\n        return { virtual: schema.virtuals[cur], path: nestedSchemaPath };\n      }\n      continue;\n    }\n\n    if (schema.nested[cur]) {\n      continue;\n    }\n\n    if (schema.paths[cur] && schema.paths[cur].schema) {\n      schema = schema.paths[cur].schema;\n      const rest = parts.slice(i + 1).join('.');\n\n      if (schema.virtuals[rest]) {\n        if (i === parts.length - 2) {\n          return {\n            virtual: schema.virtuals[rest],\n            nestedSchemaPath: [nestedSchemaPath, cur].filter(v => !!v).join('.')\n          };\n        }\n        continue;\n      }\n\n      if (i + 1 < parts.length && schema.discriminators) {\n        for (const key of Object.keys(schema.discriminators)) {\n          const res = getVirtual(schema.discriminators[key], rest);\n          if (res != null) {\n            const _path = [nestedSchemaPath, cur, res.nestedSchemaPath].\n              filter(v => !!v).join('.');\n            return {\n              virtual: res.virtual,\n              nestedSchemaPath: _path\n            };\n          }\n        }\n      }\n\n      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + cur;\n      cur = '';\n      continue;\n    } else if (schema.paths[cur]?.$isSchemaMap && schema.paths[cur].$__schemaType?.schema) {\n      schema = schema.paths[cur].$__schemaType.schema;\n      ++i;\n      const rest = parts.slice(i + 1).join('.');\n\n      if (schema.virtuals[rest]) {\n        if (i === parts.length - 2) {\n          return {\n            virtual: schema.virtuals[rest],\n            nestedSchemaPath: [nestedSchemaPath, cur, '$*'].filter(v => !!v).join('.')\n          };\n        }\n        continue;\n      }\n\n      if (i + 1 < parts.length && schema.discriminators) {\n        for (const key of Object.keys(schema.discriminators)) {\n          const res = getVirtual(schema.discriminators[key], rest);\n          if (res != null) {\n            const _path = [nestedSchemaPath, cur, res.nestedSchemaPath, '$*'].\n              filter(v => !!v).join('.');\n            return {\n              virtual: res.virtual,\n              nestedSchemaPath: _path\n            };\n          }\n        }\n      }\n\n      nestedSchemaPath += (nestedSchemaPath.length > 0 ? '.' : '') + '$*' + cur;\n      cur = '';\n    }\n\n    if (schema.discriminators) {\n      for (const discriminatorKey of Object.keys(schema.discriminators)) {\n        const virtualFromDiscriminator = getVirtual(schema.discriminators[discriminatorKey], name);\n        if (virtualFromDiscriminator) return virtualFromDiscriminator;\n      }\n    }\n\n    return null;\n  }\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6473, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/assignVals.js"],"sourcesContent":["'use strict';\n\nconst MongooseMap = require('../../types/map');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst assignRawDocsToIdStructure = require('./assignRawDocsToIdStructure');\nconst get = require('../get');\nconst getVirtual = require('./getVirtual');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst markArraySubdocsPopulated = require('./markArraySubdocsPopulated');\nconst mpath = require('mpath');\nconst sift = require('sift').default;\nconst utils = require('../../utils');\nconst { populateModelSymbol } = require('../symbols');\n\nmodule.exports = function assignVals(o) {\n  // Options that aren't explicitly listed in `populateOptions`\n  const userOptions = Object.assign({}, get(o, 'allOptions.options.options'), get(o, 'allOptions.options'));\n  // `o.options` contains options explicitly listed in `populateOptions`, like\n  // `match` and `limit`.\n  const populateOptions = Object.assign({}, o.options, userOptions, {\n    justOne: o.justOne,\n    isVirtual: o.isVirtual\n  });\n  populateOptions.$nullIfNotFound = o.isVirtual;\n  const populatedModel = o.populatedModel;\n\n  const originalIds = [].concat(o.rawIds);\n\n  // replace the original ids in our intermediate _ids structure\n  // with the documents found by query\n  o.allIds = [].concat(o.allIds);\n  assignRawDocsToIdStructure(o.rawIds, o.rawDocs, o.rawOrder, populateOptions);\n\n  // now update the original documents being populated using the\n  // result structure that contains real documents.\n  const docs = o.docs;\n  const rawIds = o.rawIds;\n  const options = o.options;\n  const count = o.count && o.isVirtual;\n  let i;\n  let setValueIndex = 0;\n\n  function setValue(val) {\n    ++setValueIndex;\n    if (count) {\n      return val;\n    }\n    if (val instanceof SkipPopulateValue) {\n      return val.val;\n    }\n    if (val === void 0) {\n      return val;\n    }\n\n    const _allIds = o.allIds[i];\n\n    if (o.path.endsWith('.$*')) {\n      // Skip maps re: gh-12494\n      return valueFilter(val, options, populateOptions, _allIds);\n    }\n\n    if (o.justOne === true && Array.isArray(val)) {\n      // Might be an embedded discriminator (re: gh-9244) with multiple models, so make sure to pick the right\n      // model before assigning.\n      const ret = [];\n      for (const doc of val) {\n        const _docPopulatedModel = leanPopulateMap.get(doc);\n        if (_docPopulatedModel == null || _docPopulatedModel === populatedModel) {\n          ret.push(doc);\n        }\n      }\n      // Since we don't want to have to create a new mongoosearray, make sure to\n      // modify the array in place\n      while (val.length > ret.length) {\n        Array.prototype.pop.apply(val, []);\n      }\n      for (let i = 0; i < ret.length; ++i) {\n        val[i] = ret[i];\n      }\n\n      return valueFilter(val[0], options, populateOptions, _allIds);\n    } else if (o.justOne === false && !Array.isArray(val)) {\n      return valueFilter([val], options, populateOptions, _allIds);\n    } else if (o.justOne === true && !Array.isArray(val) && Array.isArray(_allIds)) {\n      return valueFilter(val, options, populateOptions, val == null ? val : _allIds[setValueIndex - 1]);\n    }\n    return valueFilter(val, options, populateOptions, _allIds);\n  }\n\n  for (i = 0; i < docs.length; ++i) {\n    setValueIndex = 0;\n    const _path = o.path.endsWith('.$*') ? o.path.slice(0, -3) : o.path;\n    const existingVal = mpath.get(_path, docs[i], lookupLocalFields);\n    if (existingVal == null && !getVirtual(o.originalModel.schema, _path)) {\n      continue;\n    }\n\n    let valueToSet;\n    if (count) {\n      valueToSet = numDocs(rawIds[i]);\n    } else if (Array.isArray(o.match)) {\n      valueToSet = Array.isArray(rawIds[i]) ?\n        rawIds[i].filter(v => v == null || sift(o.match[i])(v)) :\n        [rawIds[i]].filter(v => v == null || sift(o.match[i])(v))[0];\n    } else {\n      valueToSet = rawIds[i];\n    }\n\n    // If we're populating a map, the existing value will be an object, so\n    // we need to transform again\n    const originalSchema = o.originalModel.schema;\n    const isDoc = get(docs[i], '$__', null) != null;\n    let isMap = isDoc ?\n      existingVal instanceof Map :\n      utils.isPOJO(existingVal);\n    // If we pass the first check, also make sure the local field's schematype\n    // is map (re: gh-6460)\n    isMap = isMap && get(originalSchema._getSchema(_path), '$isSchemaMap');\n    if (!o.isVirtual && isMap) {\n      const _keys = existingVal instanceof Map ?\n        Array.from(existingVal.keys()) :\n        Object.keys(existingVal);\n      valueToSet = valueToSet.reduce((cur, v, i) => {\n        cur.set(_keys[i], v);\n        return cur;\n      }, new Map());\n    }\n\n    if (isDoc && Array.isArray(valueToSet)) {\n      for (const val of valueToSet) {\n        if (val != null && val.$__ != null) {\n          val.$__.parent = docs[i];\n        }\n      }\n    } else if (isDoc && valueToSet != null && valueToSet.$__ != null) {\n      valueToSet.$__.parent = docs[i];\n    }\n\n    if (o.isVirtual && isDoc) {\n      docs[i].$populated(_path, o.justOne ? originalIds[0] : originalIds, o.allOptions);\n      // If virtual populate and doc is already init-ed, need to walk through\n      // the actual doc to set rather than setting `_doc` directly\n      if (Array.isArray(valueToSet)) {\n        valueToSet = valueToSet.map(v => v == null ? void 0 : v);\n      }\n      mpath.set(\n        _path,\n        valueToSet,\n        docs[i],\n        // Handle setting paths underneath maps using $* by converting arrays into maps of values\n        function lookup(obj, part, val) {\n          if (arguments.length >= 3) {\n            obj[part] = val;\n            return obj[part];\n          }\n          if (obj instanceof Map && part === '$*') {\n            return [...obj.values()];\n          }\n          return obj[part];\n        },\n        setValue,\n        false\n      );\n      continue;\n    }\n\n    const parts = _path.split('.');\n    let cur = docs[i];\n    for (let j = 0; j < parts.length - 1; ++j) {\n      // If we get to an array with a dotted path, like `arr.foo`, don't set\n      // `foo` on the array.\n      if (Array.isArray(cur) && !utils.isArrayIndex(parts[j])) {\n        break;\n      }\n\n      if (parts[j] === '$*') {\n        break;\n      }\n\n      if (cur[parts[j]] == null) {\n        // If nothing to set, avoid creating an unnecessary array. Otherwise\n        // we'll end up with a single doc in the array with only defaults.\n        // See gh-8342, gh-8455\n        const curPath = parts.slice(0, j + 1).join('.');\n        const schematype = originalSchema._getSchema(curPath);\n        if (valueToSet == null && schematype != null && schematype.$isMongooseArray) {\n          break;\n        }\n        cur[parts[j]] = {};\n      }\n      cur = cur[parts[j]];\n      // If the property in MongoDB is a primitive, we won't be able to populate\n      // the nested path, so skip it. See gh-7545\n      if (typeof cur !== 'object') {\n        break;\n      }\n    }\n    if (docs[i].$__) {\n      o.allOptions.options[populateModelSymbol] = o.allOptions.model;\n      docs[i].$populated(_path, o.unpopulatedValues[i], o.allOptions.options);\n\n      if (valueToSet != null && valueToSet.$__ != null) {\n        valueToSet.$__.wasPopulated = { value: o.unpopulatedValues[i] };\n      }\n\n      if (valueToSet instanceof Map && !valueToSet.$isMongooseMap) {\n        valueToSet = new MongooseMap(valueToSet, _path, docs[i], docs[i].schema.path(_path).$__schemaType);\n      }\n    }\n\n    // If lean, need to check that each individual virtual respects\n    // `justOne`, because you may have a populated virtual with `justOne`\n    // underneath an array. See gh-6867\n    mpath.set(_path, valueToSet, docs[i], lookupLocalFields, setValue, false);\n\n    if (docs[i].$__) {\n      markArraySubdocsPopulated(docs[i], [o.allOptions.options]);\n    }\n  }\n};\n\nfunction numDocs(v) {\n  if (Array.isArray(v)) {\n    // If setting underneath an array of populated subdocs, we may have an\n    // array of arrays. See gh-7573\n    if (v.some(el => Array.isArray(el) || el === null)) {\n      return v.map(el => {\n        if (el == null) {\n          return 0;\n        }\n        if (Array.isArray(el)) {\n          return el.filter(el => el != null).length;\n        }\n        return 1;\n      });\n    }\n    return v.filter(el => el != null).length;\n  }\n  return v == null ? 0 : 1;\n}\n\n/**\n * 1) Apply backwards compatible find/findOne behavior to sub documents\n *\n *    find logic:\n *      a) filter out non-documents\n *      b) remove _id from sub docs when user specified\n *\n *    findOne\n *      a) if no doc found, set to null\n *      b) remove _id from sub docs when user specified\n *\n * 2) Remove _ids when specified by users query.\n *\n * background:\n * _ids are left in the query even when user excludes them so\n * that population mapping can occur.\n * @param {Any} val\n * @param {Object} assignmentOpts\n * @param {Object} populateOptions\n * @param {Function} [populateOptions.transform]\n * @param {Boolean} allIds\n * @api private\n */\n\nfunction valueFilter(val, assignmentOpts, populateOptions, allIds) {\n  const userSpecifiedTransform = typeof populateOptions.transform === 'function';\n  const transform = userSpecifiedTransform ? populateOptions.transform : v => v;\n  if (Array.isArray(val)) {\n    // find logic\n    const ret = [];\n    const numValues = val.length;\n    for (let i = 0; i < numValues; ++i) {\n      let subdoc = val[i];\n      const _allIds = Array.isArray(allIds) ? allIds[i] : allIds;\n      if (!isPopulatedObject(subdoc) && (!populateOptions.retainNullValues || subdoc != null) && !userSpecifiedTransform) {\n        continue;\n      } else if (!populateOptions.retainNullValues && subdoc == null) {\n        continue;\n      } else if (userSpecifiedTransform) {\n        subdoc = transform(isPopulatedObject(subdoc) ? subdoc : null, _allIds);\n      }\n      maybeRemoveId(subdoc, assignmentOpts);\n      ret.push(subdoc);\n      if (assignmentOpts.originalLimit &&\n          ret.length >= assignmentOpts.originalLimit) {\n        break;\n      }\n    }\n\n    const rLen = ret.length;\n    // Since we don't want to have to create a new mongoosearray, make sure to\n    // modify the array in place\n    while (val.length > rLen) {\n      Array.prototype.pop.apply(val, []);\n    }\n    let i = 0;\n    if (utils.isMongooseArray(val)) {\n      for (i = 0; i < rLen; ++i) {\n        val.set(i, ret[i], true);\n      }\n    } else {\n      for (i = 0; i < rLen; ++i) {\n        val[i] = ret[i];\n      }\n    }\n    return val;\n  }\n\n  // findOne\n  if (isPopulatedObject(val) || utils.isPOJO(val)) {\n    maybeRemoveId(val, assignmentOpts);\n    return transform(val, allIds);\n  }\n  if (val instanceof Map) {\n    return val;\n  }\n\n  if (populateOptions.justOne === false) {\n    return [];\n  }\n\n  return val == null ? transform(val, allIds) : transform(null, allIds);\n}\n\n/**\n * Remove _id from `subdoc` if user specified \"lean\" query option\n * @param {Document} subdoc\n * @param {Object} assignmentOpts\n * @api private\n */\n\nfunction maybeRemoveId(subdoc, assignmentOpts) {\n  if (subdoc != null && assignmentOpts.excludeId) {\n    if (typeof subdoc.$__setValue === 'function') {\n      delete subdoc._doc._id;\n    } else {\n      delete subdoc._id;\n    }\n  }\n}\n\n/**\n * Determine if `obj` is something we can set a populated path to. Can be a\n * document, a lean document, or an array/map that contains docs.\n * @param {Any} obj\n * @api private\n */\n\nfunction isPopulatedObject(obj) {\n  if (obj == null) {\n    return false;\n  }\n\n  return Array.isArray(obj) ||\n    obj.$isMongooseMap ||\n    obj.$__ != null ||\n    leanPopulateMap.has(obj);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6792, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/createPopulateQueryFilter.js"],"sourcesContent":["'use strict';\n\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst parentPaths = require('../path/parentPaths');\nconst { trusted } = require('../query/trusted');\nconst hasDollarKeys = require('../query/hasDollarKeys');\n\nmodule.exports = function createPopulateQueryFilter(ids, _match, _foreignField, model, skipInvalidIds) {\n  const match = _formatMatch(_match);\n\n  if (_foreignField.size === 1) {\n    const foreignField = Array.from(_foreignField)[0];\n    const foreignSchemaType = model.schema.path(foreignField);\n    if (foreignField !== '_id' || !match['_id']) {\n      ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n      match[foreignField] = trusted({ $in: ids });\n    } else if (foreignField === '_id' && match['_id']) {\n      const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ?\n        match[foreignField] :\n        { $eq: match[foreignField] };\n      match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };\n    }\n\n    const _parentPaths = parentPaths(foreignField);\n    for (let i = 0; i < _parentPaths.length - 1; ++i) {\n      const cur = _parentPaths[i];\n      if (match[cur] != null && match[cur].$elemMatch != null) {\n        match[cur].$elemMatch[foreignField.slice(cur.length + 1)] = trusted({ $in: ids });\n        delete match[foreignField];\n        break;\n      }\n    }\n  } else {\n    const $or = [];\n    if (Array.isArray(match.$or)) {\n      match.$and = [{ $or: match.$or }, { $or: $or }];\n      delete match.$or;\n    } else {\n      match.$or = $or;\n    }\n    for (const foreignField of _foreignField) {\n      if (foreignField !== '_id' || !match['_id']) {\n        const foreignSchemaType = model.schema.path(foreignField);\n        ids = _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds);\n        $or.push({ [foreignField]: { $in: ids } });\n      } else if (foreignField === '_id' && match['_id']) {\n        const userSpecifiedMatch = hasDollarKeys(match[foreignField]) ?\n          match[foreignField] :\n          { $eq: match[foreignField] };\n        match[foreignField] = { ...trusted({ $in: ids }), ...userSpecifiedMatch };\n      }\n    }\n  }\n\n  return match;\n};\n\n/**\n * Optionally filter out invalid ids that don't conform to foreign field's schema\n * to avoid cast errors (gh-7706)\n * @param {Array} ids\n * @param {SchemaType} foreignSchemaType\n * @param {Boolean} [skipInvalidIds]\n * @api private\n */\n\nfunction _filterInvalidIds(ids, foreignSchemaType, skipInvalidIds) {\n  ids = ids.filter(v => !(v instanceof SkipPopulateValue));\n  if (!skipInvalidIds) {\n    return ids;\n  }\n  return ids.filter(id => {\n    try {\n      foreignSchemaType.cast(id);\n      return true;\n    } catch (err) {\n      return false;\n    }\n  });\n}\n\n/**\n * Format `mod.match` given that it may be an array that we need to $or if\n * the client has multiple docs with match functions\n * @param {Array|Any} match\n * @api private\n */\n\nfunction _formatMatch(match) {\n  if (Array.isArray(match)) {\n    if (match.length > 1) {\n      return { $or: [].concat(match.map(m => Object.assign({}, m))) };\n    }\n    return Object.assign({}, match[0]);\n  }\n  return Object.assign({}, match);\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 6908, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/getSchemaTypes.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst Mixed = require('../../schema/mixed');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst leanPopulateMap = require('./leanPopulateMap');\nconst mpath = require('mpath');\n\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\n\n/**\n * Given a model and its schema, find all possible schema types for `path`,\n * including searching through discriminators. If `doc` is specified, will\n * use the doc's values for discriminator keys when searching, otherwise\n * will search all discriminators.\n *\n * @param {Model} model\n * @param {Schema} schema\n * @param {Object} doc POJO\n * @param {string} path\n * @api private\n */\n\nmodule.exports = function getSchemaTypes(model, schema, doc, path) {\n  const pathschema = schema.path(path);\n  const topLevelDoc = doc;\n  if (pathschema) {\n    return pathschema;\n  }\n\n  const discriminatorKey = schema.discriminatorMapping &&\n    schema.discriminatorMapping.key;\n  if (discriminatorKey && model != null) {\n    if (doc != null && doc[discriminatorKey] != null) {\n      const discriminator = getDiscriminatorByValue(model.discriminators, doc[discriminatorKey]);\n      schema = discriminator ? discriminator.schema : schema;\n    } else if (model.discriminators != null) {\n      return Object.keys(model.discriminators).reduce((arr, name) => {\n        const disc = model.discriminators[name];\n        return arr.concat(getSchemaTypes(disc, disc.schema, null, path));\n      }, []);\n    }\n  }\n\n  function search(parts, schema, subdoc, nestedPath) {\n    let p = parts.length + 1;\n    let foundschema;\n    let trypath;\n\n    while (p--) {\n      trypath = parts.slice(0, p).join('.');\n      foundschema = schema.path(trypath);\n      if (foundschema == null) {\n        continue;\n      }\n\n      if (foundschema.caster) {\n        // array of Mixed?\n        if (foundschema.caster instanceof Mixed) {\n          return foundschema.caster;\n        }\n\n        let schemas = null;\n        if (foundschema.schema != null && foundschema.schema.discriminators != null) {\n          const discriminators = foundschema.schema.discriminators;\n          const discriminatorKeyPath = trypath + '.' +\n            foundschema.schema.options.discriminatorKey;\n          const keys = subdoc ? mpath.get(discriminatorKeyPath, subdoc) || [] : [];\n          schemas = Object.keys(discriminators).\n            reduce(function(cur, discriminator) {\n              const tiedValue = discriminators[discriminator].discriminatorMapping.value;\n              if (doc == null || keys.indexOf(discriminator) !== -1 || keys.indexOf(tiedValue) !== -1) {\n                cur.push(discriminators[discriminator]);\n              }\n              return cur;\n            }, []);\n        }\n\n        // Now that we found the array, we need to check if there\n        // are remaining document paths to look up for casting.\n        // Also we need to handle array.$.path since schema.path\n        // doesn't work for that.\n        // If there is no foundschema.schema we are dealing with\n        // a path like array.$\n        if (p !== parts.length && foundschema.schema) {\n          let ret;\n          if (parts[p] === '$') {\n            if (p + 1 === parts.length) {\n              // comments.$\n              return foundschema;\n            }\n            // comments.$.comments.$.title\n            ret = search(\n              parts.slice(p + 1),\n              schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n\n          if (schemas != null && schemas.length > 0) {\n            ret = [];\n            for (const schema of schemas) {\n              const _ret = search(\n                parts.slice(p),\n                schema,\n                subdoc ? mpath.get(trypath, subdoc) : null,\n                nestedPath.concat(parts.slice(0, p))\n              );\n              if (_ret != null) {\n                _ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray ||\n                  (foundschema.schema.$isSingleNested ? null : foundschema);\n                if (_ret.$parentSchemaDocArray) {\n                  ret.$parentSchemaDocArray = _ret.$parentSchemaDocArray;\n                }\n                ret.push(_ret);\n              }\n            }\n            return ret;\n          } else {\n            ret = search(\n              parts.slice(p),\n              foundschema.schema,\n              subdoc ? mpath.get(trypath, subdoc) : null,\n              nestedPath.concat(parts.slice(0, p))\n            );\n\n            if (ret) {\n              ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n                (foundschema.schema.$isSingleNested ? null : foundschema);\n            }\n            return ret;\n          }\n        } else if (p !== parts.length &&\n            foundschema.$isMongooseArray &&\n            foundschema.casterConstructor.$isMongooseArray) {\n          // Nested arrays. Drill down to the bottom of the nested array.\n          let type = foundschema;\n          while (type.$isMongooseArray && !type.$isMongooseDocumentArray) {\n            type = type.casterConstructor;\n          }\n\n          const ret = search(\n            parts.slice(p),\n            type.schema,\n            null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n          if (ret != null) {\n            return ret;\n          }\n\n          if (type.schema.discriminators) {\n            const discriminatorPaths = [];\n            for (const discriminatorName of Object.keys(type.schema.discriminators)) {\n              const _schema = type.schema.discriminators[discriminatorName] || type.schema;\n              const ret = search(parts.slice(p), _schema, null, nestedPath.concat(parts.slice(0, p)));\n              if (ret != null) {\n                discriminatorPaths.push(ret);\n              }\n            }\n            if (discriminatorPaths.length > 0) {\n              return discriminatorPaths;\n            }\n          }\n        }\n      } else if (foundschema.$isSchemaMap && foundschema.$__schemaType instanceof Mixed) {\n        return foundschema.$__schemaType;\n      }\n\n      const fullPath = nestedPath.concat([trypath]).join('.');\n      if (topLevelDoc != null && topLevelDoc.$__ && topLevelDoc.$populated(fullPath, true) && p < parts.length) {\n        const model = topLevelDoc.$populated(fullPath, true).options[populateModelSymbol];\n        if (model != null) {\n          const ret = search(\n            parts.slice(p),\n            model.schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          return ret;\n        }\n      }\n\n      const _val = get(topLevelDoc, trypath);\n      if (_val != null) {\n        const model = Array.isArray(_val) && _val.length > 0 ?\n          leanPopulateMap.get(_val[0]) :\n          leanPopulateMap.get(_val);\n        // Populated using lean, `leanPopulateMap` value is the foreign model\n        const schema = model != null ? model.schema : null;\n        if (schema != null) {\n          const ret = search(\n            parts.slice(p),\n            schema,\n            subdoc ? mpath.get(trypath, subdoc) : null,\n            nestedPath.concat(parts.slice(0, p))\n          );\n\n          if (ret != null) {\n            ret.$parentSchemaDocArray = ret.$parentSchemaDocArray ||\n              (schema.$isSingleNested ? null : schema);\n            return ret;\n          }\n        }\n      }\n      return foundschema;\n    }\n  }\n  // look for arrays\n  const parts = path.split('.');\n  for (let i = 0; i < parts.length; ++i) {\n    if (parts[i] === '$') {\n      // Re: gh-5628, because `schema.path()` doesn't take $ into account.\n      parts[i] = '0';\n    }\n  }\n  return search(parts, schema, doc, []);\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7080, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/getModelsMapForPopulate.js"],"sourcesContent":["'use strict';\n\nconst MongooseError = require('../../error/index');\nconst SkipPopulateValue = require('./skipPopulateValue');\nconst clone = require('../clone');\nconst get = require('../get');\nconst getDiscriminatorByValue = require('../discriminator/getDiscriminatorByValue');\nconst getConstructorName = require('../getConstructorName');\nconst getSchemaTypes = require('./getSchemaTypes');\nconst getVirtual = require('./getVirtual');\nconst lookupLocalFields = require('./lookupLocalFields');\nconst mpath = require('mpath');\nconst modelNamesFromRefPath = require('./modelNamesFromRefPath');\nconst utils = require('../../utils');\n\nconst modelSymbol = require('../symbols').modelSymbol;\nconst populateModelSymbol = require('../symbols').populateModelSymbol;\nconst schemaMixedSymbol = require('../../schema/symbols').schemaMixedSymbol;\nconst StrictPopulate = require('../../error/strictPopulate');\n\nmodule.exports = function getModelsMapForPopulate(model, docs, options) {\n  let doc;\n  const len = docs.length;\n  const map = [];\n  const modelNameFromQuery = options.model && options.model.modelName || options.model;\n  let schema;\n  let refPath;\n  let modelNames;\n  const available = {};\n\n  const modelSchema = model.schema;\n\n  // Populating a nested path should always be a no-op re: #9073.\n  // People shouldn't do this, but apparently they do.\n  if (options._localModel != null && options._localModel.schema.nested[options.path]) {\n    return [];\n  }\n\n  const _virtualRes = getVirtual(model.schema, options.path);\n  const virtual = _virtualRes == null ? null : _virtualRes.virtual;\n  if (virtual != null) {\n    return _virtualPopulate(model, docs, options, _virtualRes);\n  }\n\n  let allSchemaTypes = getSchemaTypes(model, modelSchema, null, options.path);\n  allSchemaTypes = Array.isArray(allSchemaTypes) ? allSchemaTypes : [allSchemaTypes].filter(v => v != null);\n\n  const isStrictPopulateDisabled = options.strictPopulate === false || options.options?.strictPopulate === false;\n  if (!isStrictPopulateDisabled && allSchemaTypes.length === 0 && options._localModel != null) {\n    return new StrictPopulate(options._fullPath || options.path);\n  }\n\n  for (let i = 0; i < len; i++) {\n    doc = docs[i];\n    let justOne = null;\n\n    if (doc.$__ != null && doc.populated(options.path)) {\n      const forceRepopulate = options.forceRepopulate != null ? options.forceRepopulate : doc.constructor.base.options.forceRepopulate;\n      if (forceRepopulate === false) {\n        continue;\n      }\n    }\n\n    const docSchema = doc != null && doc.$__ != null ? doc.$__schema : modelSchema;\n    schema = getSchemaTypes(model, docSchema, doc, options.path);\n\n    // Special case: populating a path that's a DocumentArray unless\n    // there's an explicit `ref` or `refPath` re: gh-8946\n    if (schema != null &&\n        schema.$isMongooseDocumentArray &&\n        schema.options.ref == null &&\n        schema.options.refPath == null) {\n      continue;\n    }\n    const isUnderneathDocArray = schema && schema.$parentSchemaDocArray;\n    if (isUnderneathDocArray && get(options, 'options.sort') != null) {\n      return new MongooseError('Cannot populate with `sort` on path ' + options.path +\n        ' because it is a subproperty of a document array');\n    }\n\n    modelNames = null;\n    let isRefPath = false;\n    let normalizedRefPath = null;\n    let schemaOptions = null;\n    let modelNamesInOrder = null;\n\n    if (schema != null && schema.instance === 'Embedded') {\n      if (schema.options.ref) {\n        const data = {\n          localField: options.path + '._id',\n          foreignField: '_id',\n          justOne: true\n        };\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n\n        const unpopulatedValue = mpath.get(options.path, doc);\n        const id = mpath.get('_id', unpopulatedValue);\n        addModelNamesToMap(model, map, available, res.modelNames, options, data, id, doc, schemaOptions, unpopulatedValue);\n      }\n      // No-op if no `ref` set. See gh-11538\n      continue;\n    }\n\n    if (Array.isArray(schema)) {\n      const schemasArray = schema;\n      for (const _schema of schemasArray) {\n        let _modelNames;\n        let res;\n        try {\n          res = _getModelNames(doc, _schema, modelNameFromQuery, model);\n          _modelNames = res.modelNames;\n          isRefPath = isRefPath || res.isRefPath;\n          normalizedRefPath = normalizedRefPath || res.refPath;\n          justOne = res.justOne;\n        } catch (error) {\n          return error;\n        }\n\n        if (isRefPath && !res.isRefPath) {\n          continue;\n        }\n        if (!_modelNames) {\n          continue;\n        }\n        modelNames = modelNames || [];\n        for (const modelName of _modelNames) {\n          if (modelNames.indexOf(modelName) === -1) {\n            modelNames.push(modelName);\n          }\n        }\n      }\n    } else {\n      try {\n        const res = _getModelNames(doc, schema, modelNameFromQuery, model);\n        modelNames = res.modelNames;\n        isRefPath = res.isRefPath;\n        normalizedRefPath = normalizedRefPath || res.refPath;\n        justOne = res.justOne;\n        schemaOptions = get(schema, 'options.populate', null);\n        // Dedupe, because `refPath` can return duplicates of the same model name,\n        // and that causes perf issues.\n        if (isRefPath) {\n          modelNamesInOrder = modelNames;\n          modelNames = Array.from(new Set(modelNames));\n        }\n      } catch (error) {\n        return error;\n      }\n\n      if (!modelNames) {\n        continue;\n      }\n    }\n\n    const data = {};\n    const localField = options.path;\n    const foreignField = '_id';\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    } else if (schema && !schema[schemaMixedSymbol]) {\n      // Skip Mixed types because we explicitly don't do casting on those.\n      if (options.path.endsWith('.' + schema.path) || options.path === schema.path) {\n        justOne = Array.isArray(schema) ?\n          schema.every(schema => !schema.$isMongooseArray) :\n          !schema.$isMongooseArray;\n      }\n    }\n\n    if (!modelNames) {\n      continue;\n    }\n\n    data.isVirtual = false;\n    data.justOne = justOne;\n    data.localField = localField;\n    data.foreignField = foreignField;\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, null, schema);\n\n    const id = String(utils.getValue(foreignField, doc));\n    options._docs[id] = Array.isArray(ret) ? ret.slice() : ret;\n\n    let match = get(options, 'match', null);\n\n    const hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc);\n    }\n    throwOn$where(match);\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n    data.isRefPath = isRefPath;\n    data.modelNamesInOrder = modelNamesInOrder;\n\n    if (isRefPath) {\n      const embeddedDiscriminatorModelNames = _findRefPathForDiscriminators(doc,\n        modelSchema, data, options, normalizedRefPath, ret);\n\n      modelNames = embeddedDiscriminatorModelNames || modelNames;\n    }\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions);\n    } catch (err) {\n      return err;\n    }\n  }\n  return map;\n\n  function _getModelNames(doc, schema, modelNameFromQuery, model) {\n    let modelNames;\n    let isRefPath = false;\n    let justOne = null;\n\n    const originalSchema = schema;\n    if (schema && schema.instance === 'Array') {\n      schema = schema.caster;\n    }\n    if (schema && schema.$isSchemaMap) {\n      schema = schema.$__schemaType;\n    }\n\n    const ref = schema && schema.options && schema.options.ref;\n    refPath = schema && schema.options && schema.options.refPath;\n    if (schema != null &&\n        schema[schemaMixedSymbol] &&\n        !ref &&\n        !refPath &&\n        !modelNameFromQuery) {\n      return { modelNames: null };\n    }\n\n    if (modelNameFromQuery) {\n      modelNames = [modelNameFromQuery]; // query options\n    } else if (refPath != null) {\n      if (typeof refPath === 'function') {\n        const subdocPath = options.path.slice(0, options.path.length - schema.path.length - 1);\n        const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n        const subdocsBeingPopulated = Array.isArray(vals) ?\n          utils.array.flatten(vals) :\n          (vals ? [vals] : []);\n\n        modelNames = new Set();\n        for (const subdoc of subdocsBeingPopulated) {\n          refPath = refPath.call(subdoc, subdoc, options.path);\n          modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n            forEach(name => modelNames.add(name));\n        }\n        modelNames = Array.from(modelNames);\n      } else {\n        modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n      }\n\n      isRefPath = true;\n    } else {\n      let ref;\n      let refPath;\n      let schemaForCurrentDoc;\n      let discriminatorValue;\n      let modelForCurrentDoc = model;\n      const discriminatorKey = model.schema.options.discriminatorKey;\n\n      if (!schema && discriminatorKey && (discriminatorValue = utils.getValue(discriminatorKey, doc))) {\n        // `modelNameForFind` is the discriminator value, so we might need\n        // find the discriminated model name\n        const discriminatorModel = getDiscriminatorByValue(model.discriminators, discriminatorValue) || model;\n        if (discriminatorModel != null) {\n          modelForCurrentDoc = discriminatorModel;\n        } else {\n          try {\n            modelForCurrentDoc = _getModelFromConn(model.db, discriminatorValue);\n          } catch (error) {\n            return error;\n          }\n        }\n\n        schemaForCurrentDoc = modelForCurrentDoc.schema._getSchema(options.path);\n\n        if (schemaForCurrentDoc && schemaForCurrentDoc.caster) {\n          schemaForCurrentDoc = schemaForCurrentDoc.caster;\n        }\n      } else {\n        schemaForCurrentDoc = schema;\n      }\n\n      if (originalSchema && originalSchema.path.endsWith('.$*')) {\n        justOne = !originalSchema.$isMongooseArray && !originalSchema._arrayPath;\n      } else if (schemaForCurrentDoc != null) {\n        justOne = !schemaForCurrentDoc.$isMongooseArray && !schemaForCurrentDoc._arrayPath;\n      }\n\n      if ((ref = get(schemaForCurrentDoc, 'options.ref')) != null) {\n        if (schemaForCurrentDoc != null &&\n            typeof ref === 'function' &&\n            options.path.endsWith('.' + schemaForCurrentDoc.path)) {\n          // Ensure correct context for ref functions: subdoc, not top-level doc. See gh-8469\n          modelNames = new Set();\n\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n          for (const subdoc of subdocsBeingPopulated) {\n            modelNames.add(handleRefFunction(ref, subdoc));\n          }\n\n          if (subdocsBeingPopulated.length === 0) {\n            modelNames = [handleRefFunction(ref, doc)];\n          } else {\n            modelNames = Array.from(modelNames);\n          }\n        } else {\n          ref = handleRefFunction(ref, doc);\n          modelNames = [ref];\n        }\n      } else if ((schemaForCurrentDoc = get(schema, 'options.refPath')) != null) {\n        isRefPath = true;\n        if (typeof refPath === 'function') {\n          const subdocPath = options.path.slice(0, options.path.length - schemaForCurrentDoc.path.length - 1);\n          const vals = mpath.get(subdocPath, doc, lookupLocalFields);\n          const subdocsBeingPopulated = Array.isArray(vals) ?\n            utils.array.flatten(vals) :\n            (vals ? [vals] : []);\n\n          modelNames = new Set();\n          for (const subdoc of subdocsBeingPopulated) {\n            refPath = refPath.call(subdoc, subdoc, options.path);\n            modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection).\n              forEach(name => modelNames.add(name));\n          }\n          modelNames = Array.from(modelNames);\n        } else {\n          modelNames = modelNamesFromRefPath(refPath, doc, options.path, modelSchema, options._queryProjection);\n        }\n      }\n    }\n\n    if (!modelNames) {\n      // `Model.populate()` on a POJO with no known local model. Default to using the `Model`\n      if (options._localModel == null) {\n        modelNames = [model.modelName];\n      } else {\n        return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n      }\n    }\n\n    if (!Array.isArray(modelNames)) {\n      modelNames = [modelNames];\n    }\n\n    return { modelNames: modelNames, justOne: justOne, isRefPath: isRefPath, refPath: refPath };\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction _virtualPopulate(model, docs, options, _virtualRes) {\n  const map = [];\n  const available = {};\n  const virtual = _virtualRes.virtual;\n\n  for (const doc of docs) {\n    let modelNames = null;\n    const data = {};\n\n    // localField and foreignField\n    let localField;\n    const virtualPrefix = _virtualRes.nestedSchemaPath ?\n      _virtualRes.nestedSchemaPath + '.' : '';\n    if (typeof options.localField === 'string') {\n      localField = options.localField;\n    } else if (typeof virtual.options.localField === 'function') {\n      localField = virtualPrefix + virtual.options.localField.call(doc, doc);\n    } else if (Array.isArray(virtual.options.localField)) {\n      localField = virtual.options.localField.map(field => virtualPrefix + field);\n    } else {\n      localField = virtualPrefix + virtual.options.localField;\n    }\n    data.count = virtual.options.count;\n\n    if (virtual.options.skip != null && !options.hasOwnProperty('skip')) {\n      options.skip = virtual.options.skip;\n    }\n    if (virtual.options.limit != null && !options.hasOwnProperty('limit')) {\n      options.limit = virtual.options.limit;\n    }\n    if (virtual.options.perDocumentLimit != null && !options.hasOwnProperty('perDocumentLimit')) {\n      options.perDocumentLimit = virtual.options.perDocumentLimit;\n    }\n    let foreignField = virtual.options.foreignField;\n\n    if (!localField || !foreignField) {\n      return new MongooseError(`Cannot populate virtual \\`${options.path}\\` on model \\`${model.modelName}\\`, because options \\`localField\\` and / or \\`foreignField\\` are missing`);\n    }\n\n    if (typeof localField === 'function') {\n      localField = localField.call(doc, doc);\n    }\n    if (typeof foreignField === 'function') {\n      foreignField = foreignField.call(doc, doc);\n    }\n\n    data.isRefPath = false;\n\n    // `justOne = null` means we don't know from the schema whether the end\n    // result should be an array or a single doc. This can result from\n    // populating a POJO using `Model.populate()`\n    let justOne = null;\n    if ('justOne' in options && options.justOne !== void 0) {\n      justOne = options.justOne;\n    }\n\n    modelNames = virtual._getModelNamesForPopulate(doc);\n    if (virtual.options.refPath) {\n      justOne = !!virtual.options.justOne;\n      data.isRefPath = true;\n    } else if (virtual.options.ref) {\n      justOne = !!virtual.options.justOne;\n    }\n\n    data.isVirtual = true;\n    data.virtual = virtual;\n    data.justOne = justOne;\n\n    // `match`\n    const baseMatch = get(data, 'virtual.options.match', null) ||\n      get(data, 'virtual.options.options.match', null);\n    let match = get(options, 'match', null) || baseMatch;\n\n    let hasMatchFunction = typeof match === 'function';\n    if (hasMatchFunction) {\n      match = match.call(doc, doc, data.virtual);\n    }\n\n    if (Array.isArray(localField) && Array.isArray(foreignField) && localField.length === foreignField.length) {\n      match = Object.assign({}, match);\n      for (let i = 1; i < localField.length; ++i) {\n        match[foreignField[i]] = convertTo_id(mpath.get(localField[i], doc, lookupLocalFields), model.schema);\n        hasMatchFunction = true;\n      }\n\n      localField = localField[0];\n      foreignField = foreignField[0];\n    }\n    data.localField = localField;\n    data.foreignField = foreignField;\n    data.match = match;\n    data.hasMatchFunction = hasMatchFunction;\n\n    throwOn$where(match);\n\n    // Get local fields\n    const ret = _getLocalFieldValues(doc, localField, model, options, virtual);\n\n    try {\n      addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc);\n    } catch (err) {\n      return err;\n    }\n  }\n\n  return map;\n}\n\n/*!\n * ignore\n */\n\nfunction addModelNamesToMap(model, map, available, modelNames, options, data, ret, doc, schemaOptions, unpopulatedValue) {\n  // `PopulateOptions#connection`: if the model is passed as a string, the\n  // connection matters because different connections have different models.\n  const connection = options.connection != null ? options.connection : model.db;\n\n  unpopulatedValue = unpopulatedValue === void 0 ? ret : unpopulatedValue;\n  if (Array.isArray(unpopulatedValue)) {\n    unpopulatedValue = utils.cloneArrays(unpopulatedValue);\n  }\n\n  if (modelNames == null) {\n    return;\n  }\n\n  const flatModelNames = utils.array.flatten(modelNames);\n  let k = flatModelNames.length;\n  while (k--) {\n    let modelName = flatModelNames[k];\n    if (modelName == null) {\n      continue;\n    }\n\n    let Model;\n    if (options.model && options.model[modelSymbol]) {\n      Model = options.model;\n    } else if (modelName[modelSymbol]) {\n      Model = modelName;\n      modelName = Model.modelName;\n    } else {\n      try {\n        Model = _getModelFromConn(connection, modelName);\n      } catch (err) {\n        if (ret !== void 0) {\n          throw err;\n        }\n        Model = null;\n      }\n    }\n\n    let ids = ret;\n\n    const modelNamesForRefPath = data.modelNamesInOrder ? data.modelNamesInOrder : modelNames;\n    if (data.isRefPath && Array.isArray(ret) && ret.length === modelNamesForRefPath.length) {\n      ids = matchIdsToRefPaths(ret, modelNamesForRefPath, modelName);\n    }\n\n    const perDocumentLimit = options.perDocumentLimit == null ?\n      get(options, 'options.perDocumentLimit', null) :\n      options.perDocumentLimit;\n\n    if (!available[modelName] || perDocumentLimit != null) {\n      const currentOptions = {\n        model: Model\n      };\n      if (data.isVirtual && get(data.virtual, 'options.options')) {\n        currentOptions.options = clone(data.virtual.options.options);\n      } else if (schemaOptions != null) {\n        currentOptions.options = Object.assign({}, schemaOptions);\n      }\n      utils.merge(currentOptions, options);\n\n      // Used internally for checking what model was used to populate this\n      // path.\n      options[populateModelSymbol] = Model;\n      currentOptions[populateModelSymbol] = Model;\n      available[modelName] = {\n        model: Model,\n        options: currentOptions,\n        match: data.hasMatchFunction ? [data.match] : data.match,\n        docs: [doc],\n        ids: [ids],\n        allIds: [ret],\n        unpopulatedValues: [unpopulatedValue],\n        localField: new Set([data.localField]),\n        foreignField: new Set([data.foreignField]),\n        justOne: data.justOne,\n        isVirtual: data.isVirtual,\n        virtual: data.virtual,\n        count: data.count,\n        [populateModelSymbol]: Model\n      };\n      map.push(available[modelName]);\n    } else {\n      available[modelName].localField.add(data.localField);\n      available[modelName].foreignField.add(data.foreignField);\n      available[modelName].docs.push(doc);\n      available[modelName].ids.push(ids);\n      available[modelName].allIds.push(ret);\n      available[modelName].unpopulatedValues.push(unpopulatedValue);\n      if (data.hasMatchFunction) {\n        available[modelName].match.push(data.match);\n      }\n    }\n  }\n}\n\nfunction _getModelFromConn(conn, modelName) {\n  /* If this connection has a parent from `useDb()`, bubble up to parent's models */\n  if (conn.models[modelName] == null && conn._parent != null) {\n    return _getModelFromConn(conn._parent, modelName);\n  }\n\n  return conn.model(modelName);\n}\n\nfunction matchIdsToRefPaths(ids, refPaths, refPathToFind) {\n  if (!Array.isArray(refPaths)) {\n    return refPaths === refPathToFind\n      ? Array.isArray(ids)\n        ? utils.array.flatten(ids)\n        : [ids]\n      : [];\n  }\n  if (Array.isArray(ids) && Array.isArray(refPaths)) {\n    return ids.flatMap((id, index) => matchIdsToRefPaths(id, refPaths[index], refPathToFind));\n  }\n  return [];\n}\n\n/*!\n * ignore\n */\n\nfunction handleRefFunction(ref, doc) {\n  if (typeof ref === 'function' && !ref[modelSymbol]) {\n    return ref.call(doc, doc);\n  }\n  return ref;\n}\n\n/*!\n * ignore\n */\n\nfunction _getLocalFieldValues(doc, localField, model, options, virtual, schema) {\n  // Get Local fields\n  const localFieldPathType = model.schema._getPathType(localField);\n  const localFieldPath = localFieldPathType === 'real' ?\n    model.schema.path(localField) :\n    localFieldPathType.schema;\n  const localFieldGetters = localFieldPath && localFieldPath.getters ?\n    localFieldPath.getters : [];\n\n  localField = localFieldPath != null && localFieldPath.instance === 'Embedded' ? localField + '._id' : localField;\n\n  const _populateOptions = get(options, 'options', {});\n\n  const getters = 'getters' in _populateOptions ?\n    _populateOptions.getters :\n    get(virtual, 'options.getters', false);\n  if (localFieldGetters.length !== 0 && getters) {\n    const hydratedDoc = (doc.$__ != null) ? doc : model.hydrate(doc);\n    const localFieldValue = utils.getValue(localField, doc);\n    if (Array.isArray(localFieldValue)) {\n      const localFieldHydratedValue = utils.getValue(localField.split('.').slice(0, -1), hydratedDoc);\n      return localFieldValue.map((localFieldArrVal, localFieldArrIndex) =>\n        localFieldPath.applyGetters(localFieldArrVal, localFieldHydratedValue[localFieldArrIndex]));\n    } else {\n      return localFieldPath.applyGetters(localFieldValue, hydratedDoc);\n    }\n  } else {\n    return convertTo_id(mpath.get(localField, doc, lookupLocalFields), schema);\n  }\n}\n\n/**\n * Retrieve the _id of `val` if a Document or Array of Documents.\n *\n * @param {Array|Document|Any} val\n * @param {Schema} schema\n * @return {Array|Document|Any}\n * @api private\n */\n\nfunction convertTo_id(val, schema) {\n  if (val != null && val.$__ != null) {\n    return val._doc._id;\n  }\n  if (val != null && val._id != null && (schema == null || !schema.$isSchemaMap)) {\n    return val._id;\n  }\n\n  if (Array.isArray(val)) {\n    const rawVal = val.__array != null ? val.__array : val;\n    for (let i = 0; i < rawVal.length; ++i) {\n      if (rawVal[i] != null && rawVal[i].$__ != null) {\n        rawVal[i] = rawVal[i]._doc._id;\n      }\n    }\n    if (utils.isMongooseArray(val) && val.$schema()) {\n      return val.$schema()._castForPopulate(val, val.$parent());\n    }\n\n    return [].concat(val);\n  }\n\n  // `populate('map')` may be an object if populating on a doc that hasn't\n  // been hydrated yet\n  if (getConstructorName(val) === 'Object' &&\n      // The intent here is we should only flatten the object if we expect\n      // to get a Map in the end. Avoid doing this for mixed types.\n      (schema == null || schema[schemaMixedSymbol] == null)) {\n    const ret = [];\n    for (const key of Object.keys(val)) {\n      ret.push(val[key]);\n    }\n    return ret;\n  }\n  // If doc has already been hydrated, e.g. `doc.populate('map')`\n  // then `val` will already be a map\n  if (val instanceof Map) {\n    return Array.from(val.values());\n  }\n\n  return val;\n}\n\n/*!\n * ignore\n */\n\nfunction _findRefPathForDiscriminators(doc, modelSchema, data, options, normalizedRefPath, ret) {\n  // Re: gh-8452. Embedded discriminators may not have `refPath`, so clear\n  // out embedded discriminator docs that don't have a `refPath` on the\n  // populated path.\n  if (!data.isRefPath || normalizedRefPath == null) {\n    return;\n  }\n\n  const pieces = normalizedRefPath.split('.');\n  let cur = '';\n  let modelNames = void 0;\n  for (let i = 0; i < pieces.length; ++i) {\n    const piece = pieces[i];\n    cur = cur + (cur.length === 0 ? '' : '.') + piece;\n    const schematype = modelSchema.path(cur);\n    if (schematype != null &&\n        schematype.$isMongooseArray &&\n        schematype.caster.discriminators != null &&\n        Object.keys(schematype.caster.discriminators).length !== 0) {\n      const subdocs = utils.getValue(cur, doc);\n      const remnant = options.path.substring(cur.length + 1);\n      const discriminatorKey = schematype.caster.schema.options.discriminatorKey;\n      modelNames = [];\n      for (const subdoc of subdocs) {\n        const discriminatorName = utils.getValue(discriminatorKey, subdoc);\n        const discriminator = schematype.caster.discriminators[discriminatorName];\n        const discriminatorSchema = discriminator && discriminator.schema;\n        if (discriminatorSchema == null) {\n          continue;\n        }\n        const _path = discriminatorSchema.path(remnant);\n        if (_path == null || _path.options.refPath == null) {\n          const docValue = utils.getValue(data.localField.substring(cur.length + 1), subdoc);\n          ret.forEach((v, i) => {\n            if (v === docValue) {\n              ret[i] = SkipPopulateValue(v);\n            }\n          });\n          continue;\n        }\n        const modelName = utils.getValue(pieces.slice(i + 1).join('.'), subdoc);\n        modelNames.push(modelName);\n      }\n    }\n  }\n\n  return modelNames;\n}\n\n/**\n * Throw an error if there are any $where keys\n */\n\nfunction throwOn$where(match) {\n  if (match == null) {\n    return;\n  }\n  if (typeof match !== 'object') {\n    return;\n  }\n  for (const key of Object.keys(match)) {\n    if (key === '$where') {\n      throw new MongooseError('Cannot use $where filter with populate() match');\n    }\n    if (match[key] != null && typeof match[key] === 'object') {\n      throwOn$where(match[key]);\n    }\n  }\n}\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN,MAAM,cAAc,6GAAsB,WAAW;AACrD,MAAM,sBAAsB,6GAAsB,mBAAmB;AACrE,MAAM,oBAAoB,4GAAgC,iBAAiB;AAC3E,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,wBAAwB,KAAK,EAAE,IAAI,EAAE,OAAO;IACpE,IAAI;IACJ,MAAM,MAAM,KAAK,MAAM;IACvB,MAAM,MAAM,EAAE;IACd,MAAM,qBAAqB,QAAQ,KAAK,IAAI,QAAQ,KAAK,CAAC,SAAS,IAAI,QAAQ,KAAK;IACpF,IAAI;IACJ,IAAI;IACJ,IAAI;IACJ,MAAM,YAAY,CAAC;IAEnB,MAAM,cAAc,MAAM,MAAM;IAEhC,+DAA+D;IAC/D,oDAAoD;IACpD,IAAI,QAAQ,WAAW,IAAI,QAAQ,QAAQ,WAAW,CAAC,MAAM,CAAC,MAAM,CAAC,QAAQ,IAAI,CAAC,EAAE;QAClF,OAAO,EAAE;IACX;IAEA,MAAM,cAAc,WAAW,MAAM,MAAM,EAAE,QAAQ,IAAI;IACzD,MAAM,UAAU,eAAe,OAAO,OAAO,YAAY,OAAO;IAChE,IAAI,WAAW,MAAM;QACnB,OAAO,iBAAiB,OAAO,MAAM,SAAS;IAChD;IAEA,IAAI,iBAAiB,eAAe,OAAO,aAAa,MAAM,QAAQ,IAAI;IAC1E,iBAAiB,MAAM,OAAO,CAAC,kBAAkB,iBAAiB;QAAC;KAAe,CAAC,MAAM,CAAC,CAAA,IAAK,KAAK;IAEpG,MAAM,2BAA2B,QAAQ,cAAc,KAAK,SAAS,QAAQ,OAAO,EAAE,mBAAmB;IACzG,IAAI,CAAC,4BAA4B,eAAe,MAAM,KAAK,KAAK,QAAQ,WAAW,IAAI,MAAM;QAC3F,OAAO,IAAI,eAAe,QAAQ,SAAS,IAAI,QAAQ,IAAI;IAC7D;IAEA,IAAK,IAAI,IAAI,GAAG,IAAI,KAAK,IAAK;QAC5B,MAAM,IAAI,CAAC,EAAE;QACb,IAAI,UAAU;QAEd,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAI,SAAS,CAAC,QAAQ,IAAI,GAAG;YAClD,MAAM,kBAAkB,QAAQ,eAAe,IAAI,OAAO,QAAQ,eAAe,GAAG,IAAI,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,eAAe;YAChI,IAAI,oBAAoB,OAAO;gBAC7B;YACF;QACF;QAEA,MAAM,YAAY,OAAO,QAAQ,IAAI,GAAG,IAAI,OAAO,IAAI,SAAS,GAAG;QACnE,SAAS,eAAe,OAAO,WAAW,KAAK,QAAQ,IAAI;QAE3D,gEAAgE;QAChE,qDAAqD;QACrD,IAAI,UAAU,QACV,OAAO,wBAAwB,IAC/B,OAAO,OAAO,CAAC,GAAG,IAAI,QACtB,OAAO,OAAO,CAAC,OAAO,IAAI,MAAM;YAClC;QACF;QACA,MAAM,uBAAuB,UAAU,OAAO,qBAAqB;QACnE,IAAI,wBAAwB,IAAI,SAAS,mBAAmB,MAAM;YAChE,OAAO,IAAI,cAAc,yCAAyC,QAAQ,IAAI,GAC5E;QACJ;QAEA,aAAa;QACb,IAAI,YAAY;QAChB,IAAI,oBAAoB;QACxB,IAAI,gBAAgB;QACpB,IAAI,oBAAoB;QAExB,IAAI,UAAU,QAAQ,OAAO,QAAQ,KAAK,YAAY;YACpD,IAAI,OAAO,OAAO,CAAC,GAAG,EAAE;gBACtB,MAAM,OAAO;oBACX,YAAY,QAAQ,IAAI,GAAG;oBAC3B,cAAc;oBACd,SAAS;gBACX;gBACA,MAAM,MAAM,eAAe,KAAK,QAAQ,oBAAoB;gBAE5D,MAAM,mBAAmB,MAAM,GAAG,CAAC,QAAQ,IAAI,EAAE;gBACjD,MAAM,KAAK,MAAM,GAAG,CAAC,OAAO;gBAC5B,mBAAmB,OAAO,KAAK,WAAW,IAAI,UAAU,EAAE,SAAS,MAAM,IAAI,KAAK,eAAe;YACnG;YAEA;QACF;QAEA,IAAI,MAAM,OAAO,CAAC,SAAS;YACzB,MAAM,eAAe;YACrB,KAAK,MAAM,WAAW,aAAc;gBAClC,IAAI;gBACJ,IAAI;gBACJ,IAAI;oBACF,MAAM,eAAe,KAAK,SAAS,oBAAoB;oBACvD,cAAc,IAAI,UAAU;oBAC5B,YAAY,aAAa,IAAI,SAAS;oBACtC,oBAAoB,qBAAqB,IAAI,OAAO;oBACpD,UAAU,IAAI,OAAO;gBACvB,EAAE,OAAO,OAAO;oBACd,OAAO;gBACT;gBAEA,IAAI,aAAa,CAAC,IAAI,SAAS,EAAE;oBAC/B;gBACF;gBACA,IAAI,CAAC,aAAa;oBAChB;gBACF;gBACA,aAAa,cAAc,EAAE;gBAC7B,KAAK,MAAM,aAAa,YAAa;oBACnC,IAAI,WAAW,OAAO,CAAC,eAAe,CAAC,GAAG;wBACxC,WAAW,IAAI,CAAC;oBAClB;gBACF;YACF;QACF,OAAO;YACL,IAAI;gBACF,MAAM,MAAM,eAAe,KAAK,QAAQ,oBAAoB;gBAC5D,aAAa,IAAI,UAAU;gBAC3B,YAAY,IAAI,SAAS;gBACzB,oBAAoB,qBAAqB,IAAI,OAAO;gBACpD,UAAU,IAAI,OAAO;gBACrB,gBAAgB,IAAI,QAAQ,oBAAoB;gBAChD,0EAA0E;gBAC1E,+BAA+B;gBAC/B,IAAI,WAAW;oBACb,oBAAoB;oBACpB,aAAa,MAAM,IAAI,CAAC,IAAI,IAAI;gBAClC;YACF,EAAE,OAAO,OAAO;gBACd,OAAO;YACT;YAEA,IAAI,CAAC,YAAY;gBACf;YACF;QACF;QAEA,MAAM,OAAO,CAAC;QACd,MAAM,aAAa,QAAQ,IAAI;QAC/B,MAAM,eAAe;QAErB,uEAAuE;QACvE,kEAAkE;QAClE,6CAA6C;QAC7C,IAAI,aAAa,WAAW,QAAQ,OAAO,KAAK,KAAK,GAAG;YACtD,UAAU,QAAQ,OAAO;QAC3B,OAAO,IAAI,UAAU,CAAC,MAAM,CAAC,kBAAkB,EAAE;YAC/C,oEAAoE;YACpE,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,OAAO,IAAI,KAAK,QAAQ,IAAI,KAAK,OAAO,IAAI,EAAE;gBAC5E,UAAU,MAAM,OAAO,CAAC,UACtB,OAAO,KAAK,CAAC,CAAA,SAAU,CAAC,OAAO,gBAAgB,IAC/C,CAAC,OAAO,gBAAgB;YAC5B;QACF;QAEA,IAAI,CAAC,YAAY;YACf;QACF;QAEA,KAAK,SAAS,GAAG;QACjB,KAAK,OAAO,GAAG;QACf,KAAK,UAAU,GAAG;QAClB,KAAK,YAAY,GAAG;QAEpB,mBAAmB;QACnB,MAAM,MAAM,qBAAqB,KAAK,YAAY,OAAO,SAAS,MAAM;QAExE,MAAM,KAAK,OAAO,MAAM,QAAQ,CAAC,cAAc;QAC/C,QAAQ,KAAK,CAAC,GAAG,GAAG,MAAM,OAAO,CAAC,OAAO,IAAI,KAAK,KAAK;QAEvD,IAAI,QAAQ,IAAI,SAAS,SAAS;QAElC,MAAM,mBAAmB,OAAO,UAAU;QAC1C,IAAI,kBAAkB;YACpB,QAAQ,MAAM,IAAI,CAAC,KAAK;QAC1B;QACA,cAAc;QACd,KAAK,KAAK,GAAG;QACb,KAAK,gBAAgB,GAAG;QACxB,KAAK,SAAS,GAAG;QACjB,KAAK,iBAAiB,GAAG;QAEzB,IAAI,WAAW;YACb,MAAM,kCAAkC,8BAA8B,KACpE,aAAa,MAAM,SAAS,mBAAmB;YAEjD,aAAa,mCAAmC;QAClD;QAEA,IAAI;YACF,mBAAmB,OAAO,KAAK,WAAW,YAAY,SAAS,MAAM,KAAK,KAAK;QACjF,EAAE,OAAO,KAAK;YACZ,OAAO;QACT;IACF;IACA,OAAO;;;IAEP,SAAS,eAAe,GAAG,EAAE,MAAM,EAAE,kBAAkB,EAAE,KAAK;QAC5D,IAAI;QACJ,IAAI,YAAY;QAChB,IAAI,UAAU;QAEd,MAAM,iBAAiB;QACvB,IAAI,UAAU,OAAO,QAAQ,KAAK,SAAS;YACzC,SAAS,OAAO,MAAM;QACxB;QACA,IAAI,UAAU,OAAO,YAAY,EAAE;YACjC,SAAS,OAAO,aAAa;QAC/B;QAEA,MAAM,MAAM,UAAU,OAAO,OAAO,IAAI,OAAO,OAAO,CAAC,GAAG;QAC1D,UAAU,UAAU,OAAO,OAAO,IAAI,OAAO,OAAO,CAAC,OAAO;QAC5D,IAAI,UAAU,QACV,MAAM,CAAC,kBAAkB,IACzB,CAAC,OACD,CAAC,WACD,CAAC,oBAAoB;YACvB,OAAO;gBAAE,YAAY;YAAK;QAC5B;QAEA,IAAI,oBAAoB;YACtB,aAAa;gBAAC;aAAmB,EAAE,gBAAgB;QACrD,OAAO,IAAI,WAAW,MAAM;YAC1B,IAAI,OAAO,YAAY,YAAY;gBACjC,MAAM,aAAa,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,QAAQ,IAAI,CAAC,MAAM,GAAG,OAAO,IAAI,CAAC,MAAM,GAAG;gBACpF,MAAM,OAAO,MAAM,GAAG,CAAC,YAAY,KAAK;gBACxC,MAAM,wBAAwB,MAAM,OAAO,CAAC,QAC1C,MAAM,KAAK,CAAC,OAAO,CAAC,QACnB,OAAO;oBAAC;iBAAK,GAAG,EAAE;gBAErB,aAAa,IAAI;gBACjB,KAAK,MAAM,UAAU,sBAAuB;oBAC1C,UAAU,QAAQ,IAAI,CAAC,QAAQ,QAAQ,QAAQ,IAAI;oBACnD,sBAAsB,SAAS,KAAK,QAAQ,IAAI,EAAE,aAAa,QAAQ,gBAAgB,EACrF,OAAO,CAAC,CAAA,OAAQ,WAAW,GAAG,CAAC;gBACnC;gBACA,aAAa,MAAM,IAAI,CAAC;YAC1B,OAAO;gBACL,aAAa,sBAAsB,SAAS,KAAK,QAAQ,IAAI,EAAE,aAAa,QAAQ,gBAAgB;YACtG;YAEA,YAAY;QACd,OAAO;YACL,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI;YACJ,IAAI,qBAAqB;YACzB,MAAM,mBAAmB,MAAM,MAAM,CAAC,OAAO,CAAC,gBAAgB;YAE9D,IAAI,CAAC,UAAU,oBAAoB,CAAC,qBAAqB,MAAM,QAAQ,CAAC,kBAAkB,IAAI,GAAG;gBAC/F,kEAAkE;gBAClE,oCAAoC;gBACpC,MAAM,qBAAqB,wBAAwB,MAAM,cAAc,EAAE,uBAAuB;gBAChG,IAAI,sBAAsB,MAAM;oBAC9B,qBAAqB;gBACvB,OAAO;oBACL,IAAI;wBACF,qBAAqB,kBAAkB,MAAM,EAAE,EAAE;oBACnD,EAAE,OAAO,OAAO;wBACd,OAAO;oBACT;gBACF;gBAEA,sBAAsB,mBAAmB,MAAM,CAAC,UAAU,CAAC,QAAQ,IAAI;gBAEvE,IAAI,uBAAuB,oBAAoB,MAAM,EAAE;oBACrD,sBAAsB,oBAAoB,MAAM;gBAClD;YACF,OAAO;gBACL,sBAAsB;YACxB;YAEA,IAAI,kBAAkB,eAAe,IAAI,CAAC,QAAQ,CAAC,QAAQ;gBACzD,UAAU,CAAC,eAAe,gBAAgB,IAAI,CAAC,eAAe,UAAU;YAC1E,OAAO,IAAI,uBAAuB,MAAM;gBACtC,UAAU,CAAC,oBAAoB,gBAAgB,IAAI,CAAC,oBAAoB,UAAU;YACpF;YAEA,IAAI,CAAC,MAAM,IAAI,qBAAqB,cAAc,KAAK,MAAM;gBAC3D,IAAI,uBAAuB,QACvB,OAAO,QAAQ,cACf,QAAQ,IAAI,CAAC,QAAQ,CAAC,MAAM,oBAAoB,IAAI,GAAG;oBACzD,mFAAmF;oBACnF,aAAa,IAAI;oBAEjB,MAAM,aAAa,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,QAAQ,IAAI,CAAC,MAAM,GAAG,oBAAoB,IAAI,CAAC,MAAM,GAAG;oBACjG,MAAM,OAAO,MAAM,GAAG,CAAC,YAAY,KAAK;oBACxC,MAAM,wBAAwB,MAAM,OAAO,CAAC,QAC1C,MAAM,KAAK,CAAC,OAAO,CAAC,QACnB,OAAO;wBAAC;qBAAK,GAAG,EAAE;oBACrB,KAAK,MAAM,UAAU,sBAAuB;wBAC1C,WAAW,GAAG,CAAC,kBAAkB,KAAK;oBACxC;oBAEA,IAAI,sBAAsB,MAAM,KAAK,GAAG;wBACtC,aAAa;4BAAC,kBAAkB,KAAK;yBAAK;oBAC5C,OAAO;wBACL,aAAa,MAAM,IAAI,CAAC;oBAC1B;gBACF,OAAO;oBACL,MAAM,kBAAkB,KAAK;oBAC7B,aAAa;wBAAC;qBAAI;gBACpB;YACF,OAAO,IAAI,CAAC,sBAAsB,IAAI,QAAQ,kBAAkB,KAAK,MAAM;gBACzE,YAAY;gBACZ,IAAI,OAAO,YAAY,YAAY;oBACjC,MAAM,aAAa,QAAQ,IAAI,CAAC,KAAK,CAAC,GAAG,QAAQ,IAAI,CAAC,MAAM,GAAG,oBAAoB,IAAI,CAAC,MAAM,GAAG;oBACjG,MAAM,OAAO,MAAM,GAAG,CAAC,YAAY,KAAK;oBACxC,MAAM,wBAAwB,MAAM,OAAO,CAAC,QAC1C,MAAM,KAAK,CAAC,OAAO,CAAC,QACnB,OAAO;wBAAC;qBAAK,GAAG,EAAE;oBAErB,aAAa,IAAI;oBACjB,KAAK,MAAM,UAAU,sBAAuB;wBAC1C,UAAU,QAAQ,IAAI,CAAC,QAAQ,QAAQ,QAAQ,IAAI;wBACnD,sBAAsB,SAAS,KAAK,QAAQ,IAAI,EAAE,aAAa,QAAQ,gBAAgB,EACrF,OAAO,CAAC,CAAA,OAAQ,WAAW,GAAG,CAAC;oBACnC;oBACA,aAAa,MAAM,IAAI,CAAC;gBAC1B,OAAO;oBACL,aAAa,sBAAsB,SAAS,KAAK,QAAQ,IAAI,EAAE,aAAa,QAAQ,gBAAgB;gBACtG;YACF;QACF;QAEA,IAAI,CAAC,YAAY;YACf,uFAAuF;YACvF,IAAI,QAAQ,WAAW,IAAI,MAAM;gBAC/B,aAAa;oBAAC,MAAM,SAAS;iBAAC;YAChC,OAAO;gBACL,OAAO;oBAAE,YAAY;oBAAY,SAAS;oBAAS,WAAW;oBAAW,SAAS;gBAAQ;YAC5F;QACF;QAEA,IAAI,CAAC,MAAM,OAAO,CAAC,aAAa;YAC9B,aAAa;gBAAC;aAAW;QAC3B;QAEA,OAAO;YAAE,YAAY;YAAY,SAAS;YAAS,WAAW;YAAW,SAAS;QAAQ;IAC5F;AACF;AAEA;;CAEC,GAED,SAAS,iBAAiB,KAAK,EAAE,IAAI,EAAE,OAAO,EAAE,WAAW;IACzD,MAAM,MAAM,EAAE;IACd,MAAM,YAAY,CAAC;IACnB,MAAM,UAAU,YAAY,OAAO;IAEnC,KAAK,MAAM,OAAO,KAAM;QACtB,IAAI,aAAa;QACjB,MAAM,OAAO,CAAC;QAEd,8BAA8B;QAC9B,IAAI;QACJ,MAAM,gBAAgB,YAAY,gBAAgB,GAChD,YAAY,gBAAgB,GAAG,MAAM;QACvC,IAAI,OAAO,QAAQ,UAAU,KAAK,UAAU;YAC1C,aAAa,QAAQ,UAAU;QACjC,OAAO,IAAI,OAAO,QAAQ,OAAO,CAAC,UAAU,KAAK,YAAY;YAC3D,aAAa,gBAAgB,QAAQ,OAAO,CAAC,UAAU,CAAC,IAAI,CAAC,KAAK;QACpE,OAAO,IAAI,MAAM,OAAO,CAAC,QAAQ,OAAO,CAAC,UAAU,GAAG;YACpD,aAAa,QAAQ,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAA,QAAS,gBAAgB;QACvE,OAAO;YACL,aAAa,gBAAgB,QAAQ,OAAO,CAAC,UAAU;QACzD;QACA,KAAK,KAAK,GAAG,QAAQ,OAAO,CAAC,KAAK;QAElC,IAAI,QAAQ,OAAO,CAAC,IAAI,IAAI,QAAQ,CAAC,QAAQ,cAAc,CAAC,SAAS;YACnE,QAAQ,IAAI,GAAG,QAAQ,OAAO,CAAC,IAAI;QACrC;QACA,IAAI,QAAQ,OAAO,CAAC,KAAK,IAAI,QAAQ,CAAC,QAAQ,cAAc,CAAC,UAAU;YACrE,QAAQ,KAAK,GAAG,QAAQ,OAAO,CAAC,KAAK;QACvC;QACA,IAAI,QAAQ,OAAO,CAAC,gBAAgB,IAAI,QAAQ,CAAC,QAAQ,cAAc,CAAC,qBAAqB;YAC3F,QAAQ,gBAAgB,GAAG,QAAQ,OAAO,CAAC,gBAAgB;QAC7D;QACA,IAAI,eAAe,QAAQ,OAAO,CAAC,YAAY;QAE/C,IAAI,CAAC,cAAc,CAAC,cAAc;YAChC,OAAO,IAAI,cAAc,CAAC,0BAA0B,EAAE,QAAQ,IAAI,CAAC,cAAc,EAAE,MAAM,SAAS,CAAC,wEAAwE,CAAC;QAC9K;QAEA,IAAI,OAAO,eAAe,YAAY;YACpC,aAAa,WAAW,IAAI,CAAC,KAAK;QACpC;QACA,IAAI,OAAO,iBAAiB,YAAY;YACtC,eAAe,aAAa,IAAI,CAAC,KAAK;QACxC;QAEA,KAAK,SAAS,GAAG;QAEjB,uEAAuE;QACvE,kEAAkE;QAClE,6CAA6C;QAC7C,IAAI,UAAU;QACd,IAAI,aAAa,WAAW,QAAQ,OAAO,KAAK,KAAK,GAAG;YACtD,UAAU,QAAQ,OAAO;QAC3B;QAEA,aAAa,QAAQ,yBAAyB,CAAC;QAC/C,IAAI,QAAQ,OAAO,CAAC,OAAO,EAAE;YAC3B,UAAU,CAAC,CAAC,QAAQ,OAAO,CAAC,OAAO;YACnC,KAAK,SAAS,GAAG;QACnB,OAAO,IAAI,QAAQ,OAAO,CAAC,GAAG,EAAE;YAC9B,UAAU,CAAC,CAAC,QAAQ,OAAO,CAAC,OAAO;QACrC;QAEA,KAAK,SAAS,GAAG;QACjB,KAAK,OAAO,GAAG;QACf,KAAK,OAAO,GAAG;QAEf,UAAU;QACV,MAAM,YAAY,IAAI,MAAM,yBAAyB,SACnD,IAAI,MAAM,iCAAiC;QAC7C,IAAI,QAAQ,IAAI,SAAS,SAAS,SAAS;QAE3C,IAAI,mBAAmB,OAAO,UAAU;QACxC,IAAI,kBAAkB;YACpB,QAAQ,MAAM,IAAI,CAAC,KAAK,KAAK,KAAK,OAAO;QAC3C;QAEA,IAAI,MAAM,OAAO,CAAC,eAAe,MAAM,OAAO,CAAC,iBAAiB,WAAW,MAAM,KAAK,aAAa,MAAM,EAAE;YACzG,QAAQ,OAAO,MAAM,CAAC,CAAC,GAAG;YAC1B,IAAK,IAAI,IAAI,GAAG,IAAI,WAAW,MAAM,EAAE,EAAE,EAAG;gBAC1C,KAAK,CAAC,YAAY,CAAC,EAAE,CAAC,GAAG,aAAa,MAAM,GAAG,CAAC,UAAU,CAAC,EAAE,EAAE,KAAK,oBAAoB,MAAM,MAAM;gBACpG,mBAAmB;YACrB;YAEA,aAAa,UAAU,CAAC,EAAE;YAC1B,eAAe,YAAY,CAAC,EAAE;QAChC;QACA,KAAK,UAAU,GAAG;QAClB,KAAK,YAAY,GAAG;QACpB,KAAK,KAAK,GAAG;QACb,KAAK,gBAAgB,GAAG;QAExB,cAAc;QAEd,mBAAmB;QACnB,MAAM,MAAM,qBAAqB,KAAK,YAAY,OAAO,SAAS;QAElE,IAAI;YACF,mBAAmB,OAAO,KAAK,WAAW,YAAY,SAAS,MAAM,KAAK;QAC5E,EAAE,OAAO,KAAK;YACZ,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAEA;;CAEC,GAED,SAAS,mBAAmB,KAAK,EAAE,GAAG,EAAE,SAAS,EAAE,UAAU,EAAE,OAAO,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,aAAa,EAAE,gBAAgB;IACrH,wEAAwE;IACxE,0EAA0E;IAC1E,MAAM,aAAa,QAAQ,UAAU,IAAI,OAAO,QAAQ,UAAU,GAAG,MAAM,EAAE;IAE7E,mBAAmB,qBAAqB,KAAK,IAAI,MAAM;IACvD,IAAI,MAAM,OAAO,CAAC,mBAAmB;QACnC,mBAAmB,MAAM,WAAW,CAAC;IACvC;IAEA,IAAI,cAAc,MAAM;QACtB;IACF;IAEA,MAAM,iBAAiB,MAAM,KAAK,CAAC,OAAO,CAAC;IAC3C,IAAI,IAAI,eAAe,MAAM;IAC7B,MAAO,IAAK;QACV,IAAI,YAAY,cAAc,CAAC,EAAE;QACjC,IAAI,aAAa,MAAM;YACrB;QACF;QAEA,IAAI;QACJ,IAAI,QAAQ,KAAK,IAAI,QAAQ,KAAK,CAAC,YAAY,EAAE;YAC/C,QAAQ,QAAQ,KAAK;QACvB,OAAO,IAAI,SAAS,CAAC,YAAY,EAAE;YACjC,QAAQ;YACR,YAAY,MAAM,SAAS;QAC7B,OAAO;YACL,IAAI;gBACF,QAAQ,kBAAkB,YAAY;YACxC,EAAE,OAAO,KAAK;gBACZ,IAAI,QAAQ,KAAK,GAAG;oBAClB,MAAM;gBACR;gBACA,QAAQ;YACV;QACF;QAEA,IAAI,MAAM;QAEV,MAAM,uBAAuB,KAAK,iBAAiB,GAAG,KAAK,iBAAiB,GAAG;QAC/E,IAAI,KAAK,SAAS,IAAI,MAAM,OAAO,CAAC,QAAQ,IAAI,MAAM,KAAK,qBAAqB,MAAM,EAAE;YACtF,MAAM,mBAAmB,KAAK,sBAAsB;QACtD;QAEA,MAAM,mBAAmB,QAAQ,gBAAgB,IAAI,OACnD,IAAI,SAAS,4BAA4B,QACzC,QAAQ,gBAAgB;QAE1B,IAAI,CAAC,SAAS,CAAC,UAAU,IAAI,oBAAoB,MAAM;YACrD,MAAM,iBAAiB;gBACrB,OAAO;YACT;YACA,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,OAAO,EAAE,oBAAoB;gBAC1D,eAAe,OAAO,GAAG,MAAM,KAAK,OAAO,CAAC,OAAO,CAAC,OAAO;YAC7D,OAAO,IAAI,iBAAiB,MAAM;gBAChC,eAAe,OAAO,GAAG,OAAO,MAAM,CAAC,CAAC,GAAG;YAC7C;YACA,MAAM,KAAK,CAAC,gBAAgB;YAE5B,oEAAoE;YACpE,QAAQ;YACR,OAAO,CAAC,oBAAoB,GAAG;YAC/B,cAAc,CAAC,oBAAoB,GAAG;YACtC,SAAS,CAAC,UAAU,GAAG;gBACrB,OAAO;gBACP,SAAS;gBACT,OAAO,KAAK,gBAAgB,GAAG;oBAAC,KAAK,KAAK;iBAAC,GAAG,KAAK,KAAK;gBACxD,MAAM;oBAAC;iBAAI;gBACX,KAAK;oBAAC;iBAAI;gBACV,QAAQ;oBAAC;iBAAI;gBACb,mBAAmB;oBAAC;iBAAiB;gBACrC,YAAY,IAAI,IAAI;oBAAC,KAAK,UAAU;iBAAC;gBACrC,cAAc,IAAI,IAAI;oBAAC,KAAK,YAAY;iBAAC;gBACzC,SAAS,KAAK,OAAO;gBACrB,WAAW,KAAK,SAAS;gBACzB,SAAS,KAAK,OAAO;gBACrB,OAAO,KAAK,KAAK;gBACjB,CAAC,oBAAoB,EAAE;YACzB;YACA,IAAI,IAAI,CAAC,SAAS,CAAC,UAAU;QAC/B,OAAO;YACL,SAAS,CAAC,UAAU,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,UAAU;YACnD,SAAS,CAAC,UAAU,CAAC,YAAY,CAAC,GAAG,CAAC,KAAK,YAAY;YACvD,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC;YAC/B,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,IAAI,CAAC;YAC9B,SAAS,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,CAAC;YACjC,SAAS,CAAC,UAAU,CAAC,iBAAiB,CAAC,IAAI,CAAC;YAC5C,IAAI,KAAK,gBAAgB,EAAE;gBACzB,SAAS,CAAC,UAAU,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,KAAK;YAC5C;QACF;IACF;AACF;AAEA,SAAS,kBAAkB,IAAI,EAAE,SAAS;IACxC,gFAAgF,GAChF,IAAI,KAAK,MAAM,CAAC,UAAU,IAAI,QAAQ,KAAK,OAAO,IAAI,MAAM;QAC1D,OAAO,kBAAkB,KAAK,OAAO,EAAE;IACzC;IAEA,OAAO,KAAK,KAAK,CAAC;AACpB;AAEA,SAAS,mBAAmB,GAAG,EAAE,QAAQ,EAAE,aAAa;IACtD,IAAI,CAAC,MAAM,OAAO,CAAC,WAAW;QAC5B,OAAO,aAAa,gBAChB,MAAM,OAAO,CAAC,OACZ,MAAM,KAAK,CAAC,OAAO,CAAC,OACpB;YAAC;SAAI,GACP,EAAE;IACR;IACA,IAAI,MAAM,OAAO,CAAC,QAAQ,MAAM,OAAO,CAAC,WAAW;QACjD,OAAO,IAAI,OAAO,CAAC,CAAC,IAAI,QAAU,mBAAmB,IAAI,QAAQ,CAAC,MAAM,EAAE;IAC5E;IACA,OAAO,EAAE;AACX;AAEA;;CAEC,GAED,SAAS,kBAAkB,GAAG,EAAE,GAAG;IACjC,IAAI,OAAO,QAAQ,cAAc,CAAC,GAAG,CAAC,YAAY,EAAE;QAClD,OAAO,IAAI,IAAI,CAAC,KAAK;IACvB;IACA,OAAO;AACT;AAEA;;CAEC,GAED,SAAS,qBAAqB,GAAG,EAAE,UAAU,EAAE,KAAK,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM;IAC5E,mBAAmB;IACnB,MAAM,qBAAqB,MAAM,MAAM,CAAC,YAAY,CAAC;IACrD,MAAM,iBAAiB,uBAAuB,SAC5C,MAAM,MAAM,CAAC,IAAI,CAAC,cAClB,mBAAmB,MAAM;IAC3B,MAAM,oBAAoB,kBAAkB,eAAe,OAAO,GAChE,eAAe,OAAO,GAAG,EAAE;IAE7B,aAAa,kBAAkB,QAAQ,eAAe,QAAQ,KAAK,aAAa,aAAa,SAAS;IAEtG,MAAM,mBAAmB,IAAI,SAAS,WAAW,CAAC;IAElD,MAAM,UAAU,aAAa,mBAC3B,iBAAiB,OAAO,GACxB,IAAI,SAAS,mBAAmB;IAClC,IAAI,kBAAkB,MAAM,KAAK,KAAK,SAAS;QAC7C,MAAM,cAAc,AAAC,IAAI,GAAG,IAAI,OAAQ,MAAM,MAAM,OAAO,CAAC;QAC5D,MAAM,kBAAkB,MAAM,QAAQ,CAAC,YAAY;QACnD,IAAI,MAAM,OAAO,CAAC,kBAAkB;YAClC,MAAM,0BAA0B,MAAM,QAAQ,CAAC,WAAW,KAAK,CAAC,KAAK,KAAK,CAAC,GAAG,CAAC,IAAI;YACnF,OAAO,gBAAgB,GAAG,CAAC,CAAC,kBAAkB,qBAC5C,eAAe,YAAY,CAAC,kBAAkB,uBAAuB,CAAC,mBAAmB;QAC7F,OAAO;YACL,OAAO,eAAe,YAAY,CAAC,iBAAiB;QACtD;IACF,OAAO;QACL,OAAO,aAAa,MAAM,GAAG,CAAC,YAAY,KAAK,oBAAoB;IACrE;AACF;AAEA;;;;;;;CAOC,GAED,SAAS,aAAa,GAAG,EAAE,MAAM;IAC/B,IAAI,OAAO,QAAQ,IAAI,GAAG,IAAI,MAAM;QAClC,OAAO,IAAI,IAAI,CAAC,GAAG;IACrB;IACA,IAAI,OAAO,QAAQ,IAAI,GAAG,IAAI,QAAQ,CAAC,UAAU,QAAQ,CAAC,OAAO,YAAY,GAAG;QAC9E,OAAO,IAAI,GAAG;IAChB;IAEA,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,MAAM,SAAS,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO,GAAG;QACnD,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,EAAE,EAAG;YACtC,IAAI,MAAM,CAAC,EAAE,IAAI,QAAQ,MAAM,CAAC,EAAE,CAAC,GAAG,IAAI,MAAM;gBAC9C,MAAM,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC,IAAI,CAAC,GAAG;YAChC;QACF;QACA,IAAI,MAAM,eAAe,CAAC,QAAQ,IAAI,OAAO,IAAI;YAC/C,OAAO,IAAI,OAAO,GAAG,gBAAgB,CAAC,KAAK,IAAI,OAAO;QACxD;QAEA,OAAO,EAAE,CAAC,MAAM,CAAC;IACnB;IAEA,wEAAwE;IACxE,oBAAoB;IACpB,IAAI,mBAAmB,SAAS,YAC5B,oEAAoE;IACpE,6DAA6D;IAC7D,CAAC,UAAU,QAAQ,MAAM,CAAC,kBAAkB,IAAI,IAAI,GAAG;QACzD,MAAM,MAAM,EAAE;QACd,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,KAAM;YAClC,IAAI,IAAI,CAAC,GAAG,CAAC,IAAI;QACnB;QACA,OAAO;IACT;IACA,+DAA+D;IAC/D,mCAAmC;IACnC,IAAI,eAAe,KAAK;QACtB,OAAO,MAAM,IAAI,CAAC,IAAI,MAAM;IAC9B;IAEA,OAAO;AACT;AAEA;;CAEC,GAED,SAAS,8BAA8B,GAAG,EAAE,WAAW,EAAE,IAAI,EAAE,OAAO,EAAE,iBAAiB,EAAE,GAAG;IAC5F,wEAAwE;IACxE,qEAAqE;IACrE,kBAAkB;IAClB,IAAI,CAAC,KAAK,SAAS,IAAI,qBAAqB,MAAM;QAChD;IACF;IAEA,MAAM,SAAS,kBAAkB,KAAK,CAAC;IACvC,IAAI,MAAM;IACV,IAAI,aAAa,KAAK;IACtB,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,MAAM,EAAE,EAAE,EAAG;QACtC,MAAM,QAAQ,MAAM,CAAC,EAAE;QACvB,MAAM,MAAM,CAAC,IAAI,MAAM,KAAK,IAAI,KAAK,GAAG,IAAI;QAC5C,MAAM,aAAa,YAAY,IAAI,CAAC;QACpC,IAAI,cAAc,QACd,WAAW,gBAAgB,IAC3B,WAAW,MAAM,CAAC,cAAc,IAAI,QACpC,OAAO,IAAI,CAAC,WAAW,MAAM,CAAC,cAAc,EAAE,MAAM,KAAK,GAAG;YAC9D,MAAM,UAAU,MAAM,QAAQ,CAAC,KAAK;YACpC,MAAM,UAAU,QAAQ,IAAI,CAAC,SAAS,CAAC,IAAI,MAAM,GAAG;YACpD,MAAM,mBAAmB,WAAW,MAAM,CAAC,MAAM,CAAC,OAAO,CAAC,gBAAgB;YAC1E,aAAa,EAAE;YACf,KAAK,MAAM,UAAU,QAAS;gBAC5B,MAAM,oBAAoB,MAAM,QAAQ,CAAC,kBAAkB;gBAC3D,MAAM,gBAAgB,WAAW,MAAM,CAAC,cAAc,CAAC,kBAAkB;gBACzE,MAAM,sBAAsB,iBAAiB,cAAc,MAAM;gBACjE,IAAI,uBAAuB,MAAM;oBAC/B;gBACF;gBACA,MAAM,QAAQ,oBAAoB,IAAI,CAAC;gBACvC,IAAI,SAAS,QAAQ,MAAM,OAAO,CAAC,OAAO,IAAI,MAAM;oBAClD,MAAM,WAAW,MAAM,QAAQ,CAAC,KAAK,UAAU,CAAC,SAAS,CAAC,IAAI,MAAM,GAAG,IAAI;oBAC3E,IAAI,OAAO,CAAC,CAAC,GAAG;wBACd,IAAI,MAAM,UAAU;4BAClB,GAAG,CAAC,EAAE,GAAG,kBAAkB;wBAC7B;oBACF;oBACA;gBACF;gBACA,MAAM,YAAY,MAAM,QAAQ,CAAC,OAAO,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC,MAAM;gBAChE,WAAW,IAAI,CAAC;YAClB;QACF;IACF;IAEA,OAAO;AACT;AAEA;;CAEC,GAED,SAAS,cAAc,KAAK;IAC1B,IAAI,SAAS,MAAM;QACjB;IACF;IACA,IAAI,OAAO,UAAU,UAAU;QAC7B;IACF;IACA,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,OAAQ;QACpC,IAAI,QAAQ,UAAU;YACpB,MAAM,IAAI,cAAc;QAC1B;QACA,IAAI,KAAK,CAAC,IAAI,IAAI,QAAQ,OAAO,KAAK,CAAC,IAAI,KAAK,UAAU;YACxD,cAAc,KAAK,CAAC,IAAI;QAC1B;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7751, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/indexes/isDefaultIdIndex.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\n\nmodule.exports = function isDefaultIdIndex(index) {\n  if (Array.isArray(index)) {\n    // Mongoose syntax\n    const keys = Object.keys(index[0]);\n    return keys.length === 1 && keys[0] === '_id' && index[0]._id !== 'hashed';\n  }\n\n  if (typeof index !== 'object') {\n    return false;\n  }\n\n  const key = get(index, 'key', {});\n  return Object.keys(key).length === 1 && key.hasOwnProperty('_id');\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,OAAO,OAAO,GAAG,SAAS,iBAAiB,KAAK;IAC9C,IAAI,MAAM,OAAO,CAAC,QAAQ;QACxB,kBAAkB;QAClB,MAAM,OAAO,OAAO,IAAI,CAAC,KAAK,CAAC,EAAE;QACjC,OAAO,KAAK,MAAM,KAAK,KAAK,IAAI,CAAC,EAAE,KAAK,SAAS,KAAK,CAAC,EAAE,CAAC,GAAG,KAAK;IACpE;IAEA,IAAI,OAAO,UAAU,UAAU;QAC7B,OAAO;IACT;IAEA,MAAM,MAAM,IAAI,OAAO,OAAO,CAAC;IAC/B,OAAO,OAAO,IAAI,CAAC,KAAK,MAAM,KAAK,KAAK,IAAI,cAAc,CAAC;AAC7D","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7768, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/indexes/isIndexEqual.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\nconst utils = require('../../utils');\n/**\n * Given a Mongoose index definition (key + options objects) and a MongoDB server\n * index definition, determine if the two indexes are equal.\n *\n * @param {Object} schemaIndexKeysObject the Mongoose index spec\n * @param {Object} options the Mongoose index definition's options\n * @param {Object} dbIndex the index in MongoDB as returned by `listIndexes()`\n * @api private\n */\n\nmodule.exports = function isIndexEqual(schemaIndexKeysObject, options, dbIndex) {\n  // Special case: text indexes have a special format in the db. For example,\n  // `{ name: 'text' }` becomes:\n  // {\n  //   v: 2,\n  //   key: { _fts: 'text', _ftsx: 1 },\n  //   name: 'name_text',\n  //   ns: 'test.tests',\n  //   background: true,\n  //   weights: { name: 1 },\n  //   default_language: 'english',\n  //   language_override: 'language',\n  //   textIndexVersion: 3\n  // }\n  if (dbIndex.textIndexVersion != null) {\n    delete dbIndex.key._fts;\n    delete dbIndex.key._ftsx;\n    const weights = { ...dbIndex.weights, ...dbIndex.key };\n    if (Object.keys(weights).length !== Object.keys(schemaIndexKeysObject).length) {\n      return false;\n    }\n    for (const prop of Object.keys(weights)) {\n      if (!(prop in schemaIndexKeysObject)) {\n        return false;\n      }\n      const weight = weights[prop];\n      if (weight !== get(options, 'weights.' + prop) && !(weight === 1 && get(options, 'weights.' + prop) == null)) {\n        return false;\n      }\n    }\n\n    if (options['default_language'] !== dbIndex['default_language']) {\n      return dbIndex['default_language'] === 'english' && options['default_language'] == null;\n    }\n\n    return true;\n  }\n\n  const optionKeys = [\n    'unique',\n    'partialFilterExpression',\n    'sparse',\n    'expireAfterSeconds',\n    'collation'\n  ];\n  for (const key of optionKeys) {\n    if (!(key in options) && !(key in dbIndex)) {\n      continue;\n    }\n    if (key === 'collation') {\n      if (options[key] == null || dbIndex[key] == null) {\n        return options[key] == null && dbIndex[key] == null;\n      }\n      const definedKeys = Object.keys(options.collation);\n      const schemaCollation = options.collation;\n      const dbCollation = dbIndex.collation;\n      for (const opt of definedKeys) {\n        if (get(schemaCollation, opt) !== get(dbCollation, opt)) {\n          return false;\n        }\n      }\n    } else if (!utils.deepEqual(options[key], dbIndex[key])) {\n      return false;\n    }\n  }\n\n  const schemaIndexKeys = Object.keys(schemaIndexKeysObject);\n  const dbIndexKeys = Object.keys(dbIndex.key);\n  if (schemaIndexKeys.length !== dbIndexKeys.length) {\n    return false;\n  }\n  for (let i = 0; i < schemaIndexKeys.length; ++i) {\n    if (schemaIndexKeys[i] !== dbIndexKeys[i]) {\n      return false;\n    }\n    if (!utils.deepEqual(schemaIndexKeysObject[schemaIndexKeys[i]], dbIndex.key[dbIndexKeys[i]])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN;;;;;;;;CAQC,GAED,OAAO,OAAO,GAAG,SAAS,aAAa,qBAAqB,EAAE,OAAO,EAAE,OAAO;IAC5E,2EAA2E;IAC3E,8BAA8B;IAC9B,IAAI;IACJ,UAAU;IACV,qCAAqC;IACrC,uBAAuB;IACvB,sBAAsB;IACtB,sBAAsB;IACtB,0BAA0B;IAC1B,iCAAiC;IACjC,mCAAmC;IACnC,wBAAwB;IACxB,IAAI;IACJ,IAAI,QAAQ,gBAAgB,IAAI,MAAM;QACpC,OAAO,QAAQ,GAAG,CAAC,IAAI;QACvB,OAAO,QAAQ,GAAG,CAAC,KAAK;QACxB,MAAM,UAAU;YAAE,GAAG,QAAQ,OAAO;YAAE,GAAG,QAAQ,GAAG;QAAC;QACrD,IAAI,OAAO,IAAI,CAAC,SAAS,MAAM,KAAK,OAAO,IAAI,CAAC,uBAAuB,MAAM,EAAE;YAC7E,OAAO;QACT;QACA,KAAK,MAAM,QAAQ,OAAO,IAAI,CAAC,SAAU;YACvC,IAAI,CAAC,CAAC,QAAQ,qBAAqB,GAAG;gBACpC,OAAO;YACT;YACA,MAAM,SAAS,OAAO,CAAC,KAAK;YAC5B,IAAI,WAAW,IAAI,SAAS,aAAa,SAAS,CAAC,CAAC,WAAW,KAAK,IAAI,SAAS,aAAa,SAAS,IAAI,GAAG;gBAC5G,OAAO;YACT;QACF;QAEA,IAAI,OAAO,CAAC,mBAAmB,KAAK,OAAO,CAAC,mBAAmB,EAAE;YAC/D,OAAO,OAAO,CAAC,mBAAmB,KAAK,aAAa,OAAO,CAAC,mBAAmB,IAAI;QACrF;QAEA,OAAO;IACT;IAEA,MAAM,aAAa;QACjB;QACA;QACA;QACA;QACA;KACD;IACD,KAAK,MAAM,OAAO,WAAY;QAC5B,IAAI,CAAC,CAAC,OAAO,OAAO,KAAK,CAAC,CAAC,OAAO,OAAO,GAAG;YAC1C;QACF;QACA,IAAI,QAAQ,aAAa;YACvB,IAAI,OAAO,CAAC,IAAI,IAAI,QAAQ,OAAO,CAAC,IAAI,IAAI,MAAM;gBAChD,OAAO,OAAO,CAAC,IAAI,IAAI,QAAQ,OAAO,CAAC,IAAI,IAAI;YACjD;YACA,MAAM,cAAc,OAAO,IAAI,CAAC,QAAQ,SAAS;YACjD,MAAM,kBAAkB,QAAQ,SAAS;YACzC,MAAM,cAAc,QAAQ,SAAS;YACrC,KAAK,MAAM,OAAO,YAAa;gBAC7B,IAAI,IAAI,iBAAiB,SAAS,IAAI,aAAa,MAAM;oBACvD,OAAO;gBACT;YACF;QACF,OAAO,IAAI,CAAC,MAAM,SAAS,CAAC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,IAAI,GAAG;YACvD,OAAO;QACT;IACF;IAEA,MAAM,kBAAkB,OAAO,IAAI,CAAC;IACpC,MAAM,cAAc,OAAO,IAAI,CAAC,QAAQ,GAAG;IAC3C,IAAI,gBAAgB,MAAM,KAAK,YAAY,MAAM,EAAE;QACjD,OAAO;IACT;IACA,IAAK,IAAI,IAAI,GAAG,IAAI,gBAAgB,MAAM,EAAE,EAAE,EAAG;QAC/C,IAAI,eAAe,CAAC,EAAE,KAAK,WAAW,CAAC,EAAE,EAAE;YACzC,OAAO;QACT;QACA,IAAI,CAAC,MAAM,SAAS,CAAC,qBAAqB,CAAC,eAAe,CAAC,EAAE,CAAC,EAAE,QAAQ,GAAG,CAAC,WAAW,CAAC,EAAE,CAAC,GAAG;YAC5F,OAAO;QACT;IACF;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7862, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/indexes/isTimeseriesIndex.js"],"sourcesContent":["'use strict';\n\n/**\n * Returns `true` if the given index matches the schema's `timestamps` options\n */\n\nmodule.exports = function isTimeseriesIndex(dbIndex, schemaOptions) {\n  if (schemaOptions.timeseries == null) {\n    return false;\n  }\n  const { timeField, metaField } = schemaOptions.timeseries;\n  if (typeof timeField !== 'string' || typeof metaField !== 'string') {\n    return false;\n  }\n  return Object.keys(dbIndex.key).length === 2 && dbIndex.key[timeField] === 1 && dbIndex.key[metaField] === 1;\n};\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,kBAAkB,OAAO,EAAE,aAAa;IAChE,IAAI,cAAc,UAAU,IAAI,MAAM;QACpC,OAAO;IACT;IACA,MAAM,EAAE,SAAS,EAAE,SAAS,EAAE,GAAG,cAAc,UAAU;IACzD,IAAI,OAAO,cAAc,YAAY,OAAO,cAAc,UAAU;QAClE,OAAO;IACT;IACA,OAAO,OAAO,IAAI,CAAC,QAAQ,GAAG,EAAE,MAAM,KAAK,KAAK,QAAQ,GAAG,CAAC,UAAU,KAAK,KAAK,QAAQ,GAAG,CAAC,UAAU,KAAK;AAC7G","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7878, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/indexes/getRelatedIndexes.js"],"sourcesContent":["'use strict';\n\nconst hasDollarKeys = require('../query/hasDollarKeys');\n\nfunction getRelatedSchemaIndexes(model, schemaIndexes) {\n  return getRelatedIndexes({\n    baseModelName: model.baseModelName,\n    discriminatorMapping: model.schema.discriminatorMapping,\n    indexes: schemaIndexes,\n    indexesType: 'schema'\n  });\n}\n\nfunction getRelatedDBIndexes(model, dbIndexes) {\n  return getRelatedIndexes({\n    baseModelName: model.baseModelName,\n    discriminatorMapping: model.schema.discriminatorMapping,\n    indexes: dbIndexes,\n    indexesType: 'db'\n  });\n}\n\nmodule.exports = {\n  getRelatedSchemaIndexes,\n  getRelatedDBIndexes\n};\n\nfunction getRelatedIndexes({\n  baseModelName,\n  discriminatorMapping,\n  indexes,\n  indexesType\n}) {\n  const discriminatorKey = discriminatorMapping && discriminatorMapping.key;\n  const discriminatorValue = discriminatorMapping && discriminatorMapping.value;\n\n  if (!discriminatorKey) {\n    return indexes;\n  }\n\n  const isChildDiscriminatorModel = Boolean(baseModelName);\n  if (isChildDiscriminatorModel) {\n    return indexes.filter(index => {\n      const partialFilterExpression = getPartialFilterExpression(index, indexesType);\n      return partialFilterExpression && partialFilterExpression[discriminatorKey] === discriminatorValue;\n    });\n  }\n\n  return indexes.filter(index => {\n    const partialFilterExpression = getPartialFilterExpression(index, indexesType);\n    return !partialFilterExpression\n      || !partialFilterExpression[discriminatorKey]\n      || (hasDollarKeys(partialFilterExpression[discriminatorKey]) && !('$eq' in partialFilterExpression[discriminatorKey]));\n  });\n}\n\nfunction getPartialFilterExpression(index, indexesType) {\n  if (indexesType === 'schema') {\n    const options = index[1];\n    return options && options.partialFilterExpression;\n  }\n  return index.partialFilterExpression;\n}\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,SAAS,wBAAwB,KAAK,EAAE,aAAa;IACnD,OAAO,kBAAkB;QACvB,eAAe,MAAM,aAAa;QAClC,sBAAsB,MAAM,MAAM,CAAC,oBAAoB;QACvD,SAAS;QACT,aAAa;IACf;AACF;AAEA,SAAS,oBAAoB,KAAK,EAAE,SAAS;IAC3C,OAAO,kBAAkB;QACvB,eAAe,MAAM,aAAa;QAClC,sBAAsB,MAAM,MAAM,CAAC,oBAAoB;QACvD,SAAS;QACT,aAAa;IACf;AACF;AAEA,OAAO,OAAO,GAAG;IACf;IACA;AACF;AAEA,SAAS,kBAAkB,EACzB,aAAa,EACb,oBAAoB,EACpB,OAAO,EACP,WAAW,EACZ;IACC,MAAM,mBAAmB,wBAAwB,qBAAqB,GAAG;IACzE,MAAM,qBAAqB,wBAAwB,qBAAqB,KAAK;IAE7E,IAAI,CAAC,kBAAkB;QACrB,OAAO;IACT;IAEA,MAAM,4BAA4B,QAAQ;IAC1C,IAAI,2BAA2B;QAC7B,OAAO,QAAQ,MAAM,CAAC,CAAA;YACpB,MAAM,0BAA0B,2BAA2B,OAAO;YAClE,OAAO,2BAA2B,uBAAuB,CAAC,iBAAiB,KAAK;QAClF;IACF;IAEA,OAAO,QAAQ,MAAM,CAAC,CAAA;QACpB,MAAM,0BAA0B,2BAA2B,OAAO;QAClE,OAAO,CAAC,2BACH,CAAC,uBAAuB,CAAC,iBAAiB,IACzC,cAAc,uBAAuB,CAAC,iBAAiB,KAAK,CAAC,CAAC,SAAS,uBAAuB,CAAC,iBAAiB;IACxH;AACF;AAEA,SAAS,2BAA2B,KAAK,EAAE,WAAW;IACpD,IAAI,gBAAgB,UAAU;QAC5B,MAAM,UAAU,KAAK,CAAC,EAAE;QACxB,OAAO,WAAW,QAAQ,uBAAuB;IACnD;IACA,OAAO,MAAM,uBAAuB;AACtC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7928, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/parallelLimit.js"],"sourcesContent":["'use strict';\n\nmodule.exports = parallelLimit;\n\n/*!\n * ignore\n */\n\nfunction parallelLimit(fns, limit, callback) {\n  let numInProgress = 0;\n  let numFinished = 0;\n  let error = null;\n\n  if (limit <= 0) {\n    throw new Error('Limit must be positive');\n  }\n\n  if (fns.length === 0) {\n    return callback(null, []);\n  }\n\n  for (let i = 0; i < fns.length && i < limit; ++i) {\n    _start();\n  }\n\n  function _start() {\n    fns[numFinished + numInProgress](_done(numFinished + numInProgress));\n    ++numInProgress;\n  }\n\n  const results = [];\n\n  function _done(index) {\n    return (err, res) => {\n      --numInProgress;\n      ++numFinished;\n\n      if (error != null) {\n        return;\n      }\n      if (err != null) {\n        error = err;\n        return callback(error);\n      }\n\n      results[index] = res;\n\n      if (numFinished === fns.length) {\n        return callback(null, results);\n      } else if (numFinished + numInProgress < fns.length) {\n        _start();\n      }\n    };\n  }\n}\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG;AAEjB;;CAEC,GAED,SAAS,cAAc,GAAG,EAAE,KAAK,EAAE,QAAQ;IACzC,IAAI,gBAAgB;IACpB,IAAI,cAAc;IAClB,IAAI,QAAQ;IAEZ,IAAI,SAAS,GAAG;QACd,MAAM,IAAI,MAAM;IAClB;IAEA,IAAI,IAAI,MAAM,KAAK,GAAG;QACpB,OAAO,SAAS,MAAM,EAAE;IAC1B;IAEA,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,IAAI,IAAI,OAAO,EAAE,EAAG;QAChD;IACF;IAEA,SAAS;QACP,GAAG,CAAC,cAAc,cAAc,CAAC,MAAM,cAAc;QACrD,EAAE;IACJ;IAEA,MAAM,UAAU,EAAE;IAElB,SAAS,MAAM,KAAK;QAClB,OAAO,CAAC,KAAK;YACX,EAAE;YACF,EAAE;YAEF,IAAI,SAAS,MAAM;gBACjB;YACF;YACA,IAAI,OAAO,MAAM;gBACf,QAAQ;gBACR,OAAO,SAAS;YAClB;YAEA,OAAO,CAAC,MAAM,GAAG;YAEjB,IAAI,gBAAgB,IAAI,MAAM,EAAE;gBAC9B,OAAO,SAAS,MAAM;YACxB,OAAO,IAAI,cAAc,gBAAgB,IAAI,MAAM,EAAE;gBACnD;YACF;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7973, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/model/pushNestedArrayPaths.js"],"sourcesContent":["'use strict';\n\nmodule.exports = function pushNestedArrayPaths(paths, nestedArray, path) {\n  if (nestedArray == null) {\n    return;\n  }\n\n  for (let i = 0; i < nestedArray.length; ++i) {\n    if (Array.isArray(nestedArray[i])) {\n      pushNestedArrayPaths(paths, nestedArray[i], path + '.' + i);\n    } else {\n      paths.push(path + '.' + i);\n    }\n  }\n};\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG,SAAS,qBAAqB,KAAK,EAAE,WAAW,EAAE,IAAI;IACrE,IAAI,eAAe,MAAM;QACvB;IACF;IAEA,IAAK,IAAI,IAAI,GAAG,IAAI,YAAY,MAAM,EAAE,EAAE,EAAG;QAC3C,IAAI,MAAM,OAAO,CAAC,WAAW,CAAC,EAAE,GAAG;YACjC,qBAAqB,OAAO,WAAW,CAAC,EAAE,EAAE,OAAO,MAAM;QAC3D,OAAO;YACL,MAAM,IAAI,CAAC,OAAO,MAAM;QAC1B;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 7989, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/populate/removeDeselectedForeignField.js"],"sourcesContent":["'use strict';\n\nconst get = require('../get');\nconst mpath = require('mpath');\nconst parseProjection = require('../projection/parseProjection');\n\n/*!\n * ignore\n */\n\nmodule.exports = function removeDeselectedForeignField(foreignFields, options, docs) {\n  const projection = parseProjection(get(options, 'select', null), true) ||\n    parseProjection(get(options, 'options.select', null), true);\n\n  if (projection == null) {\n    return;\n  }\n  for (const foreignField of foreignFields) {\n    if (!projection.hasOwnProperty('-' + foreignField)) {\n      continue;\n    }\n\n    for (const val of docs) {\n      if (val.$__ != null) {\n        mpath.unset(foreignField, val._doc);\n      } else {\n        mpath.unset(foreignField, val);\n      }\n    }\n  }\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AAEN;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,6BAA6B,aAAa,EAAE,OAAO,EAAE,IAAI;IACjF,MAAM,aAAa,gBAAgB,IAAI,SAAS,UAAU,OAAO,SAC/D,gBAAgB,IAAI,SAAS,kBAAkB,OAAO;IAExD,IAAI,cAAc,MAAM;QACtB;IACF;IACA,KAAK,MAAM,gBAAgB,cAAe;QACxC,IAAI,CAAC,WAAW,cAAc,CAAC,MAAM,eAAe;YAClD;QACF;QAEA,KAAK,MAAM,OAAO,KAAM;YACtB,IAAI,IAAI,GAAG,IAAI,MAAM;gBACnB,MAAM,KAAK,CAAC,cAAc,IAAI,IAAI;YACpC,OAAO;gBACL,MAAM,KAAK,CAAC,cAAc;YAC5B;QACF;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8016, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/pluralize.js"],"sourcesContent":["'use strict';\n\nmodule.exports = pluralize;\n\n/**\n * Pluralization rules.\n */\n\nexports.pluralization = [\n  [/human$/gi, 'humans'],\n  [/(m)an$/gi, '$1en'],\n  [/(pe)rson$/gi, '$1ople'],\n  [/(child)$/gi, '$1ren'],\n  [/^(ox)$/gi, '$1en'],\n  [/(ax|test)is$/gi, '$1es'],\n  [/(octop|vir)us$/gi, '$1i'],\n  [/(alias|status)$/gi, '$1es'],\n  [/(bu)s$/gi, '$1ses'],\n  [/(buffal|tomat|potat)o$/gi, '$1oes'],\n  [/([ti])um$/gi, '$1a'],\n  [/sis$/gi, 'ses'],\n  [/(?:([^f])fe|([lr])f)$/gi, '$1$2ves'],\n  [/(hive)$/gi, '$1s'],\n  [/([^aeiouy]|qu)y$/gi, '$1ies'],\n  [/(x|ch|ss|sh)$/gi, '$1es'],\n  [/(matr|vert|ind)ix|ex$/gi, '$1ices'],\n  [/([m|l])ouse$/gi, '$1ice'],\n  [/(kn|w|l)ife$/gi, '$1ives'],\n  [/(quiz)$/gi, '$1zes'],\n  [/^goose$/i, 'geese'],\n  [/s$/gi, 's'],\n  [/([^a-z])$/, '$1'],\n  [/$/gi, 's']\n];\nconst rules = exports.pluralization;\n\n/**\n * Uncountable words.\n *\n * These words are applied while processing the argument to `toCollectionName`.\n * @api public\n */\n\nexports.uncountables = [\n  'advice',\n  'energy',\n  'excretion',\n  'digestion',\n  'cooperation',\n  'health',\n  'justice',\n  'labour',\n  'machinery',\n  'equipment',\n  'information',\n  'pollution',\n  'sewage',\n  'paper',\n  'money',\n  'species',\n  'series',\n  'rain',\n  'rice',\n  'fish',\n  'sheep',\n  'moose',\n  'deer',\n  'news',\n  'expertise',\n  'status',\n  'media'\n];\nconst uncountables = exports.uncountables;\n\n/**\n * Pluralize function.\n *\n * @author TJ Holowaychuk (extracted from _ext.js_)\n * @param {String} string to pluralize\n * @api private\n */\n\nfunction pluralize(str) {\n  let found;\n  str = str.toLowerCase();\n  if (!~uncountables.indexOf(str)) {\n    found = rules.filter(function(rule) {\n      return str.match(rule[0]);\n    });\n    if (found[0]) {\n      return str.replace(found[0][0], found[0][1]);\n    }\n  }\n  return str;\n}\n"],"names":[],"mappings":"AAEA,OAAO,OAAO,GAAG;AAEjB;;CAEC,GAED,QAAQ,aAAa,GAAG;IACtB;QAAC;QAAY;KAAS;IACtB;QAAC;QAAY;KAAO;IACpB;QAAC;QAAe;KAAS;IACzB;QAAC;QAAc;KAAQ;IACvB;QAAC;QAAY;KAAO;IACpB;QAAC;QAAkB;KAAO;IAC1B;QAAC;QAAoB;KAAM;IAC3B;QAAC;QAAqB;KAAO;IAC7B;QAAC;QAAY;KAAQ;IACrB;QAAC;QAA4B;KAAQ;IACrC;QAAC;QAAe;KAAM;IACtB;QAAC;QAAU;KAAM;IACjB;QAAC;QAA2B;KAAU;IACtC;QAAC;QAAa;KAAM;IACpB;QAAC;QAAsB;KAAQ;IAC/B;QAAC;QAAmB;KAAO;IAC3B;QAAC;QAA2B;KAAS;IACrC;QAAC;QAAkB;KAAQ;IAC3B;QAAC;QAAkB;KAAS;IAC5B;QAAC;QAAa;KAAQ;IACtB;QAAC;QAAY;KAAQ;IACrB;QAAC;QAAQ;KAAI;IACb;QAAC;QAAa;KAAK;IACnB;QAAC;QAAO;KAAI;CACb;AACD,MAAM,QAAQ,QAAQ,aAAa;AAEnC;;;;;CAKC,GAED,QAAQ,YAAY,GAAG;IACrB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;CACD;AACD,MAAM,eAAe,QAAQ,YAAY;AAEzC;;;;;;CAMC,GAED,SAAS,UAAU,GAAG;IACpB,IAAI;IACJ,MAAM,IAAI,WAAW;IACrB,IAAI,CAAC,CAAC,aAAa,OAAO,CAAC,MAAM;QAC/B,QAAQ,MAAM,MAAM,CAAC,SAAS,IAAI;YAChC,OAAO,IAAI,KAAK,CAAC,IAAI,CAAC,EAAE;QAC1B;QACA,IAAI,KAAK,CAAC,EAAE,EAAE;YACZ,OAAO,IAAI,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,CAAC,EAAE,CAAC,EAAE;QAC7C;IACF;IACA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 8176, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/helpers/printJestWarning.js"],"sourcesContent":["'use strict';\n\nconst utils = require('../utils');\n\nif (typeof jest !== 'undefined' && !process.env.SUPPRESS_JEST_WARNINGS) {\n  if (typeof window !== 'undefined') {\n    utils.warn('Mongoose: looks like you\\'re trying to test a Mongoose app ' +\n      'with Jest\\'s default jsdom test environment. Please make sure you read ' +\n      'Mongoose\\'s docs on configuring Jest to test Node.js apps: ' +\n      'https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true ' +\n      'to hide this warning.');\n  }\n\n  if (setTimeout.clock != null && typeof setTimeout.clock.Date === 'function') {\n    utils.warn('Mongoose: looks like you\\'re trying to test a Mongoose app ' +\n      'with Jest\\'s mock timers enabled. Please make sure you read ' +\n      'Mongoose\\'s docs on configuring Jest to test Node.js apps: ' +\n      'https://mongoosejs.com/docs/jest.html. Set the SUPPRESS_JEST_WARNINGS to true ' +\n      'to hide this warning.');\n  }\n}\n"],"names":[],"mappings":"AAEA,MAAM;AAEN,IAAI,OAAO,SAAS,eAAe,CAAC,QAAQ,GAAG,CAAC,sBAAsB,EAAE;IACtE;;IAQA,IAAI,WAAW,KAAK,IAAI,QAAQ,OAAO,WAAW,KAAK,CAAC,IAAI,KAAK,YAAY;QAC3E,MAAM,IAAI,CAAC,gEACT,iEACA,gEACA,mFACA;IACJ;AACF","ignoreList":[0],"debugId":null}}]
}