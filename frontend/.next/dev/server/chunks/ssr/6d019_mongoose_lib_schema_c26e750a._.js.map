{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/operators/exists.js"],"sourcesContent":["'use strict';\n\nconst castBoolean = require('../../cast/boolean');\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  const path = this != null ? this.path : null;\n  return castBoolean(val, path);\n};\n"],"names":[],"mappings":"AAEA,MAAM;AAEN;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,GAAG;IAC3B,MAAM,OAAO,IAAI,IAAI,OAAO,IAAI,CAAC,IAAI,GAAG;IACxC,OAAO,YAAY,KAAK;AAC1B","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 15, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/operators/type.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nmodule.exports = function(val) {\n  if (Array.isArray(val)) {\n    if (!val.every(v => typeof v === 'number' || typeof v === 'string')) {\n      throw new Error('$type array values must be strings or numbers');\n    }\n    return val;\n  }\n\n  if (typeof val !== 'number' && typeof val !== 'string') {\n    throw new Error('$type parameter must be number, string, or array of numbers and strings');\n  }\n\n  return val;\n};\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,OAAO,OAAO,GAAG,SAAS,GAAG;IAC3B,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,IAAI,CAAC,IAAI,KAAK,CAAC,CAAA,IAAK,OAAO,MAAM,YAAY,OAAO,MAAM,WAAW;YACnE,MAAM,IAAI,MAAM;QAClB;QACA,OAAO;IACT;IAEA,IAAI,OAAO,QAAQ,YAAY,OAAO,QAAQ,UAAU;QACtD,MAAM,IAAI,MAAM;IAClB;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 33, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/symbols.js"],"sourcesContent":["'use strict';\n\nexports.schemaMixedSymbol = Symbol.for('mongoose:schema_mixed');\n\nexports.builtInMiddleware = Symbol.for('mongoose:built-in-middleware');\n"],"names":[],"mappings":"AAEA,QAAQ,iBAAiB,GAAG,OAAO,GAAG,CAAC;AAEvC,QAAQ,iBAAiB,GAAG,OAAO,GAAG,CAAC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 39, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/mixed.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst SchemaType = require('../schemaType');\nconst symbols = require('./symbols');\nconst isObject = require('../helpers/isObject');\nconst utils = require('../utils');\n\n/**\n * Mixed SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaMixed(path, options) {\n  if (options && options.default) {\n    const def = options.default;\n    if (Array.isArray(def) && def.length === 0) {\n      // make sure empty array defaults are handled\n      options.default = Array;\n    } else if (!options.shared && isObject(def) && Object.keys(def).length === 0) {\n      // prevent odd \"shared\" objects between documents\n      options.default = function() {\n        return {};\n      };\n    }\n  }\n\n  SchemaType.call(this, path, options, 'Mixed');\n\n  this[symbols.schemaMixedSymbol] = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaMixed.schemaName = 'Mixed';\n\nSchemaMixed.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaMixed.prototype = Object.create(SchemaType.prototype);\nSchemaMixed.prototype.constructor = SchemaMixed;\n\n/**\n * Attaches a getter for all Mixed paths.\n *\n * #### Example:\n *\n *     // Hide the 'hidden' path\n *     mongoose.Schema.Mixed.get(v => Object.assign({}, v, { hidden: null }));\n *\n *     const Model = mongoose.model('Test', new Schema({ test: {} }));\n *     new Model({ test: { hidden: 'Secret!' } }).test.hidden; // null\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaMixed.get = SchemaType.get;\n\n/**\n * Sets a default option for all Mixed instances.\n *\n * #### Example:\n *\n *     // Make all mixed instances have `required` of true by default.\n *     mongoose.Schema.Mixed.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.Mixed }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaMixed.set = SchemaType.set;\n\nSchemaMixed.setters = [];\n\n/**\n * Casts `val` for Mixed.\n *\n * _this is a no-op_\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaMixed.prototype.cast = function(val) {\n  if (val instanceof Error) {\n    return utils.errorToPOJO(val);\n  }\n  return val;\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nSchemaMixed.prototype.castForQuery = function($cond, val) {\n  return val;\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\n// eslint-disable-next-line no-unused-vars\nSchemaMixed.prototype.toJSONSchema = function toJSONSchema(_options) {\n  return {};\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaMixed;\n"],"names":[],"mappings":"AAAA;;CAEC,GAID,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN;;;;;;;CAOC,GAED,SAAS,YAAY,IAAI,EAAE,OAAO;IAChC,IAAI,WAAW,QAAQ,OAAO,EAAE;QAC9B,MAAM,MAAM,QAAQ,OAAO;QAC3B,IAAI,MAAM,OAAO,CAAC,QAAQ,IAAI,MAAM,KAAK,GAAG;YAC1C,6CAA6C;YAC7C,QAAQ,OAAO,GAAG;QACpB,OAAO,IAAI,CAAC,QAAQ,MAAM,IAAI,SAAS,QAAQ,OAAO,IAAI,CAAC,KAAK,MAAM,KAAK,GAAG;YAC5E,iDAAiD;YACjD,QAAQ,OAAO,GAAG;gBAChB,OAAO,CAAC;YACV;QACF;IACF;IAEA,WAAW,IAAI,CAAC,IAAI,EAAE,MAAM,SAAS;IAErC,IAAI,CAAC,QAAQ,iBAAiB,CAAC,GAAG;AACpC;AAEA;;;;;CAKC,GACD,YAAY,UAAU,GAAG;AAEzB,YAAY,cAAc,GAAG,CAAC;AAE9B;;CAEC,GACD,YAAY,SAAS,GAAG,OAAO,MAAM,CAAC,WAAW,SAAS;AAC1D,YAAY,SAAS,CAAC,WAAW,GAAG;AAEpC;;;;;;;;;;;;;;;;CAgBC,GAED,YAAY,GAAG,GAAG,WAAW,GAAG;AAEhC;;;;;;;;;;;;;;;;;CAiBC,GAED,YAAY,GAAG,GAAG,WAAW,GAAG;AAEhC,YAAY,OAAO,GAAG,EAAE;AAExB;;;;;;;CAOC,GAED,YAAY,SAAS,CAAC,IAAI,GAAG,SAAS,GAAG;IACvC,IAAI,eAAe,OAAO;QACxB,OAAO,MAAM,WAAW,CAAC;IAC3B;IACA,OAAO;AACT;AAEA;;;;;;CAMC,GAED,YAAY,SAAS,CAAC,YAAY,GAAG,SAAS,KAAK,EAAE,GAAG;IACtD,OAAO;AACT;AAEA;;;;;;CAMC,GAED,0CAA0C;AAC1C,YAAY,SAAS,CAAC,YAAY,GAAG,SAAS,aAAa,QAAQ;IACjE,OAAO,CAAC;AACV;AAEA;;CAEC,GAED,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 154, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/operators/text.js"],"sourcesContent":["'use strict';\n\nconst CastError = require('../../error/cast');\nconst castBoolean = require('../../cast/boolean');\nconst castString = require('../../cast/string');\n\n/**\n * Casts val to an object suitable for `$text`. Throws an error if the object\n * can't be casted.\n *\n * @param {Any} val value to cast\n * @param {String} [path] path to associate with any errors that occured\n * @return {Object} casted object\n * @see https://www.mongodb.com/docs/manual/reference/operator/query/text/\n * @api private\n */\n\nmodule.exports = function castTextSearch(val, path) {\n  if (val == null || typeof val !== 'object') {\n    throw new CastError('$text', val, path);\n  }\n\n  if (val.$search != null) {\n    val.$search = castString(val.$search, path + '.$search');\n  }\n  if (val.$language != null) {\n    val.$language = castString(val.$language, path + '.$language');\n  }\n  if (val.$caseSensitive != null) {\n    val.$caseSensitive = castBoolean(val.$caseSensitive,\n      path + '.$castSensitive');\n  }\n  if (val.$diacriticSensitive != null) {\n    val.$diacriticSensitive = castBoolean(val.$diacriticSensitive,\n      path + '.$diacriticSensitive');\n  }\n\n  return val;\n};\n"],"names":[],"mappings":"AAEA,MAAM;AACN,MAAM;AACN,MAAM;AAEN;;;;;;;;;CASC,GAED,OAAO,OAAO,GAAG,SAAS,eAAe,GAAG,EAAE,IAAI;IAChD,IAAI,OAAO,QAAQ,OAAO,QAAQ,UAAU;QAC1C,MAAM,IAAI,UAAU,SAAS,KAAK;IACpC;IAEA,IAAI,IAAI,OAAO,IAAI,MAAM;QACvB,IAAI,OAAO,GAAG,WAAW,IAAI,OAAO,EAAE,OAAO;IAC/C;IACA,IAAI,IAAI,SAAS,IAAI,MAAM;QACzB,IAAI,SAAS,GAAG,WAAW,IAAI,SAAS,EAAE,OAAO;IACnD;IACA,IAAI,IAAI,cAAc,IAAI,MAAM;QAC9B,IAAI,cAAc,GAAG,YAAY,IAAI,cAAc,EACjD,OAAO;IACX;IACA,IAAI,IAAI,mBAAmB,IAAI,MAAM;QACnC,IAAI,mBAAmB,GAAG,YAAY,IAAI,mBAAmB,EAC3D,OAAO;IACX;IAEA,OAAO;AACT","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 188, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/operators/bitwise.js"],"sourcesContent":["/*!\n * Module requirements.\n */\n\n'use strict';\n\nconst CastError = require('../../error/cast');\n\n/*!\n * ignore\n */\n\nfunction handleBitwiseOperator(val) {\n  const _this = this;\n  if (Array.isArray(val)) {\n    return val.map(function(v) {\n      return _castNumber(_this.path, v);\n    });\n  } else if (Buffer.isBuffer(val)) {\n    return val;\n  }\n  // Assume trying to cast to number\n  return _castNumber(_this.path, val);\n}\n\n/*!\n * ignore\n */\n\nfunction _castNumber(path, num) {\n  const v = Number(num);\n  if (isNaN(v)) {\n    throw new CastError('number', num, path);\n  }\n  return v;\n}\n\nmodule.exports = handleBitwiseOperator;\n"],"names":[],"mappings":"AAAA;;CAEC,GAID,MAAM;AAEN;;CAEC,GAED,SAAS,sBAAsB,GAAG;IAChC,MAAM,QAAQ,IAAI;IAClB,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,OAAO,IAAI,GAAG,CAAC,SAAS,CAAC;YACvB,OAAO,YAAY,MAAM,IAAI,EAAE;QACjC;IACF,OAAO,IAAI,OAAO,QAAQ,CAAC,MAAM;QAC/B,OAAO;IACT;IACA,kCAAkC;IAClC,OAAO,YAAY,MAAM,IAAI,EAAE;AACjC;AAEA;;CAEC,GAED,SAAS,YAAY,IAAI,EAAE,GAAG;IAC5B,MAAM,IAAI,OAAO;IACjB,IAAI,MAAM,IAAI;QACZ,MAAM,IAAI,UAAU,UAAU,KAAK;IACrC;IACA,OAAO;AACT;AAEA,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 219, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/number.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module requirements.\n */\n\nconst MongooseError = require('../error/index');\nconst SchemaNumberOptions = require('../options/schemaNumberOptions');\nconst SchemaType = require('../schemaType');\nconst castNumber = require('../cast/number');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst handleBitwiseOperator = require('./operators/bitwise');\nconst utils = require('../utils');\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Number SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaNumber(key, options) {\n  SchemaType.call(this, key, options, 'Number');\n}\n\n/**\n * Attaches a getter for all Number instances.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Number.get(function(v) { return Math.floor(v); });\n *\n *     const Model = mongoose.model('Test', new Schema({ test: Number }));\n *     new Model({ test: 3.14 }).test; // 3\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaNumber.get = SchemaType.get;\n\n/**\n * Sets a default option for all Number instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Number.set('min', 0);\n *\n *     const Order = mongoose.model('Order', new Schema({ amount: Number }));\n *     new Order({ amount: -10 }).validateSync().errors.amount.message; // Path `amount` must be larger than 0.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaNumber.set = SchemaType.set;\n\nSchemaNumber.setters = [];\n\n/*!\n * ignore\n */\n\nSchemaNumber._cast = castNumber;\n\n/**\n * Get/set the function used to cast arbitrary values to numbers.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty strings '' to 0 for paths declared as numbers\n *     const original = mongoose.Number.cast();\n *     mongoose.Number.cast(v => {\n *       if (v === '') { return 0; }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Number.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function cast\n * @static\n * @api public\n */\n\nSchemaNumber.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaNumber._defaultCaster = v => {\n  if (typeof v !== 'number') {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaNumber.schemaName = 'Number';\n\nSchemaNumber.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaNumber.prototype = Object.create(SchemaType.prototype);\nSchemaNumber.prototype.constructor = SchemaNumber;\nSchemaNumber.prototype.OptionsConstructor = SchemaNumberOptions;\n\n/*!\n * ignore\n */\n\nSchemaNumber._checkRequired = v => typeof v === 'number' || v instanceof Number;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaNumber.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaNumber.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaNumber.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum number validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, min: 10 })\n *     const M = db.model('M', s)\n *     const m = new M({ n: 9 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [10, 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ n: { type: Number, min: min })\n *     const M = mongoose.model('Measurement', schema);\n *     const s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) is beneath the limit (10).\n *     })\n *\n * @param {Number} value minimum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.min;\n    msg = msg.replace(/{MIN}/, value);\n    this.validators.push({\n      validator: this.minValidator = function(v) {\n        return v == null || v >= value;\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum number validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, max: 10 })\n *     const M = db.model('M', s)\n *     const m = new M({ n: 11 })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.n = 10;\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [10, 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ n: { type: Number, max: max })\n *     const M = mongoose.model('Measurement', schema);\n *     const s= new M({ n: 4 });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `n` (4) exceeds the limit (10).\n *     })\n *\n * @param {Number} maximum number\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.Number.max;\n    msg = msg.replace(/{MAX}/, value);\n    this.validators.push({\n      validator: this.maxValidator = function(v) {\n        return v == null || v <= value;\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a enum validator\n *\n * #### Example:\n *\n *     const s = new Schema({ n: { type: Number, enum: [1, 2, 3] });\n *     const M = db.model('M', s);\n *\n *     const m = new M({ n: 4 });\n *     await m.save(); // throws validation error\n *\n *     m.n = 3;\n *     await m.save(); // succeeds\n *\n * @param {Array} values allowed values\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaNumber.prototype.enum = function(values, message) {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n  }\n\n\n  if (!Array.isArray(values)) {\n    const isObjectSyntax = utils.isPOJO(values) && values.values != null;\n    if (isObjectSyntax) {\n      message = values.message;\n      values = values.values;\n    } else if (typeof values === 'number') {\n      values = Array.prototype.slice.call(arguments);\n      message = null;\n    }\n\n    if (utils.isPOJO(values)) {\n      values = Object.values(values);\n    }\n    message = message || MongooseError.messages.Number.enum;\n  }\n\n  message = message == null ? MongooseError.messages.Number.enum : message;\n\n  this.enumValidator = v => v == null || values.indexOf(v) !== -1;\n  this.validators.push({\n    validator: this.enumValidator,\n    message: message,\n    type: 'enum',\n    enumValues: values\n  });\n\n  return this;\n};\n\n/**\n * Casts to number\n *\n * @param {Object} value value to cast\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaNumber.prototype.cast = function(value, doc, init, prev, options) {\n  if (typeof value !== 'number' && SchemaType._isRef(this, value, doc, init)) {\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init, options);\n    }\n  }\n\n  const val = value && typeof value._id !== 'undefined' ?\n    value._id : // documents\n    value;\n\n  let castNumber;\n  if (typeof this._castFunction === 'function') {\n    castNumber = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castNumber = this.constructor.cast();\n  } else {\n    castNumber = SchemaNumber.cast();\n  }\n\n  try {\n    return castNumber(val);\n  } catch (err) {\n    throw new CastError('Number', val, this.path, err, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nfunction handleArray(val) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.cast(val)];\n  }\n  return val.map(function(m) {\n    return _this.cast(m);\n  });\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $mod: handleArray\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$gte` is the function Mongoose calls to cast `$gte` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaNumber\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaNumber.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaNumber.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new CastError('number', val, this.path, null, this);\n    }\n    return handler.call(this, val, context);\n  }\n\n  try {\n    val = this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n\n  return val;\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaNumber.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = (this.options.required && typeof this.options.required !== 'function') || this.path === '_id';\n  return createJSONSchemaTypeDefinition('number', 'number', options?.useBsonType, isRequired);\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaNumber;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 614, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/operators/helpers.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module requirements.\n */\n\nconst SchemaNumber = require('../number');\n\n/*!\n * ignore\n */\n\nexports.castToNumber = castToNumber;\nexports.castArraysOfNumbers = castArraysOfNumbers;\n\n/*!\n * ignore\n */\n\nfunction castToNumber(val) {\n  return SchemaNumber.cast()(val);\n}\n\nfunction castArraysOfNumbers(arr, self) {\n  arr.forEach(function(v, i) {\n    if (Array.isArray(v)) {\n      castArraysOfNumbers(v, self);\n    } else {\n      arr[i] = castToNumber.call(self, v);\n    }\n  });\n}\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,MAAM;AAEN;;CAEC,GAED,QAAQ,YAAY,GAAG;AACvB,QAAQ,mBAAmB,GAAG;AAE9B;;CAEC,GAED,SAAS,aAAa,GAAG;IACvB,OAAO,aAAa,IAAI,GAAG;AAC7B;AAEA,SAAS,oBAAoB,GAAG,EAAE,IAAI;IACpC,IAAI,OAAO,CAAC,SAAS,CAAC,EAAE,CAAC;QACvB,IAAI,MAAM,OAAO,CAAC,IAAI;YACpB,oBAAoB,GAAG;QACzB,OAAO;YACL,GAAG,CAAC,EAAE,GAAG,aAAa,IAAI,CAAC,MAAM;QACnC;IACF;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 639, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/operators/geospatial.js"],"sourcesContent":["/*!\n * Module requirements.\n */\n\n'use strict';\n\nconst castArraysOfNumbers = require('./helpers').castArraysOfNumbers;\nconst castToNumber = require('./helpers').castToNumber;\n\n/*!\n * ignore\n */\n\nexports.cast$geoIntersects = cast$geoIntersects;\nexports.cast$near = cast$near;\nexports.cast$within = cast$within;\n\nfunction cast$near(val) {\n  const SchemaArray = require('../array');\n\n  if (Array.isArray(val)) {\n    castArraysOfNumbers(val, this);\n    return val;\n  }\n\n  _castMinMaxDistance(this, val);\n\n  if (val && val.$geometry) {\n    return cast$geometry(val, this);\n  }\n\n  if (!Array.isArray(val)) {\n    throw new TypeError('$near must be either an array or an object ' +\n      'with a $geometry property');\n  }\n\n  return SchemaArray.prototype.castForQuery.call(this, null, val);\n}\n\nfunction cast$geometry(val, self) {\n  switch (val.$geometry.type) {\n    case 'Polygon':\n    case 'LineString':\n    case 'Point':\n      castArraysOfNumbers(val.$geometry.coordinates, self);\n      break;\n    default:\n      // ignore unknowns\n      break;\n  }\n\n  _castMinMaxDistance(self, val);\n\n  return val;\n}\n\nfunction cast$within(val) {\n  _castMinMaxDistance(this, val);\n\n  if (val.$box || val.$polygon) {\n    const type = val.$box ? '$box' : '$polygon';\n    val[type].forEach(arr => {\n      if (!Array.isArray(arr)) {\n        const msg = 'Invalid $within $box argument. '\n            + 'Expected an array, received ' + arr;\n        throw new TypeError(msg);\n      }\n      arr.forEach((v, i) => {\n        arr[i] = castToNumber.call(this, v);\n      });\n    });\n  } else if (val.$center || val.$centerSphere) {\n    const type = val.$center ? '$center' : '$centerSphere';\n    val[type].forEach((item, i) => {\n      if (Array.isArray(item)) {\n        item.forEach((v, j) => {\n          item[j] = castToNumber.call(this, v);\n        });\n      } else {\n        val[type][i] = castToNumber.call(this, item);\n      }\n    });\n  } else if (val.$geometry) {\n    cast$geometry(val, this);\n  }\n\n  return val;\n}\n\nfunction cast$geoIntersects(val) {\n  const geo = val.$geometry;\n  if (!geo) {\n    return;\n  }\n\n  cast$geometry(val, this);\n  return val;\n}\n\nfunction _castMinMaxDistance(self, val) {\n  if (val.$maxDistance) {\n    val.$maxDistance = castToNumber.call(self, val.$maxDistance);\n  }\n  if (val.$minDistance) {\n    val.$minDistance = castToNumber.call(self, val.$minDistance);\n  }\n}\n"],"names":[],"mappings":"AAAA;;CAEC,GAID,MAAM,sBAAsB,sHAAqB,mBAAmB;AACpE,MAAM,eAAe,sHAAqB,YAAY;AAEtD;;CAEC,GAED,QAAQ,kBAAkB,GAAG;AAC7B,QAAQ,SAAS,GAAG;AACpB,QAAQ,WAAW,GAAG;AAEtB,SAAS,UAAU,GAAG;IACpB,MAAM;IAEN,IAAI,MAAM,OAAO,CAAC,MAAM;QACtB,oBAAoB,KAAK,IAAI;QAC7B,OAAO;IACT;IAEA,oBAAoB,IAAI,EAAE;IAE1B,IAAI,OAAO,IAAI,SAAS,EAAE;QACxB,OAAO,cAAc,KAAK,IAAI;IAChC;IAEA,IAAI,CAAC,MAAM,OAAO,CAAC,MAAM;QACvB,MAAM,IAAI,UAAU,gDAClB;IACJ;IAEA,OAAO,YAAY,SAAS,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM;AAC7D;AAEA,SAAS,cAAc,GAAG,EAAE,IAAI;IAC9B,OAAQ,IAAI,SAAS,CAAC,IAAI;QACxB,KAAK;QACL,KAAK;QACL,KAAK;YACH,oBAAoB,IAAI,SAAS,CAAC,WAAW,EAAE;YAC/C;QACF;YAEE;IACJ;IAEA,oBAAoB,MAAM;IAE1B,OAAO;AACT;AAEA,SAAS,YAAY,GAAG;IACtB,oBAAoB,IAAI,EAAE;IAE1B,IAAI,IAAI,IAAI,IAAI,IAAI,QAAQ,EAAE;QAC5B,MAAM,OAAO,IAAI,IAAI,GAAG,SAAS;QACjC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAA;YAChB,IAAI,CAAC,MAAM,OAAO,CAAC,MAAM;gBACvB,MAAM,MAAM,oCACN,iCAAiC;gBACvC,MAAM,IAAI,UAAU;YACtB;YACA,IAAI,OAAO,CAAC,CAAC,GAAG;gBACd,GAAG,CAAC,EAAE,GAAG,aAAa,IAAI,CAAC,IAAI,EAAE;YACnC;QACF;IACF,OAAO,IAAI,IAAI,OAAO,IAAI,IAAI,aAAa,EAAE;QAC3C,MAAM,OAAO,IAAI,OAAO,GAAG,YAAY;QACvC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,MAAM;YACvB,IAAI,MAAM,OAAO,CAAC,OAAO;gBACvB,KAAK,OAAO,CAAC,CAAC,GAAG;oBACf,IAAI,CAAC,EAAE,GAAG,aAAa,IAAI,CAAC,IAAI,EAAE;gBACpC;YACF,OAAO;gBACL,GAAG,CAAC,KAAK,CAAC,EAAE,GAAG,aAAa,IAAI,CAAC,IAAI,EAAE;YACzC;QACF;IACF,OAAO,IAAI,IAAI,SAAS,EAAE;QACxB,cAAc,KAAK,IAAI;IACzB;IAEA,OAAO;AACT;AAEA,SAAS,mBAAmB,GAAG;IAC7B,MAAM,MAAM,IAAI,SAAS;IACzB,IAAI,CAAC,KAAK;QACR;IACF;IAEA,cAAc,KAAK,IAAI;IACvB,OAAO;AACT;AAEA,SAAS,oBAAoB,IAAI,EAAE,GAAG;IACpC,IAAI,IAAI,YAAY,EAAE;QACpB,IAAI,YAAY,GAAG,aAAa,IAAI,CAAC,MAAM,IAAI,YAAY;IAC7D;IACA,IAAI,IAAI,YAAY,EAAE;QACpB,IAAI,YAAY,GAAG,aAAa,IAAI,CAAC,MAAM,IAAI,YAAY;IAC7D;AACF","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 725, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/array.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst $exists = require('./operators/exists');\nconst $type = require('./operators/type');\nconst MongooseError = require('../error/mongooseError');\nconst SchemaArrayOptions = require('../options/schemaArrayOptions');\nconst SchemaType = require('../schemaType');\nconst CastError = SchemaType.CastError;\nconst Mixed = require('./mixed');\nconst VirtualOptions = require('../options/virtualOptions');\nconst VirtualType = require('../virtualType');\nconst arrayDepth = require('../helpers/arrayDepth');\nconst cast = require('../cast');\nconst clone = require('../helpers/clone');\nconst getConstructorName = require('../helpers/getConstructorName');\nconst isOperator = require('../helpers/query/isOperator');\nconst util = require('util');\nconst utils = require('../utils');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst geospatial = require('./operators/geospatial');\nconst getDiscriminatorByValue = require('../helpers/discriminator/getDiscriminatorByValue');\n\nlet MongooseArray;\nlet EmbeddedDoc;\n\nconst isNestedArraySymbol = Symbol('mongoose#isNestedArray');\nconst emptyOpts = Object.freeze({});\n\n/**\n * Array SchemaType constructor\n *\n * @param {String} key\n * @param {SchemaType} cast\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaArray(key, cast, options, schemaOptions) {\n  // lazy load\n  EmbeddedDoc || (EmbeddedDoc = require('../types').Embedded);\n\n  let typeKey = 'type';\n  if (schemaOptions && schemaOptions.typeKey) {\n    typeKey = schemaOptions.typeKey;\n  }\n  this.schemaOptions = schemaOptions;\n\n  if (cast) {\n    let castOptions = {};\n\n    if (utils.isPOJO(cast)) {\n      if (cast[typeKey]) {\n        // support { type: Woot }\n        castOptions = clone(cast); // do not alter user arguments\n        delete castOptions[typeKey];\n        cast = cast[typeKey];\n      } else {\n        cast = Mixed;\n      }\n    }\n\n    if (options != null && options.ref != null && castOptions.ref == null) {\n      castOptions.ref = options.ref;\n    }\n\n    if (cast === Object) {\n      cast = Mixed;\n    }\n\n    // support { type: 'String' }\n    const name = typeof cast === 'string'\n      ? cast\n      : utils.getFunctionName(cast);\n\n    const Types = require('./index.js');\n    const caster = Types.hasOwnProperty(name) ? Types[name] : cast;\n\n    this.casterConstructor = caster;\n\n    if (this.casterConstructor instanceof SchemaArray) {\n      this.casterConstructor[isNestedArraySymbol] = true;\n    }\n\n    if (typeof caster === 'function' &&\n        !caster.$isArraySubdocument &&\n        !caster.$isSchemaMap) {\n      const path = this.caster instanceof EmbeddedDoc ? null : key;\n      this.caster = new caster(path, castOptions);\n    } else {\n      this.caster = caster;\n      if (!(this.caster instanceof EmbeddedDoc)) {\n        this.caster.path = key;\n      }\n    }\n\n    this.$embeddedSchemaType = this.caster;\n  }\n\n  this.$isMongooseArray = true;\n\n  SchemaType.call(this, key, options, 'Array');\n\n  let defaultArr;\n  let fn;\n\n  if (this.defaultValue != null) {\n    defaultArr = this.defaultValue;\n    fn = typeof defaultArr === 'function';\n  }\n\n  if (!('defaultValue' in this) || this.defaultValue != null) {\n    const defaultFn = function() {\n      // Leave it up to `cast()` to convert the array\n      return fn\n        ? defaultArr.call(this)\n        : defaultArr != null\n          ? [].concat(defaultArr)\n          : [];\n    };\n    defaultFn.$runBeforeSetters = !fn;\n    this.default(defaultFn);\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaArray.schemaName = 'Array';\n\n\n/**\n * Options for all arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @static\n * @api public\n */\n\nSchemaArray.options = { castNonArrays: true };\n\n/*!\n * ignore\n */\n\nSchemaArray.defaultOptions = {};\n\n/**\n * Sets a default option for all Array instances.\n *\n * #### Example:\n *\n *     // Make all Array instances have `required` of true by default.\n *     mongoose.Schema.Array.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Array }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @api public\n */\nSchemaArray.set = SchemaType.set;\n\nSchemaArray.setters = [];\n\n/**\n * Attaches a getter for all Array instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaArray.get = SchemaType.get;\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaArray.prototype = Object.create(SchemaType.prototype);\nSchemaArray.prototype.constructor = SchemaArray;\nSchemaArray.prototype.OptionsConstructor = SchemaArrayOptions;\n\n/*!\n * ignore\n */\n\nSchemaArray._checkRequired = SchemaType.prototype.checkRequired;\n\n/**\n * Override the function the required validator uses to check whether an array\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Require non-empty array to pass `required` check\n *     mongoose.Schema.Types.Array.checkRequired(v => Array.isArray(v) && v.length);\n *\n *     const M = mongoose.model({ arr: { type: Array, required: true } });\n *     new M({ arr: [] }).validateSync(); // `null`, validation fails!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @api public\n */\n\nSchemaArray.checkRequired = SchemaType.checkRequired;\n\n/*!\n * Virtuals defined on this array itself.\n */\n\nSchemaArray.prototype.virtuals = null;\n\n/**\n * Check if the given value satisfies the `required` validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaArray.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaArray.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Adds an enum validator if this is an array of strings or numbers. Equivalent to\n * `SchemaString.prototype.enum()` or `SchemaNumber.prototype.enum()`\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaArray} this\n */\n\nSchemaArray.prototype.enum = function() {\n  let arr = this;\n  while (true) {\n    const instance = arr &&\n    arr.caster &&\n    arr.caster.instance;\n    if (instance === 'Array') {\n      arr = arr.caster;\n      continue;\n    }\n    if (instance !== 'String' && instance !== 'Number') {\n      throw new Error('`enum` can only be set on an array of strings or numbers ' +\n        ', not ' + instance);\n    }\n    break;\n  }\n\n  let enumArray = arguments;\n  if (!Array.isArray(arguments) && utils.isObject(arguments)) {\n    enumArray = utils.object.vals(enumArray);\n  }\n\n  arr.caster.enum.apply(arr.caster, enumArray);\n  return this;\n};\n\n/**\n * Overrides the getters application for the population special-case\n *\n * @param {Object} value\n * @param {Object} scope\n * @api private\n */\n\nSchemaArray.prototype.applyGetters = function(value, scope) {\n  if (scope != null && scope.$__ != null && scope.$populated(this.path)) {\n    // means the object id was populated\n    return value;\n  }\n\n  const ret = SchemaType.prototype.applyGetters.call(this, value, scope);\n  return ret;\n};\n\nSchemaArray.prototype._applySetters = function(value, scope, init, priorVal) {\n  if (this.casterConstructor.$isMongooseArray &&\n      SchemaArray.options.castNonArrays &&\n      !this[isNestedArraySymbol]) {\n    // Check nesting levels and wrap in array if necessary\n    let depth = 0;\n    let arr = this;\n    while (arr != null &&\n      arr.$isMongooseArray &&\n      !arr.$isMongooseDocumentArray) {\n      ++depth;\n      arr = arr.casterConstructor;\n    }\n\n    // No need to wrap empty arrays\n    if (value != null && value.length !== 0) {\n      const valueDepth = arrayDepth(value);\n      if (valueDepth.min === valueDepth.max && valueDepth.max < depth && valueDepth.containsNonArrayItem) {\n        for (let i = valueDepth.max; i < depth; ++i) {\n          value = [value];\n        }\n      }\n    }\n  }\n\n  return SchemaType.prototype._applySetters.call(this, value, scope, init, priorVal);\n};\n\n/**\n * Casts values for set().\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  let i;\n  let l;\n\n  if (Array.isArray(value)) {\n    const len = value.length;\n    if (!len && doc) {\n      const indexes = doc.schema.indexedPaths();\n\n      const arrayPath = this.path;\n      for (i = 0, l = indexes.length; i < l; ++i) {\n        const pathIndex = indexes[i][0][arrayPath];\n        if (pathIndex === '2dsphere' || pathIndex === '2d') {\n          return;\n        }\n      }\n\n      // Special case: if this index is on the parent of what looks like\n      // GeoJSON, skip setting the default to empty array re: #1668, #3233\n      const arrayGeojsonPath = this.path.endsWith('.coordinates') ?\n        this.path.substring(0, this.path.lastIndexOf('.')) : null;\n      if (arrayGeojsonPath != null) {\n        for (i = 0, l = indexes.length; i < l; ++i) {\n          const pathIndex = indexes[i][0][arrayGeojsonPath];\n          if (pathIndex === '2dsphere') {\n            return;\n          }\n        }\n      }\n    }\n\n    options = options || emptyOpts;\n\n    let rawValue = utils.isMongooseArray(value) ? value.__array : value;\n    let path = options.path || this.path;\n    if (options.arrayPathIndex != null) {\n      path += '.' + options.arrayPathIndex;\n    }\n    value = MongooseArray(rawValue, path, doc, this);\n    rawValue = value.__array;\n\n    if (init && doc != null && doc.$__ != null && doc.$populated(this.path)) {\n      return value;\n    }\n\n    const caster = this.caster;\n    const isMongooseArray = caster.$isMongooseArray;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        const len = rawValue.length;\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (isMongooseArray) {\n            if (options.arrayPath != null) {\n              opts.arrayPathIndex = i;\n            } else if (caster._arrayParentPath != null) {\n              opts.arrayPathIndex = i;\n            }\n          }\n          if (options.hydratedPopulatedDocs) {\n            opts.hydratedPopulatedDocs = options.hydratedPopulatedDocs;\n          }\n          rawValue[i] = caster.applySetters(rawValue[i], doc, init, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  const castNonArraysOption = this.options.castNonArrays != null ? this.options.castNonArrays : SchemaArray.options.castNonArrays;\n  if (init || castNonArraysOption) {\n    // gh-2442: if we're loading this from the db and its not an array, mark\n    // the whole array as modified.\n    if (!!doc && !!init) {\n      doc.markModified(this.path);\n    }\n    return this.cast([value], doc, init);\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype._castForPopulate = function _castForPopulate(value, doc) {\n  // lazy load\n  MongooseArray || (MongooseArray = require('../types').Array);\n\n  if (Array.isArray(value)) {\n    let i;\n    const rawValue = value.__array ? value.__array : value;\n    const len = rawValue.length;\n\n    const caster = this.caster;\n    if (caster && this.casterConstructor !== Mixed) {\n      try {\n        for (i = 0; i < len; i++) {\n          const opts = {};\n          // Perf: creating `arrayPath` is expensive for large arrays.\n          // We only need `arrayPath` if this is a nested array, so\n          // skip if possible.\n          if (caster.$isMongooseArray && caster._arrayParentPath != null) {\n            opts.arrayPathIndex = i;\n          }\n\n          rawValue[i] = caster.cast(rawValue[i], doc, false, void 0, opts);\n        }\n      } catch (e) {\n        // rethrow\n        throw new CastError('[' + e.kind + ']', util.inspect(value), this.path + '.' + i, e, this);\n      }\n    }\n\n    return value;\n  }\n\n  throw new CastError('Array', util.inspect(value), this.path, null, this);\n};\n\nSchemaArray.prototype.$toObject = SchemaArray.prototype.toObject;\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.discriminator = function(...args) {\n  let arr = this;\n  while (arr.$isMongooseArray && !arr.$isMongooseDocumentArray) {\n    arr = arr.casterConstructor;\n    if (arr == null || typeof arr === 'function') {\n      throw new MongooseError('You can only add an embedded discriminator on ' +\n        'a document array, ' + this.path + ' is a plain array');\n    }\n  }\n  return arr.discriminator(...args);\n};\n\n/*!\n * ignore\n */\n\nSchemaArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.caster, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  return schematype;\n};\n\nSchemaArray.prototype._castForQuery = function(val, context) {\n  let Constructor = this.casterConstructor;\n\n  if (val &&\n      Constructor.discriminators &&\n      Constructor.schema &&\n      Constructor.schema.options &&\n      Constructor.schema.options.discriminatorKey) {\n    if (typeof val[Constructor.schema.options.discriminatorKey] === 'string' &&\n        Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]]) {\n      Constructor = Constructor.discriminators[val[Constructor.schema.options.discriminatorKey]];\n    } else {\n      const constructorByValue = getDiscriminatorByValue(Constructor.discriminators, val[Constructor.schema.options.discriminatorKey]);\n      if (constructorByValue) {\n        Constructor = constructorByValue;\n      }\n    }\n  }\n\n  const proto = this.casterConstructor.prototype;\n  const protoCastForQuery = proto && proto.castForQuery;\n  const protoCast = proto && proto.cast;\n  const constructorCastForQuery = Constructor.castForQuery;\n  const caster = this.caster;\n\n  if (Array.isArray(val)) {\n    this.setters.reverse().forEach(setter => {\n      val = setter.call(this, val, this);\n    });\n    val = val.map(function(v) {\n      if (utils.isObject(v) && v.$elemMatch) {\n        return v;\n      }\n      if (protoCastForQuery) {\n        v = protoCastForQuery.call(caster, null, v, context);\n        return v;\n      } else if (protoCast) {\n        v = protoCast.call(caster, v);\n        return v;\n      } else if (constructorCastForQuery) {\n        v = constructorCastForQuery.call(caster, null, v, context);\n        return v;\n      }\n      if (v != null) {\n        v = new Constructor(v);\n        return v;\n      }\n      return v;\n    });\n  } else if (protoCastForQuery) {\n    val = protoCastForQuery.call(caster, null, val, context);\n  } else if (protoCast) {\n    val = protoCast.call(caster, val);\n  } else if (constructorCastForQuery) {\n    val = constructorCastForQuery.call(caster, null, val, context);\n  } else if (val != null) {\n    val = new Constructor(val);\n  }\n\n  return val;\n};\n\n/**\n * Casts values for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaArray.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Array.');\n    }\n\n    return handler.call(this, val, context);\n  } else {\n    return this._castForQuery(val, context);\n  }\n};\n\n/**\n * Add a virtual to this array. Specifically to this array, not the individual elements.\n *\n * @param {String} name\n * @param {Object} [options]\n * @api private\n */\n\nSchemaArray.prototype.virtual = function virtual(name, options) {\n  if (name instanceof VirtualType || getConstructorName(name) === 'VirtualType') {\n    return this.virtual(name.path, name.options);\n  }\n  options = new VirtualOptions(options);\n\n  if (utils.hasUserDefinedProperty(options, ['ref', 'refPath'])) {\n    throw new MongooseError('Cannot set populate virtual as a property of an array');\n  }\n\n  const virtual = new VirtualType(options, name);\n  if (this.virtuals === null) {\n    this.virtuals = {};\n  }\n  this.virtuals[name] = virtual;\n  return virtual;\n};\n\nfunction cast$all(val, context) {\n  if (!Array.isArray(val)) {\n    val = [val];\n  }\n\n  val = val.map((v) => {\n    if (!utils.isObject(v)) {\n      return v;\n    }\n    if (v.$elemMatch != null) {\n      return { $elemMatch: cast(this.casterConstructor.schema, v.$elemMatch, null, this && this.$$context) };\n    }\n\n    const o = {};\n    o[this.path] = v;\n    return cast(this.casterConstructor.schema, o, null, this && this.$$context)[this.path];\n  }, this);\n\n  return this.castForQuery(null, val, context);\n}\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  return val;\n}\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$all` is the function Mongoose calls to cast `$all` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaArray\n * @instance\n * @api public\n */\n\nconst handle = SchemaArray.prototype.$conditionalHandlers = {};\n\nhandle.$all = cast$all;\nhandle.$options = String;\nhandle.$elemMatch = cast$elemMatch;\nhandle.$geoIntersects = geospatial.cast$geoIntersects;\nhandle.$or = createLogicalQueryOperatorHandler('$or');\nhandle.$and = createLogicalQueryOperatorHandler('$and');\nhandle.$nor = createLogicalQueryOperatorHandler('$nor');\n\nfunction createLogicalQueryOperatorHandler(op) {\n  return function logicalQueryOperatorHandler(val, context) {\n    if (!Array.isArray(val)) {\n      throw new TypeError('conditional ' + op + ' requires an array');\n    }\n\n    const ret = [];\n    for (const obj of val) {\n      ret.push(cast(this.casterConstructor.schema ?? context.schema, obj, null, this && this.$$context));\n    }\n\n    return ret;\n  };\n}\n\nhandle.$near =\nhandle.$nearSphere = geospatial.cast$near;\n\nhandle.$within =\nhandle.$geoWithin = geospatial.cast$within;\n\nhandle.$size =\nhandle.$minDistance =\nhandle.$maxDistance = castToNumber;\n\nhandle.$exists = $exists;\nhandle.$type = $type;\n\nhandle.$eq =\nhandle.$gt =\nhandle.$gte =\nhandle.$lt =\nhandle.$lte =\nhandle.$not =\nhandle.$regex =\nhandle.$ne = SchemaArray.prototype._castForQuery;\n\n// `$in` is special because you can also include an empty array in the query\n// like `$in: [1, []]`, see gh-5913\nhandle.$nin = SchemaType.prototype.$conditionalHandlers.$nin;\nhandle.$in = SchemaType.prototype.$conditionalHandlers.$in;\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaArray.prototype.toJSONSchema = function toJSONSchema(options) {\n  const embeddedSchemaType = this.getEmbeddedSchemaType();\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return {\n    ...createJSONSchemaTypeDefinition('array', 'array', options?.useBsonType, isRequired),\n    items: embeddedSchemaType.toJSONSchema(options)\n  };\n};\n\nSchemaArray.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'array';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaArray;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1307, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/bigint.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst SchemaType = require('../schemaType');\nconst castBigInt = require('../cast/bigint');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\n\n/**\n * BigInt SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBigInt(path, options) {\n  SchemaType.call(this, path, options, 'BigInt');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBigInt.schemaName = 'BigInt';\n\nSchemaBigInt.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBigInt.prototype = Object.create(SchemaType.prototype);\nSchemaBigInt.prototype.constructor = SchemaBigInt;\n\n/*!\n * ignore\n */\n\nSchemaBigInt._cast = castBigInt;\n\n/**\n * Sets a default option for all BigInt instances.\n *\n * #### Example:\n *\n *     // Make all bigints required by default\n *     mongoose.Schema.BigInt.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBigInt.set = SchemaType.set;\n\nSchemaBigInt.setters = [];\n\n/**\n * Attaches a getter for all BigInt instances\n *\n * #### Example:\n *\n *     // Convert bigints to numbers\n *     mongoose.Schema.BigInt.get(v => v == null ? v : Number(v));\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBigInt.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to bigints.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty string '' to false.\n *     const original = mongoose.Schema.Types.BigInt.cast();\n *     mongoose.Schema.BigInt.cast(v => {\n *       if (v === '') {\n *         return false;\n *       }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.BigInt.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function cast\n * @static\n * @api public\n */\n\nSchemaBigInt.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaBigInt._checkRequired = v => v != null;\n\n/**\n * Override the function the required validator uses to check whether a value\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBigInt.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBigInt.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts to bigint\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaBigInt.prototype.cast = function(value) {\n  let castBigInt;\n  if (typeof this._castFunction === 'function') {\n    castBigInt = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castBigInt = this.constructor.cast();\n  } else {\n    castBigInt = SchemaBigInt.cast();\n  }\n\n  try {\n    return castBigInt(value);\n  } catch (error) {\n    throw new CastError('BigInt', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$in` is the function Mongoose calls to cast `$in` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaBigInt\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaBigInt.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBigInt.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n *\n * @api private\n */\n\nSchemaBigInt.prototype._castNullish = function _castNullish(v) {\n  if (typeof v === 'undefined') {\n    return v;\n  }\n  const castBigInt = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaBigInt.cast();\n  if (castBigInt == null) {\n    return v;\n  }\n  return v;\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaBigInt.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('string', 'long', options?.useBsonType, isRequired);\n};\n\nSchemaBigInt.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'long';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBigInt;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1525, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/boolean.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst SchemaType = require('../schemaType');\nconst castBoolean = require('../cast/boolean');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\n\n/**\n * Boolean SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBoolean(path, options) {\n  SchemaType.call(this, path, options, 'Boolean');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBoolean.schemaName = 'Boolean';\n\nSchemaBoolean.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBoolean.prototype = Object.create(SchemaType.prototype);\nSchemaBoolean.prototype.constructor = SchemaBoolean;\n\n/*!\n * ignore\n */\n\nSchemaBoolean._cast = castBoolean;\n\n/**\n * Sets a default option for all Boolean instances.\n *\n * #### Example:\n *\n *     // Make all booleans have `default` of false.\n *     mongoose.Schema.Boolean.set('default', false);\n *\n *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\n *     new Order({ }).isPaid; // false\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBoolean.set = SchemaType.set;\n\nSchemaBoolean.setters = [];\n\n/**\n * Attaches a getter for all Boolean instances\n *\n * #### Example:\n *\n *     mongoose.Schema.Boolean.get(v => v === true ? 'yes' : 'no');\n *\n *     const Order = mongoose.model('Order', new Schema({ isPaid: Boolean }));\n *     new Order({ isPaid: false }).isPaid; // 'no'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBoolean.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to booleans.\n *\n * #### Example:\n *\n *     // Make Mongoose cast empty string '' to false.\n *     const original = mongoose.Schema.Boolean.cast();\n *     mongoose.Schema.Boolean.cast(v => {\n *       if (v === '') {\n *         return false;\n *       }\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Boolean.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function cast\n * @static\n * @api public\n */\n\nSchemaBoolean.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaBoolean._defaultCaster = v => {\n  if (v != null && typeof v !== 'boolean') {\n    throw new Error();\n  }\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaBoolean._checkRequired = v => v === true || v === false;\n\n/**\n * Override the function the required validator uses to check whether a boolean\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBoolean.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. For a boolean\n * to satisfy a required validator, it must be strictly equal to true or to\n * false.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaBoolean.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Configure which values get casted to `true`.\n *\n * #### Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'affirmative' }).b; // undefined\n *     mongoose.Schema.Boolean.convertToTrue.add('affirmative');\n *     new M({ b: 'affirmative' }).b; // true\n *\n * @property convertToTrue\n * @static\n * @memberOf SchemaBoolean\n * @type {Set}\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToTrue', {\n  get: () => castBoolean.convertToTrue,\n  set: v => { castBoolean.convertToTrue = v; }\n});\n\n/**\n * Configure which values get casted to `false`.\n *\n * #### Example:\n *\n *     const M = mongoose.model('Test', new Schema({ b: Boolean }));\n *     new M({ b: 'nay' }).b; // undefined\n *     mongoose.Schema.Types.Boolean.convertToFalse.add('nay');\n *     new M({ b: 'nay' }).b; // false\n *\n * @property convertToFalse\n * @static\n * @memberOf SchemaBoolean\n * @type {Set}\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean, 'convertToFalse', {\n  get: () => castBoolean.convertToFalse,\n  set: v => { castBoolean.convertToFalse = v; }\n});\n\n/**\n * Casts to boolean\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaBoolean.prototype.cast = function(value) {\n  let castBoolean;\n  if (typeof this._castFunction === 'function') {\n    castBoolean = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castBoolean = this.constructor.cast();\n  } else {\n    castBoolean = SchemaBoolean.cast();\n  }\n\n  try {\n    return castBoolean(value);\n  } catch (error) {\n    throw new CastError('Boolean', value, this.path, error, this);\n  }\n};\n\nconst $conditionalHandlers = { ...SchemaType.prototype.$conditionalHandlers };\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$in` is the function Mongoose calls to cast `$in` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaBoolean\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaBoolean.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaBoolean.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n *\n * @api private\n */\n\nSchemaBoolean.prototype._castNullish = function _castNullish(v) {\n  if (typeof v === 'undefined') {\n    return v;\n  }\n  const castBoolean = typeof this.constructor.cast === 'function' ?\n    this.constructor.cast() :\n    SchemaBoolean.cast();\n  if (castBoolean == null) {\n    return v;\n  }\n  if (castBoolean.convertToFalse instanceof Set && castBoolean.convertToFalse.has(v)) {\n    return false;\n  }\n  if (castBoolean.convertToTrue instanceof Set && castBoolean.convertToTrue.has(v)) {\n    return true;\n  }\n  return v;\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaBoolean.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('boolean', 'bool', options?.useBsonType, isRequired);\n};\n\nSchemaBoolean.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'bool';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBoolean;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1795, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/buffer.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseBuffer = require('../types/buffer');\nconst SchemaBufferOptions = require('../options/schemaBufferOptions');\nconst SchemaType = require('../schemaType');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst handleBitwiseOperator = require('./operators/bitwise');\nconst utils = require('../utils');\n\nconst Binary = MongooseBuffer.Binary;\nconst CastError = SchemaType.CastError;\n\n/**\n * Buffer SchemaType constructor\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaBuffer(key, options) {\n  SchemaType.call(this, key, options, 'Buffer');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaBuffer.schemaName = 'Buffer';\n\nSchemaBuffer.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaBuffer.prototype = Object.create(SchemaType.prototype);\nSchemaBuffer.prototype.constructor = SchemaBuffer;\nSchemaBuffer.prototype.OptionsConstructor = SchemaBufferOptions;\n\n/*!\n * ignore\n */\n\nSchemaBuffer._checkRequired = v => !!(v && v.length);\n\n/**\n * Sets a default option for all Buffer instances.\n *\n * #### Example:\n *\n *     // Make all buffers have `required` of true by default.\n *     mongoose.Schema.Buffer.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Buffer }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaBuffer.set = SchemaType.set;\n\nSchemaBuffer.setters = [];\n\n/**\n * Attaches a getter for all Buffer instances\n *\n * #### Example:\n *\n *     // Always convert to string when getting an ObjectId\n *     mongoose.Schema.Types.Buffer.get(v => v.toString('hex'));\n *\n *     const Model = mongoose.model('Test', new Schema({ buf: Buffer } }));\n *     typeof (new Model({ buf: Buffer.fromString('hello') }).buf); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaBuffer.get = SchemaType.get;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ buf: { type: Buffer, required: true } });\n *     new M({ buf: Buffer.from('') }).validateSync(); // validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaBuffer.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy a\n * required validator, a buffer must not be null or undefined and have\n * non-zero length.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaBuffer.prototype.checkRequired = function(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} doc document that triggers the casting\n * @param {Boolean} init\n * @api private\n */\n\nSchemaBuffer.prototype.cast = function(value, doc, init, prev, options) {\n  let ret;\n  if (SchemaType._isRef(this, value, doc, init)) {\n    if (value && value.isMongooseBuffer) {\n      return value;\n    }\n\n    if (Buffer.isBuffer(value)) {\n      if (!value || !value.isMongooseBuffer) {\n        value = new MongooseBuffer(value, [this.path, doc]);\n        if (this.options.subtype != null) {\n          value._subtype = this.options.subtype;\n        }\n      }\n      return value;\n    }\n\n    if (value instanceof Binary) {\n      ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n      if (typeof value.sub_type !== 'number') {\n        throw new CastError('Buffer', value, this.path, null, this);\n      }\n      ret._subtype = value.sub_type;\n      return ret;\n    }\n\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init, options);\n    }\n  }\n\n  // documents\n  if (value && value._id) {\n    value = value._id;\n  }\n\n  if (value && value.isMongooseBuffer) {\n    return value;\n  }\n\n  if (Buffer.isBuffer(value)) {\n    if (!value || !value.isMongooseBuffer) {\n      value = new MongooseBuffer(value, [this.path, doc]);\n      if (this.options.subtype != null) {\n        value._subtype = this.options.subtype;\n      }\n    }\n    return value;\n  }\n\n  if (value instanceof Binary) {\n    ret = new MongooseBuffer(value.value(true), [this.path, doc]);\n    if (typeof value.sub_type !== 'number') {\n      throw new CastError('Buffer', value, this.path, null, this);\n    }\n    ret._subtype = value.sub_type;\n    return ret;\n  }\n\n  if (value === null) {\n    return value;\n  }\n\n\n  const type = typeof value;\n  if (\n    type === 'string' || type === 'number' || Array.isArray(value) ||\n    (type === 'object' && value.type === 'Buffer' && Array.isArray(value.data)) // gh-6863\n  ) {\n    if (type === 'number') {\n      value = [value];\n    }\n    ret = new MongooseBuffer(value, [this.path, doc]);\n    if (this.options.subtype != null) {\n      ret._subtype = this.options.subtype;\n    }\n    return ret;\n  }\n\n  if (utils.isPOJO(value) && (value.$binary instanceof Binary || typeof value.$binary === 'string')) {\n    const buf = this.cast(Buffer.from(value.$binary, 'base64'));\n    if (value.$type != null) {\n      buf._subtype = value.$type;\n      return buf;\n    }\n  }\n\n  throw new CastError('Buffer', value, this.path, null, this);\n};\n\n/**\n * Sets the default [subtype](https://studio3t.com/whats-new/best-practices-uuid-mongodb/)\n * for this buffer. You can find a [list of allowed subtypes here](https://api.mongodb.com/python/current/api/bson/binary.html).\n *\n * #### Example:\n *\n *     const s = new Schema({ uuid: { type: Buffer, subtype: 4 });\n *     const M = db.model('M', s);\n *     const m = new M({ uuid: 'test string' });\n *     m.uuid._subtype; // 4\n *\n * @param {Number} subtype the default subtype\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaBuffer.prototype.subtype = function(subtype) {\n  this.options.subtype = subtype;\n  return this;\n};\n\n/*!\n * ignore\n */\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$exists` is the function Mongoose calls to cast `$exists` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaBuffer\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaBuffer.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaBuffer.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with Buffer.');\n    }\n    return handler.call(this, val);\n  }\n\n  let casted;\n  try {\n    casted = this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n  return casted ? casted.toObject({ transform: false, virtuals: false }) : casted;\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaBuffer.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('string', 'binData', options?.useBsonType, isRequired);\n};\n\nSchemaBuffer.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'binData';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaBuffer;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2093, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/date.js"],"sourcesContent":["/*!\n * Module requirements.\n */\n\n'use strict';\n\nconst MongooseError = require('../error/index');\nconst SchemaDateOptions = require('../options/schemaDateOptions');\nconst SchemaType = require('../schemaType');\nconst castDate = require('../cast/date');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst getConstructorName = require('../helpers/getConstructorName');\nconst utils = require('../utils');\n\nconst CastError = SchemaType.CastError;\n\n/**\n * Date SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDate(key, options) {\n  SchemaType.call(this, key, options, 'Date');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDate.schemaName = 'Date';\n\nSchemaDate.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDate.prototype = Object.create(SchemaType.prototype);\nSchemaDate.prototype.constructor = SchemaDate;\nSchemaDate.prototype.OptionsConstructor = SchemaDateOptions;\n\n/*!\n * ignore\n */\n\nSchemaDate._cast = castDate;\n\n/**\n * Sets a default option for all Date instances.\n *\n * #### Example:\n *\n *     // Make all dates have `required` of true by default.\n *     mongoose.Schema.Date.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: Date }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDate.set = SchemaType.set;\n\nSchemaDate.setters = [];\n\n/**\n * Attaches a getter for all Date instances\n *\n * #### Example:\n *\n *     // Always convert Dates to string\n *     mongoose.Date.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({ date: { type: Date, default: () => new Date() } }));\n *     typeof (new Model({}).date); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDate.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to dates.\n *\n * #### Example:\n *\n *     // Mongoose converts empty string '' into `null` for date types. You\n *     // can create a custom caster to disable it.\n *     const original = mongoose.Schema.Types.Date.cast();\n *     mongoose.Schema.Types.Date.cast(v => {\n *       assert.ok(v !== '');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.Date.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function cast\n * @static\n * @api public\n */\n\nSchemaDate.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._defaultCaster = v => {\n  if (v != null && !(v instanceof Date)) {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Declares a TTL index (rounded to the nearest second) for _Date_ types only.\n *\n * This sets the `expireAfterSeconds` index option available in MongoDB >= 2.1.2.\n * This index type is only compatible with Date types.\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: 60*60*24 }});\n *\n * `expires` utilizes the `ms` module from [vercel](https://github.com/vercel/ms) allowing us to use a friendlier syntax:\n *\n * #### Example:\n *\n *     // expire in 24 hours\n *     new Schema({ createdAt: { type: Date, expires: '24h' }});\n *\n *     // expire in 1.5 hours\n *     new Schema({ createdAt: { type: Date, expires: '1.5h' }});\n *\n *     // expire in 7 days\n *     const schema = new Schema({ createdAt: Date });\n *     schema.path('createdAt').expires('7d');\n *\n * @param {Number|String} when\n * @added 3.0.0\n * @return {SchemaType} this\n * @api public\n */\n\nSchemaDate.prototype.expires = function(when) {\n  if (getConstructorName(this._index) !== 'Object') {\n    this._index = {};\n  }\n\n  this._index.expires = when;\n  utils.expires(this._index);\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaDate._checkRequired = v => v instanceof Date;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDate.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator. To satisfy\n * a required validator, the given value must be an instance of `Date`.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDate.prototype.checkRequired = function(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDate.checkRequired();\n  return _checkRequired(value);\n};\n\n/**\n * Sets a minimum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, min: Date('1970-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('1969-12-31') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2014-12-08');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MIN} token which will be replaced with the invalid value\n *     const min = [Date('1970-01-01'), 'The value of path `{PATH}` ({VALUE}) is beneath the limit ({MIN}).'];\n *     const schema = new Schema({ d: { type: Date, min: min })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('1969-12-31') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (1969-12-31) is before the limit (1970-01-01).\n *     })\n *\n * @param {Date} value minimum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.min = function(value, message) {\n  if (this.minValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.min;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MIN}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.minValidator = function(val) {\n        let _value = value;\n        if (typeof value === 'function' && value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const min = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() >= min.valueOf();\n      },\n      message: msg,\n      type: 'min',\n      min: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Sets a maximum date validator.\n *\n * #### Example:\n *\n *     const s = new Schema({ d: { type: Date, max: Date('2014-01-01') })\n *     const M = db.model('M', s)\n *     const m = new M({ d: Date('2014-12-08') })\n *     m.save(function (err) {\n *       console.error(err) // validator error\n *       m.d = Date('2013-12-31');\n *       m.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAX} token which will be replaced with the invalid value\n *     const max = [Date('2014-01-01'), 'The value of path `{PATH}` ({VALUE}) exceeds the limit ({MAX}).'];\n *     const schema = new Schema({ d: { type: Date, max: max })\n *     const M = mongoose.model('M', schema);\n *     const s= new M({ d: Date('2014-12-08') });\n *     s.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `d` (2014-12-08) exceeds the limit (2014-01-01).\n *     })\n *\n * @param {Date} maximum date\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaDate.prototype.max = function(value, message) {\n  if (this.maxValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxValidator;\n    }, this);\n  }\n\n  if (value) {\n    let msg = message || MongooseError.messages.Date.max;\n    if (typeof msg === 'string') {\n      msg = msg.replace(/{MAX}/, (value === Date.now ? 'Date.now()' : value.toString()));\n    }\n    const _this = this;\n    this.validators.push({\n      validator: this.maxValidator = function(val) {\n        let _value = value;\n        if (typeof _value === 'function' && _value !== Date.now) {\n          _value = _value.call(this);\n        }\n        const max = (_value === Date.now ? _value() : _this.cast(_value));\n        return val === null || val.valueOf() <= max.valueOf();\n      },\n      message: msg,\n      type: 'max',\n      max: value\n    });\n  }\n\n  return this;\n};\n\n/**\n * Casts to date\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDate.prototype.cast = function(value) {\n  let castDate;\n  if (typeof this._castFunction === 'function') {\n    castDate = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDate = this.constructor.cast();\n  } else {\n    castDate = SchemaDate.cast();\n  }\n\n  try {\n    return castDate(value);\n  } catch (error) {\n    throw new CastError('date', value, this.path, error, this);\n  }\n};\n\n/**\n * Date Query casting.\n *\n * @param {Any} val\n * @api private\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$gte` is the function Mongoose calls to cast `$gte` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaDate\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaDate.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [value]\n * @api private\n */\n\nSchemaDate.prototype.castForQuery = function($conditional, val, context) {\n  if ($conditional == null) {\n    try {\n      return this.applySetters(val, context);\n    } catch (err) {\n      if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n        err.path = this.$fullPath;\n      }\n      throw err;\n    }\n  }\n\n  const handler = this.$conditionalHandlers[$conditional];\n\n  if (!handler) {\n    throw new Error('Can\\'t use ' + $conditional + ' with Date.');\n  }\n\n  return handler.call(this, val);\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaDate.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('string', 'date', options?.useBsonType, isRequired);\n};\n\nSchemaDate.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'date';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDate;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2482, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/decimal128.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst SchemaType = require('../schemaType');\nconst CastError = SchemaType.CastError;\nconst castDecimal128 = require('../cast/decimal128');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst isBsonType = require('../helpers/isBsonType');\n\n/**\n * Decimal128 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDecimal128(key, options) {\n  SchemaType.call(this, key, options, 'Decimal128');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDecimal128.schemaName = 'Decimal128';\n\nSchemaDecimal128.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDecimal128.prototype = Object.create(SchemaType.prototype);\nSchemaDecimal128.prototype.constructor = SchemaDecimal128;\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._cast = castDecimal128;\n\n/**\n * Sets a default option for all Decimal128 instances.\n *\n * #### Example:\n *\n *     // Make all decimal 128s have `required` of true by default.\n *     mongoose.Schema.Decimal128.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.Decimal128 }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDecimal128.set = SchemaType.set;\n\nSchemaDecimal128.setters = [];\n\n/**\n * Attaches a getter for all Decimal128 instances\n *\n * #### Example:\n *\n *     // Automatically convert Decimal128s to Numbers\n *     mongoose.Schema.Decimal128.get(v => v == null ? v : Number(v));\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDecimal128.get = SchemaType.get;\n\n/**\n * Get/set the function used to cast arbitrary values to decimals.\n *\n * #### Example:\n *\n *     // Make Mongoose only refuse to cast numbers as decimal128\n *     const original = mongoose.Schema.Types.Decimal128.cast();\n *     mongoose.Decimal128.cast(v => {\n *       assert.ok(typeof v !== 'number');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Decimal128.cast(false);\n *\n * @param {Function} [caster]\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDecimal128.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._defaultCaster = v => {\n  if (v != null && !isBsonType(v, 'Decimal128')) {\n    throw new Error();\n  }\n  return v;\n};\n\n/*!\n * ignore\n */\n\nSchemaDecimal128._checkRequired = v => isBsonType(v, 'Decimal128');\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDecimal128.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaDecimal128.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaDecimal128.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to Decimal128\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaDecimal128.prototype.cast = function(value, doc, init, prev, options) {\n  if (SchemaType._isRef(this, value, doc, init)) {\n    if (isBsonType(value, 'Decimal128')) {\n      return value;\n    }\n\n    return this._castRef(value, doc, init, options);\n  }\n\n  let castDecimal128;\n  if (typeof this._castFunction === 'function') {\n    castDecimal128 = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDecimal128 = this.constructor.cast();\n  } else {\n    castDecimal128 = SchemaDecimal128.cast();\n  }\n\n  try {\n    return castDecimal128(value);\n  } catch (error) {\n    throw new CastError('Decimal128', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$lte` is the function Mongoose calls to cast `$lte` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaDecimal128\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaDecimal128.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaDecimal128.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('string', 'decimal', options?.useBsonType, isRequired);\n};\n\nSchemaDecimal128.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'decimal';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDecimal128;\n"],"names":[],"mappings":"AAAA;;CAEC,GAID,MAAM;AACN,MAAM,YAAY,WAAW,SAAS;AACtC,MAAM;AACN,MAAM;AACN,MAAM;AAEN;;;;;;;CAOC,GAED,SAAS,iBAAiB,GAAG,EAAE,OAAO;IACpC,WAAW,IAAI,CAAC,IAAI,EAAE,KAAK,SAAS;AACtC;AAEA;;;;;CAKC,GACD,iBAAiB,UAAU,GAAG;AAE9B,iBAAiB,cAAc,GAAG,CAAC;AAEnC;;CAEC,GACD,iBAAiB,SAAS,GAAG,OAAO,MAAM,CAAC,WAAW,SAAS;AAC/D,iBAAiB,SAAS,CAAC,WAAW,GAAG;AAEzC;;CAEC,GAED,iBAAiB,KAAK,GAAG;AAEzB;;;;;;;;;;;;;;;;;CAiBC,GAED,iBAAiB,GAAG,GAAG,WAAW,GAAG;AAErC,iBAAiB,OAAO,GAAG,EAAE;AAE7B;;;;;;;;;;;;;CAaC,GAED,iBAAiB,GAAG,GAAG,WAAW,GAAG;AAErC;;;;;;;;;;;;;;;;;;;;CAoBC,GAED,iBAAiB,IAAI,GAAG,SAAS,KAAK,MAAM;IAC1C,IAAI,UAAU,MAAM,KAAK,GAAG;QAC1B,OAAO,IAAI,CAAC,KAAK;IACnB;IACA,IAAI,WAAW,OAAO;QACpB,SAAS,IAAI,CAAC,cAAc;IAC9B;IACA,IAAI,CAAC,KAAK,GAAG;IAEb,OAAO,IAAI,CAAC,KAAK;AACnB;AAEA;;CAEC,GAED,iBAAiB,cAAc,GAAG,CAAA;IAChC,IAAI,KAAK,QAAQ,CAAC,WAAW,GAAG,eAAe;QAC7C,MAAM,IAAI;IACZ;IACA,OAAO;AACT;AAEA;;CAEC,GAED,iBAAiB,cAAc,GAAG,CAAA,IAAK,WAAW,GAAG;AAErD;;;;;;;;;CASC,GAED,iBAAiB,aAAa,GAAG,WAAW,aAAa;AAEzD;;;;;;;CAOC,GAED,iBAAiB,SAAS,CAAC,aAAa,GAAG,SAAS,cAAc,KAAK,EAAE,GAAG;IAC1E,IAAI,WAAW,MAAM,CAAC,IAAI,EAAE,OAAO,KAAK,OAAO;QAC7C,OAAO,CAAC,CAAC;IACX;IAEA,wEAAwE;IACxE,4DAA4D;IAC5D,MAAM,iBAAiB,OAAO,IAAI,CAAC,WAAW,CAAC,aAAa,KAAK,aAC/D,IAAI,CAAC,WAAW,CAAC,aAAa,KAC9B,iBAAiB,aAAa;IAEhC,OAAO,eAAe;AACxB;AAEA;;;;;;;CAOC,GAED,iBAAiB,SAAS,CAAC,IAAI,GAAG,SAAS,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO;IACxE,IAAI,WAAW,MAAM,CAAC,IAAI,EAAE,OAAO,KAAK,OAAO;QAC7C,IAAI,WAAW,OAAO,eAAe;YACnC,OAAO;QACT;QAEA,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,KAAK,MAAM;IACzC;IAEA,IAAI;IACJ,IAAI,OAAO,IAAI,CAAC,aAAa,KAAK,YAAY;QAC5C,iBAAiB,IAAI,CAAC,aAAa;IACrC,OAAO,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,KAAK,YAAY;QACtD,iBAAiB,IAAI,CAAC,WAAW,CAAC,IAAI;IACxC,OAAO;QACL,iBAAiB,iBAAiB,IAAI;IACxC;IAEA,IAAI;QACF,OAAO,eAAe;IACxB,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,UAAU,cAAc,OAAO,IAAI,CAAC,IAAI,EAAE,OAAO,IAAI;IACjE;AACF;AAEA;;CAEC,GAED,SAAS,aAAa,GAAG;IACvB,OAAO,IAAI,CAAC,IAAI,CAAC;AACnB;AAEA,MAAM,uBAAuB;IAC3B,GAAG,WAAW,SAAS,CAAC,oBAAoB;IAC5C,KAAK;IACL,MAAM;IACN,KAAK;IACL,MAAM;AACR;AAEA;;;;;;;;CAQC,GAED,OAAO,cAAc,CAAC,iBAAiB,SAAS,EAAE,wBAAwB;IACxE,YAAY;IACZ,OAAO;AACT;AAEA;;;;;;CAMC,GAED,iBAAiB,SAAS,CAAC,YAAY,GAAG,SAAS,aAAa,OAAO;IACrE,MAAM,aAAa,IAAI,CAAC,OAAO,CAAC,QAAQ,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK;IAC7E,OAAO,+BAA+B,UAAU,WAAW,SAAS,aAAa;AACnF;AAEA,iBAAiB,SAAS,CAAC,kBAAkB,GAAG,SAAS;IACvD,OAAO;AACT;AAEA;;CAEC,GAED,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 2685, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/subdocument.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst EventEmitter = require('events').EventEmitter;\nconst ObjectExpectedError = require('../error/objectExpected');\nconst SchemaSubdocumentOptions = require('../options/schemaSubdocumentOptions');\nconst SchemaType = require('../schemaType');\nconst applyDefaults = require('../helpers/document/applyDefaults');\nconst $exists = require('./operators/exists');\nconst castToNumber = require('./operators/helpers').castToNumber;\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst discriminator = require('../helpers/model/discriminator');\nconst geospatial = require('./operators/geospatial');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst internalToObjectOptions = require('../options').internalToObjectOptions;\nconst isExclusive = require('../helpers/projection/isExclusive');\nconst utils = require('../utils');\nconst InvalidSchemaOptionError = require('../error/invalidSchemaOption');\n\nlet SubdocumentType;\n\nmodule.exports = SchemaSubdocument;\n\n/**\n * Single nested subdocument SchemaType constructor.\n *\n * @param {Schema} schema\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaSubdocument(schema, path, options) {\n  if (schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(path, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaSubdocument.defaultOptions &&\n    SchemaSubdocument.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    options = options || {};\n    options._id = schemaTypeIdOption;\n  }\n\n  schema = handleIdOption(schema, options);\n\n  this.caster = _createConstructor(schema, null, options);\n  this.caster.path = path;\n  this.caster.prototype.$basePath = path;\n  this.schema = schema;\n  this.$isSingleNested = true;\n  this.base = schema.base;\n  SchemaType.call(this, path, options, 'Embedded');\n}\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype = Object.create(SchemaType.prototype);\nSchemaSubdocument.prototype.constructor = SchemaSubdocument;\nSchemaSubdocument.prototype.OptionsConstructor = SchemaSubdocumentOptions;\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, baseClass, options) {\n  // lazy load\n  SubdocumentType || (SubdocumentType = require('../types/subdocument'));\n\n  const _embedded = function SingleNested(value, path, parent) {\n    this.$__parent = parent;\n    SubdocumentType.apply(this, arguments);\n\n    if (parent == null) {\n      return;\n    }\n    this.$session(parent.$session());\n  };\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : SubdocumentType.prototype;\n  _embedded.prototype = Object.create(proto);\n  _embedded.prototype.$__setSchema(schema);\n  _embedded.prototype.constructor = _embedded;\n  _embedded.prototype.$__schemaTypeOptions = options;\n  _embedded.$__required = options?.required;\n  _embedded.base = schema.base;\n  _embedded.schema = schema;\n  _embedded.$isSingleNested = true;\n  _embedded.events = new EventEmitter();\n  _embedded.prototype.toBSON = function() {\n    return this.toObject(internalToObjectOptions);\n  };\n\n  // apply methods\n  for (const i in schema.methods) {\n    _embedded.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    _embedded[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    _embedded[i] = EventEmitter.prototype[i];\n  }\n\n  return _embedded;\n}\n\n/*!\n * ignore\n */\nconst $conditionalHandlers = { ...SchemaType.prototype.$conditionalHandlers };\n\n/**\n * Special case for when users use a common location schema to represent\n * locations for use with $geoWithin.\n * https://www.mongodb.com/docs/manual/reference/operator/query/geoWithin/\n *\n * @param {Object} val\n * @api private\n */\n\n$conditionalHandlers.$geoWithin = function handle$geoWithin(val, context) {\n  return { $geometry: this.castForQuery(null, val.$geometry, context) };\n};\n\n/*!\n * ignore\n */\n\n$conditionalHandlers.$near =\n$conditionalHandlers.$nearSphere = geospatial.cast$near;\n\n$conditionalHandlers.$within =\n$conditionalHandlers.$geoWithin = geospatial.cast$within;\n\n$conditionalHandlers.$geoIntersects =\n  geospatial.cast$geoIntersects;\n\n$conditionalHandlers.$minDistance = castToNumber;\n$conditionalHandlers.$maxDistance = castToNumber;\n\n$conditionalHandlers.$exists = $exists;\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$exists` is the function Mongoose calls to cast `$exists` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaSubdocument\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaSubdocument.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @api private\n */\n\nSchemaSubdocument.prototype.cast = function(val, doc, init, priorVal, options) {\n  if (val && val.$isSingleNested && val.parent === doc) {\n    return val;\n  }\n\n  if (val != null && (typeof val !== 'object' || Array.isArray(val))) {\n    throw new ObjectExpectedError(this.path, val);\n  }\n\n  const discriminatorKeyPath = this.schema.path(this.schema.options.discriminatorKey);\n  const defaultDiscriminatorValue = discriminatorKeyPath == null ? null : discriminatorKeyPath.getDefault(doc);\n  const Constructor = getConstructor(this.caster, val, defaultDiscriminatorValue);\n\n  let subdoc;\n\n  // Only pull relevant selected paths and pull out the base path\n  const parentSelected = doc && doc.$__ && doc.$__.selected;\n  const path = this.path;\n  const selected = parentSelected == null ? null : Object.keys(parentSelected).reduce((obj, key) => {\n    if (key.startsWith(path + '.')) {\n      obj = obj || {};\n      obj[key.substring(path.length + 1)] = parentSelected[key];\n    }\n    return obj;\n  }, null);\n  if (init) {\n    subdoc = new Constructor(void 0, selected, doc, false, { defaults: false });\n    delete subdoc.$__.defaults;\n    // Don't pass `path` to $init - it's only for the subdocument itself, not its fields.\n    // For change tracking, subdocuments use relative paths internally.\n    // Here, `options.path` contains the absolute path and is only used by the subdocument constructor, not by $init.\n    if (options.path != null) {\n      options = { ...options };\n      delete options.path;\n    }\n    subdoc.$init(val, options);\n    const exclude = isExclusive(selected);\n    applyDefaults(subdoc, selected, exclude);\n  } else {\n    options = Object.assign({}, options, { priorDoc: priorVal });\n    if (Object.keys(val).length === 0) {\n      return new Constructor({}, selected, doc, undefined, options);\n    }\n\n    return new Constructor(val, selected, doc, undefined, options);\n  }\n\n  return subdoc;\n};\n\n/**\n * Casts contents for query\n *\n * @param {string} [$conditional] optional query operator (like `$eq` or `$in`)\n * @param {any} value\n * @api private\n */\n\nSchemaSubdocument.prototype.castForQuery = function($conditional, val, context, options) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional);\n    }\n    return handler.call(this, val);\n  }\n  if (val == null) {\n    return val;\n  }\n\n  const Constructor = getConstructor(this.caster, val);\n  if (val instanceof Constructor) {\n    return val;\n  }\n\n  if (this.options.runSetters) {\n    val = this._applySetters(val, context);\n  }\n\n  const overrideStrict = options != null && options.strict != null ?\n    options.strict :\n    void 0;\n\n  try {\n    val = new Constructor(val, overrideStrict);\n  } catch (error) {\n    // Make sure we always wrap in a CastError (gh-6803)\n    if (!(error instanceof CastError)) {\n      throw new CastError('Embedded', val, this.path, error, this);\n    }\n    throw error;\n  }\n  return val;\n};\n\n/**\n * Async validation on this single nested doc.\n *\n * @api private\n */\n\nSchemaSubdocument.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, null, (scope != null && scope.$__ != null) ? scope : null);\n  }\n\n  if (options && options.skipSchemaValidators) {\n    if (!value) {\n      return fn(null);\n    }\n    return value.validate().then(() => fn(null), err => fn(err));\n  }\n\n  SchemaType.prototype.doValidate.call(this, value, function(error) {\n    if (error) {\n      return fn(error);\n    }\n    if (!value) {\n      return fn(null);\n    }\n\n    value.validate().then(() => fn(null), err => fn(err));\n  }, scope, options);\n};\n\n/**\n * Synchronously validate this single nested doc\n *\n * @api private\n */\n\nSchemaSubdocument.prototype.doValidateSync = function(value, scope, options) {\n  if (!options || !options.skipSchemaValidators) {\n    const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, value, scope);\n    if (schemaTypeError) {\n      return schemaTypeError;\n    }\n  }\n  if (!value) {\n    return;\n  }\n  return value.validateSync();\n};\n\n/**\n * Adds a discriminator to this single nested subdocument.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shape: shapeSchema });\n *\n *     const singleNestedPath = parentSchema.path('shape');\n *     singleNestedPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @api public\n */\n\nSchemaSubdocument.prototype.discriminator = function(name, schema, options) {\n  options = options || {};\n  const value = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean'\n    ? options.clone\n    : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.caster, name, schema, value, null, null, options.overwriteExisting);\n\n  this.caster.discriminators[name] = _createConstructor(schema, this.caster);\n\n  return this.caster.discriminators[name];\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.defaultOptions = {};\n\n/**\n * Sets a default option for all Subdocument instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.Subdocument.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaSubdocument.set = SchemaType.set;\n\nSchemaSubdocument.setters = [];\n\n/**\n * Attaches a getter for all Subdocument instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaSubdocument.get = SchemaType.get;\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.toJSON = function toJSON() {\n  return { path: this.path, options: this.options };\n};\n\n/*!\n * ignore\n */\n\nSchemaSubdocument.prototype.clone = function() {\n  const schematype = new this.constructor(\n    this.schema,\n    this.path,\n    { ...this.options, _skipApplyDiscriminators: true }\n  );\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.caster.discriminators = Object.assign({}, this.caster.discriminators);\n  schematype._appliedDiscriminators = this._appliedDiscriminators;\n  return schematype;\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaSubdocument.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return {\n    ...this.schema.toJSONSchema(options),\n    ...createJSONSchemaTypeDefinition('object', 'object', options?.useBsonType, isRequired)\n  };\n};\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3044, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/documentArrayElement.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseError = require('../error/mongooseError');\nconst SchemaType = require('../schemaType');\nconst SchemaSubdocument = require('./subdocument');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\n\n/**\n * DocumentArrayElement SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDocumentArrayElement(path, options) {\n  this.$parentSchemaType = options && options.$parentSchemaType;\n  if (!this.$parentSchemaType) {\n    throw new MongooseError('Cannot create DocumentArrayElement schematype without a parent');\n  }\n  delete options.$parentSchemaType;\n\n  SchemaType.call(this, path, options, 'DocumentArrayElement');\n\n  this.$isMongooseDocumentArrayElement = true;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArrayElement.schemaName = 'DocumentArrayElement';\n\nSchemaDocumentArrayElement.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDocumentArrayElement.prototype = Object.create(SchemaType.prototype);\nSchemaDocumentArrayElement.prototype.constructor = SchemaDocumentArrayElement;\n\n/**\n * Casts `val` for DocumentArrayElement.\n *\n * @param {Object} value to cast\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.cast = function(...args) {\n  return this.$parentSchemaType.cast(...args)[0];\n};\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $cond\n * @param {any} [val]\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.doValidate = function(value, fn, scope, options) {\n  const Constructor = getConstructor(this.caster, value);\n\n  if (value && !(value instanceof Constructor)) {\n    value = new Constructor(value, scope, null, null, options && options.index != null ? options.index : null);\n  }\n\n  return SchemaSubdocument.prototype.doValidate.call(this, value, fn, scope, options);\n};\n\n/**\n * Clone the current SchemaType\n *\n * @return {DocumentArrayElement} The cloned instance\n * @api private\n */\n\nSchemaDocumentArrayElement.prototype.clone = function() {\n  this.options.$parentSchemaType = this.$parentSchemaType;\n  const ret = SchemaType.prototype.clone.apply(this, arguments);\n  delete this.options.$parentSchemaType;\n\n  ret.caster = this.caster;\n  ret.schema = this.schema;\n\n  return ret;\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArrayElement;\n"],"names":[],"mappings":"AAAA;;CAEC,GAID,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN;;;;;;;CAOC,GAED,SAAS,2BAA2B,IAAI,EAAE,OAAO;IAC/C,IAAI,CAAC,iBAAiB,GAAG,WAAW,QAAQ,iBAAiB;IAC7D,IAAI,CAAC,IAAI,CAAC,iBAAiB,EAAE;QAC3B,MAAM,IAAI,cAAc;IAC1B;IACA,OAAO,QAAQ,iBAAiB;IAEhC,WAAW,IAAI,CAAC,IAAI,EAAE,MAAM,SAAS;IAErC,IAAI,CAAC,+BAA+B,GAAG;AACzC;AAEA;;;;;CAKC,GACD,2BAA2B,UAAU,GAAG;AAExC,2BAA2B,cAAc,GAAG,CAAC;AAE7C;;CAEC,GACD,2BAA2B,SAAS,GAAG,OAAO,MAAM,CAAC,WAAW,SAAS;AACzE,2BAA2B,SAAS,CAAC,WAAW,GAAG;AAEnD;;;;;CAKC,GAED,2BAA2B,SAAS,CAAC,IAAI,GAAG,SAAS,GAAG,IAAI;IAC1D,OAAO,IAAI,CAAC,iBAAiB,CAAC,IAAI,IAAI,KAAK,CAAC,EAAE;AAChD;AAEA;;;;;;CAMC,GAED,2BAA2B,SAAS,CAAC,UAAU,GAAG,SAAS,KAAK,EAAE,EAAE,EAAE,KAAK,EAAE,OAAO;IAClF,MAAM,cAAc,eAAe,IAAI,CAAC,MAAM,EAAE;IAEhD,IAAI,SAAS,CAAC,CAAC,iBAAiB,WAAW,GAAG;QAC5C,QAAQ,IAAI,YAAY,OAAO,OAAO,MAAM,MAAM,WAAW,QAAQ,KAAK,IAAI,OAAO,QAAQ,KAAK,GAAG;IACvG;IAEA,OAAO,kBAAkB,SAAS,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,EAAE,OAAO,IAAI,OAAO;AAC7E;AAEA;;;;;CAKC,GAED,2BAA2B,SAAS,CAAC,KAAK,GAAG;IAC3C,IAAI,CAAC,OAAO,CAAC,iBAAiB,GAAG,IAAI,CAAC,iBAAiB;IACvD,MAAM,MAAM,WAAW,SAAS,CAAC,KAAK,CAAC,KAAK,CAAC,IAAI,EAAE;IACnD,OAAO,IAAI,CAAC,OAAO,CAAC,iBAAiB;IAErC,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM;IACxB,IAAI,MAAM,GAAG,IAAI,CAAC,MAAM;IAExB,OAAO;AACT;AAEA;;CAEC,GAED,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3118, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/documentArray.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst DocumentArrayElement = require('./documentArrayElement');\nconst EventEmitter = require('events').EventEmitter;\nconst SchemaArray = require('./array');\nconst SchemaDocumentArrayOptions =\n  require('../options/schemaDocumentArrayOptions');\nconst SchemaType = require('../schemaType');\nconst cast = require('../cast');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst discriminator = require('../helpers/model/discriminator');\nconst handleIdOption = require('../helpers/schema/handleIdOption');\nconst handleSpreadDoc = require('../helpers/document/handleSpreadDoc');\nconst isOperator = require('../helpers/query/isOperator');\nconst utils = require('../utils');\nconst getConstructor = require('../helpers/discriminator/getConstructor');\nconst InvalidSchemaOptionError = require('../error/invalidSchemaOption');\n\nconst arrayAtomicsSymbol = require('../helpers/symbols').arrayAtomicsSymbol;\nconst arrayPathSymbol = require('../helpers/symbols').arrayPathSymbol;\nconst documentArrayParent = require('../helpers/symbols').documentArrayParent;\n\nlet MongooseDocumentArray;\nlet Subdocument;\n\n/**\n * SubdocsArray SchemaType constructor\n *\n * @param {String} key\n * @param {Schema} schema\n * @param {Object} options\n * @param {Object} schemaOptions\n * @inherits SchemaArray\n * @api public\n */\n\nfunction SchemaDocumentArray(key, schema, options, schemaOptions) {\n  if (schema.options && schema.options.timeseries) {\n    throw new InvalidSchemaOptionError(key, 'timeseries');\n  }\n  const schemaTypeIdOption = SchemaDocumentArray.defaultOptions &&\n    SchemaDocumentArray.defaultOptions._id;\n  if (schemaTypeIdOption != null) {\n    schemaOptions = schemaOptions || {};\n    schemaOptions._id = schemaTypeIdOption;\n  }\n\n  if (schemaOptions != null && schemaOptions._id != null) {\n    schema = handleIdOption(schema, schemaOptions);\n  } else if (options != null && options._id != null) {\n    schema = handleIdOption(schema, options);\n  }\n\n  const EmbeddedDocument = _createConstructor(schema, options);\n  EmbeddedDocument.prototype.$basePath = key;\n\n  SchemaArray.call(this, key, EmbeddedDocument, options);\n\n  this.schema = schema;\n  // EmbeddedDocument schematype options\n  this.schemaOptions = schemaOptions || {};\n  this.$isMongooseDocumentArray = true;\n  this.Constructor = EmbeddedDocument;\n\n  EmbeddedDocument.base = schema.base;\n\n  const fn = this.defaultValue;\n\n  if (!('defaultValue' in this) || fn != null) {\n    this.default(function() {\n      let arr = fn.call(this);\n      if (arr != null && !Array.isArray(arr)) {\n        arr = [arr];\n      }\n      // Leave it up to `cast()` to convert this to a documentarray\n      return arr;\n    });\n  }\n\n  const $parentSchemaType = this;\n  this.$embeddedSchemaType = new DocumentArrayElement(key + '.$', {\n    ...(schemaOptions || {}),\n    $parentSchemaType\n  });\n\n  this.$embeddedSchemaType.caster = this.Constructor;\n  this.$embeddedSchemaType.schema = this.schema;\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDocumentArray.schemaName = 'DocumentArray';\n\n/**\n * Options for all document arrays.\n *\n * - `castNonArrays`: `true` by default. If `false`, Mongoose will throw a CastError when a value isn't an array. If `true`, Mongoose will wrap the provided value in an array before casting.\n *\n * @api public\n */\n\nSchemaDocumentArray.options = { castNonArrays: true };\n\n/*!\n * Inherits from SchemaArray.\n */\nSchemaDocumentArray.prototype = Object.create(SchemaArray.prototype);\nSchemaDocumentArray.prototype.constructor = SchemaDocumentArray;\nSchemaDocumentArray.prototype.OptionsConstructor = SchemaDocumentArrayOptions;\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$size` is the function Mongoose calls to cast `$size` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaDocumentArray\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaDocumentArray.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: { ...SchemaArray.prototype.$conditionalHandlers }\n});\n\n/*!\n * ignore\n */\n\nfunction _createConstructor(schema, options, baseClass) {\n  Subdocument || (Subdocument = require('../types/arraySubdocument'));\n\n  // compile an embedded document for this schema\n  function EmbeddedDocument() {\n    Subdocument.apply(this, arguments);\n    if (this.__parentArray == null || this.__parentArray.getArrayParent() == null) {\n      return;\n    }\n    this.$session(this.__parentArray.getArrayParent().$session());\n  }\n\n  schema._preCompile();\n\n  const proto = baseClass != null ? baseClass.prototype : Subdocument.prototype;\n  EmbeddedDocument.prototype = Object.create(proto);\n  EmbeddedDocument.prototype.$__setSchema(schema);\n  EmbeddedDocument.schema = schema;\n  EmbeddedDocument.prototype.constructor = EmbeddedDocument;\n  EmbeddedDocument.$isArraySubdocument = true;\n  EmbeddedDocument.events = new EventEmitter();\n  EmbeddedDocument.base = schema.base;\n\n  // apply methods\n  for (const i in schema.methods) {\n    EmbeddedDocument.prototype[i] = schema.methods[i];\n  }\n\n  // apply statics\n  for (const i in schema.statics) {\n    EmbeddedDocument[i] = schema.statics[i];\n  }\n\n  for (const i in EventEmitter.prototype) {\n    EmbeddedDocument[i] = EventEmitter.prototype[i];\n  }\n\n  EmbeddedDocument.options = options;\n\n  return EmbeddedDocument;\n}\n\n/**\n * Adds a discriminator to this document array.\n *\n * #### Example:\n *\n *     const shapeSchema = Schema({ name: String }, { discriminatorKey: 'kind' });\n *     const schema = Schema({ shapes: [shapeSchema] });\n *\n *     const docArrayPath = parentSchema.path('shapes');\n *     docArrayPath.discriminator('Circle', Schema({ radius: Number }));\n *\n * @param {String} name\n * @param {Schema} schema fields to add to the schema for instances of this sub-class\n * @param {Object|string} [options] If string, same as `options.value`.\n * @param {String} [options.value] the string stored in the `discriminatorKey` property. If not specified, Mongoose uses the `name` parameter.\n * @param {Boolean} [options.clone=true] By default, `discriminator()` clones the given `schema`. Set to `false` to skip cloning.\n * @see discriminators https://mongoosejs.com/docs/discriminators.html\n * @return {Function} the constructor Mongoose will use for creating instances of this discriminator model\n * @api public\n */\n\nSchemaDocumentArray.prototype.discriminator = function(name, schema, options) {\n  if (typeof name === 'function') {\n    name = utils.getFunctionName(name);\n  }\n\n  options = options || {};\n  const tiedValue = utils.isPOJO(options) ? options.value : options;\n  const clone = typeof options.clone === 'boolean' ? options.clone : true;\n\n  if (schema.instanceOfSchema && clone) {\n    schema = schema.clone();\n  }\n\n  schema = discriminator(this.casterConstructor, name, schema, tiedValue, null, null, options?.overwriteExisting);\n\n  const EmbeddedDocument = _createConstructor(schema, null, this.casterConstructor);\n  EmbeddedDocument.baseCasterConstructor = this.casterConstructor;\n\n  try {\n    Object.defineProperty(EmbeddedDocument, 'name', {\n      value: name\n    });\n  } catch (error) {\n    // Ignore error, only happens on old versions of node\n  }\n\n  this.casterConstructor.discriminators[name] = EmbeddedDocument;\n\n  return this.casterConstructor.discriminators[name];\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc\n *\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidate = function(array, fn, scope, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  const _this = this;\n  try {\n    SchemaType.prototype.doValidate.call(this, array, cb, scope);\n  } catch (err) {\n    return fn(err);\n  }\n\n  function cb(err) {\n    if (err) {\n      return fn(err);\n    }\n\n    let count = array && array.length;\n    let error;\n\n    if (!count) {\n      return fn();\n    }\n    if (options && options.updateValidator) {\n      return fn();\n    }\n    if (!utils.isMongooseDocumentArray(array)) {\n      array = new MongooseDocumentArray(array, _this.path, scope);\n    }\n\n    // handle sparse arrays, do not use array.forEach which does not\n    // iterate over sparse elements yet reports array.length including\n    // them :(\n\n    function callback(err) {\n      if (err != null) {\n        error = err;\n      }\n      --count || fn(error);\n    }\n\n    for (let i = 0, len = count; i < len; ++i) {\n      // sidestep sparse entries\n      let doc = array[i];\n      if (doc == null) {\n        --count || fn(error);\n        continue;\n      }\n\n      // If you set the array index directly, the doc might not yet be\n      // a full fledged mongoose subdoc, so make it into one.\n      if (!(doc instanceof Subdocument)) {\n        const Constructor = getConstructor(_this.casterConstructor, array[i]);\n        doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n      }\n\n      if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n        --count || fn(error);\n        continue;\n      }\n\n      doc.$__validate(null, options, callback);\n    }\n  }\n};\n\n/**\n * Performs local validations first, then validations on each embedded doc.\n *\n * #### Note:\n *\n * This method ignores the asynchronous validators.\n *\n * @return {MongooseError|undefined}\n * @api private\n */\n\nSchemaDocumentArray.prototype.doValidateSync = function(array, scope, options) {\n  const schemaTypeError = SchemaType.prototype.doValidateSync.call(this, array, scope);\n  if (schemaTypeError != null) {\n    return schemaTypeError;\n  }\n\n  const count = array && array.length;\n  let resultError = null;\n\n  if (!count) {\n    return;\n  }\n\n  // handle sparse arrays, do not use array.forEach which does not\n  // iterate over sparse elements yet reports array.length including\n  // them :(\n\n  for (let i = 0, len = count; i < len; ++i) {\n    // sidestep sparse entries\n    let doc = array[i];\n    if (!doc) {\n      continue;\n    }\n\n    // If you set the array index directly, the doc might not yet be\n    // a full fledged mongoose subdoc, so make it into one.\n    if (!(doc instanceof Subdocument)) {\n      const Constructor = getConstructor(this.casterConstructor, array[i]);\n      doc = array[i] = new Constructor(doc, array, undefined, undefined, i);\n    }\n\n    if (options != null && options.validateModifiedOnly && !doc.$isModified()) {\n      continue;\n    }\n\n    const subdocValidateError = doc.validateSync(options);\n\n    if (subdocValidateError && resultError == null) {\n      resultError = subdocValidateError;\n    }\n  }\n\n  return resultError;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.getDefault = function(scope, init, options) {\n  let ret = typeof this.defaultValue === 'function'\n    ? this.defaultValue.call(scope)\n    : this.defaultValue;\n\n  if (ret == null) {\n    return ret;\n  }\n\n  if (options && options.skipCast) {\n    return ret;\n  }\n\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  if (!Array.isArray(ret)) {\n    ret = [ret];\n  }\n\n  ret = new MongooseDocumentArray(ret, this.path, scope);\n\n  for (let i = 0; i < ret.length; ++i) {\n    const Constructor = getConstructor(this.casterConstructor, ret[i]);\n    const _subdoc = new Constructor({}, ret, undefined,\n      undefined, i);\n    _subdoc.$init(ret[i]);\n    _subdoc.isNew = true;\n\n    // Make sure all paths in the subdoc are set to `default` instead\n    // of `init` since we used `init`.\n    Object.assign(_subdoc.$__.activePaths.default, _subdoc.$__.activePaths.init);\n    _subdoc.$__.activePaths.init = {};\n\n    ret[i] = _subdoc;\n  }\n\n  return ret;\n};\n\nconst _toObjectOptions = Object.freeze({ transform: false, virtuals: false });\nconst initDocumentOptions = Object.freeze({ skipId: false, willInit: true });\n\n/**\n * Casts contents\n *\n * @param {Object} value\n * @param {Document} document that triggers the casting\n * @api private\n */\n\nSchemaDocumentArray.prototype.cast = function(value, doc, init, prev, options) {\n  // lazy load\n  MongooseDocumentArray || (MongooseDocumentArray = require('../types/documentArray'));\n\n  // Skip casting if `value` is the same as the previous value, no need to cast. See gh-9266\n  if (value != null && value[arrayPathSymbol] != null && value === prev) {\n    return value;\n  }\n\n  let selected;\n  let subdoc;\n\n  options = options || {};\n\n  const path = options.path || this.path;\n\n  if (!Array.isArray(value)) {\n    if (!init && !SchemaDocumentArray.options.castNonArrays) {\n      throw new CastError('DocumentArray', value, this.path, null, this);\n    }\n    // gh-2442 mark whole array as modified if we're initializing a doc from\n    // the db and the path isn't an array in the document\n    if (!!doc && init) {\n      doc.markModified(path);\n    }\n    return this.cast([value], doc, init, prev, options);\n  }\n\n  // We need to create a new array, otherwise change tracking will\n  // update the old doc (gh-4449)\n  if (!options.skipDocumentArrayCast || utils.isMongooseDocumentArray(value)) {\n    value = new MongooseDocumentArray(value, path, doc, this);\n  }\n\n  if (prev != null) {\n    value[arrayAtomicsSymbol] = prev[arrayAtomicsSymbol] || {};\n  }\n\n  if (options.arrayPathIndex != null) {\n    value[arrayPathSymbol] = path + '.' + options.arrayPathIndex;\n  }\n\n  const rawArray = utils.isMongooseDocumentArray(value) ? value.__array : value;\n  const len = rawArray.length;\n\n  for (let i = 0; i < len; ++i) {\n    if (!rawArray[i]) {\n      continue;\n    }\n\n    const Constructor = getConstructor(this.casterConstructor, rawArray[i]);\n\n    const spreadDoc = handleSpreadDoc(rawArray[i], true);\n    if (rawArray[i] !== spreadDoc) {\n      rawArray[i] = spreadDoc;\n    }\n\n    if (rawArray[i] instanceof Subdocument) {\n      if (rawArray[i][documentArrayParent] !== doc) {\n        if (init) {\n          const subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n          rawArray[i] = subdoc.$init(rawArray[i]);\n        } else {\n          const subdoc = new Constructor(rawArray[i], value, undefined, undefined, i);\n          rawArray[i] = subdoc;\n        }\n      }\n      // Might not have the correct index yet, so ensure it does.\n      if (rawArray[i].__index == null) {\n        rawArray[i].$setIndex(i);\n      }\n    } else if (rawArray[i] != null) {\n      if (init) {\n        if (doc) {\n          selected || (selected = scopePaths(this, doc.$__.selected, init));\n        } else {\n          selected = true;\n        }\n\n        subdoc = new Constructor(null, value, initDocumentOptions, selected, i);\n        rawArray[i] = subdoc.$init(rawArray[i], options);\n      } else {\n        if (prev && typeof prev.id === 'function') {\n          subdoc = prev.id(rawArray[i]._id);\n        }\n\n        if (prev && subdoc && utils.deepEqual(subdoc.toObject(_toObjectOptions), rawArray[i])) {\n          // handle resetting doc with existing id and same data\n          subdoc.set(rawArray[i]);\n          // if set() is hooked it will have no return value\n          // see gh-746\n          rawArray[i] = subdoc;\n        } else {\n          try {\n            subdoc = new Constructor(rawArray[i], value, undefined,\n              undefined, i);\n            // if set() is hooked it will have no return value\n            // see gh-746\n            rawArray[i] = subdoc;\n          } catch (error) {\n            throw new CastError('embedded', rawArray[i],\n              value[arrayPathSymbol], error, this);\n          }\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.clone = function() {\n  const options = Object.assign({}, this.options);\n  const schematype = new this.constructor(this.path, this.schema, options, this.schemaOptions);\n  schematype.validators = this.validators.slice();\n  if (this.requiredValidator !== undefined) {\n    schematype.requiredValidator = this.requiredValidator;\n  }\n  schematype.Constructor.discriminators = Object.assign({},\n    this.Constructor.discriminators);\n  schematype._appliedDiscriminators = this._appliedDiscriminators;\n  return schematype;\n};\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.prototype.applyGetters = function(value, scope) {\n  return SchemaType.prototype.applyGetters.call(this, value, scope);\n};\n\n/**\n * Scopes paths selected in a query to this array.\n * Necessary for proper default application of subdocument values.\n *\n * @param {DocumentArrayPath} array the array to scope `fields` paths\n * @param {Object|undefined} fields the root fields selected in the query\n * @param {Boolean|undefined} init if we are being created part of a query result\n * @api private\n */\n\nfunction scopePaths(array, fields, init) {\n  if (!(init && fields)) {\n    return undefined;\n  }\n\n  const path = array.path + '.';\n  const keys = Object.keys(fields);\n  let i = keys.length;\n  const selected = {};\n  let hasKeys;\n  let key;\n  let sub;\n\n  while (i--) {\n    key = keys[i];\n    if (key.startsWith(path)) {\n      sub = key.substring(path.length);\n      if (sub === '$') {\n        continue;\n      }\n      if (sub.startsWith('$.')) {\n        sub = sub.substring(2);\n      }\n      hasKeys || (hasKeys = true);\n      selected[sub] = fields[key];\n    }\n  }\n\n  return hasKeys && selected || undefined;\n}\n\n/*!\n * ignore\n */\n\nSchemaDocumentArray.defaultOptions = {};\n\n/**\n * Sets a default option for all DocumentArray instances.\n *\n * #### Example:\n *\n *     // Make all numbers have option `min` equal to 0.\n *     mongoose.Schema.DocumentArray.set('_id', false);\n *\n * @param {String} option The name of the option you'd like to set (e.g. trim, lowercase, etc...)\n * @param {Any} value The value of the option you'd like to set.\n * @return {void}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDocumentArray.set = SchemaType.set;\n\nSchemaDocumentArray.setters = [];\n\n/**\n * Attaches a getter for all DocumentArrayPath instances\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDocumentArray.get = SchemaType.get;\n\n/*!\n * Handle casting $elemMatch operators\n */\n\nSchemaDocumentArray.prototype.$conditionalHandlers.$elemMatch = cast$elemMatch;\n\nfunction cast$elemMatch(val, context) {\n  const keys = Object.keys(val);\n  const numKeys = keys.length;\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const value = val[key];\n    if (isOperator(key) && value != null) {\n      val[key] = this.castForQuery(key, value, context);\n    }\n  }\n\n  // Is this an embedded discriminator and is the discriminator key set?\n  // If so, use the discriminator schema. See gh-7449\n  const discriminatorKey = this &&\n    this.casterConstructor &&\n    this.casterConstructor.schema &&\n    this.casterConstructor.schema.options &&\n    this.casterConstructor.schema.options.discriminatorKey;\n  const discriminators = this &&\n  this.casterConstructor &&\n  this.casterConstructor.schema &&\n  this.casterConstructor.schema.discriminators || {};\n  if (discriminatorKey != null &&\n      val[discriminatorKey] != null &&\n      discriminators[val[discriminatorKey]] != null) {\n    return cast(discriminators[val[discriminatorKey]], val, null, this && this.$$context);\n  }\n\n  const schema = this.casterConstructor.schema ?? context.schema;\n  return cast(schema, val, null, this && this.$$context);\n}\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaDocumentArray.prototype.toJSONSchema = function toJSONSchema(options) {\n  const itemsTypeDefinition = createJSONSchemaTypeDefinition('object', 'object', options?.useBsonType, false);\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return {\n    ...createJSONSchemaTypeDefinition('array', 'array', options?.useBsonType, isRequired),\n    items: { ...itemsTypeDefinition, ...this.schema.toJSONSchema(options) }\n  };\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDocumentArray;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3673, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/double.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst SchemaType = require('../schemaType');\nconst castDouble = require('../cast/double');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\n\n/**\n * Double SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaDouble(path, options) {\n  SchemaType.call(this, path, options, 'Double');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaDouble.schemaName = 'Double';\n\nSchemaDouble.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaDouble.prototype = Object.create(SchemaType.prototype);\nSchemaDouble.prototype.constructor = SchemaDouble;\n\n/*!\n * ignore\n */\n\nSchemaDouble._cast = castDouble;\n\n/**\n * Sets a default option for all Double instances.\n *\n * #### Example:\n *\n *     // Make all Double fields required by default\n *     mongoose.Schema.Double.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaDouble.set = SchemaType.set;\n\nSchemaDouble.setters = [];\n\n/**\n * Attaches a getter for all Double instances\n *\n * #### Example:\n *\n *     // Converts Double to be a represent milliseconds upon access\n *     mongoose.Schema.Double.get(v => v == null ? '0.000 ms' : v.toString() + ' ms');\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaDouble.get = SchemaType.get;\n\n/*!\n * ignore\n */\n\nSchemaDouble._defaultCaster = v => {\n  if (v != null) {\n    if (v._bsontype !== 'Double') {\n      throw new Error();\n    }\n  }\n\n  return v;\n};\n\n/**\n * Get/set the function used to cast arbitrary values to  IEEE 754-2008 floating points\n *\n * #### Example:\n *\n *     // Make Mongoose cast any NaNs to 0\n *     const defaultCast = mongoose.Schema.Types.Double.cast();\n *     mongoose.Schema.Types.Double.cast(v => {\n *       if (isNaN(v)) {\n *         return 0;\n *       }\n *       return defaultCast(v);\n *     });\n *\n *     // Or disable casting for Doubles entirely (only JS numbers are permitted)\n *     mongoose.Schema.Double.cast(false);\n *\n *\n * @param {Function} caster\n * @return {Function}\n * @function cast\n * @static\n * @api public\n */\n\nSchemaDouble.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n\n  this._cast = caster;\n\n  return this._cast;\n};\n\n\n/*!\n * ignore\n */\n\nSchemaDouble._checkRequired = v => v != null;\n/**\n * Override the function the required validator uses to check whether a value\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaDouble.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaDouble.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts to Double\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaDouble.prototype.cast = function(value) {\n  let castDouble;\n  if (typeof this._castFunction === 'function') {\n    castDouble = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castDouble = this.constructor.cast();\n  } else {\n    castDouble = SchemaDouble.cast();\n  }\n\n  try {\n    return castDouble(value);\n  } catch (error) {\n    throw new CastError('Double', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$lt` is the function Mongoose calls to cast `$lt` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaDouble\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaDouble.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaDouble.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('number', 'double', options?.useBsonType, isRequired);\n};\n\nSchemaDouble.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'double';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaDouble;\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN;;;;;;;CAOC,GAED,SAAS,aAAa,IAAI,EAAE,OAAO;IACjC,WAAW,IAAI,CAAC,IAAI,EAAE,MAAM,SAAS;AACvC;AAEA;;;;;CAKC,GACD,aAAa,UAAU,GAAG;AAE1B,aAAa,cAAc,GAAG,CAAC;AAE/B;;CAEC,GACD,aAAa,SAAS,GAAG,OAAO,MAAM,CAAC,WAAW,SAAS;AAC3D,aAAa,SAAS,CAAC,WAAW,GAAG;AAErC;;CAEC,GAED,aAAa,KAAK,GAAG;AAErB;;;;;;;;;;;;;;CAcC,GAED,aAAa,GAAG,GAAG,WAAW,GAAG;AAEjC,aAAa,OAAO,GAAG,EAAE;AAEzB;;;;;;;;;;;;;CAaC,GAED,aAAa,GAAG,GAAG,WAAW,GAAG;AAEjC;;CAEC,GAED,aAAa,cAAc,GAAG,CAAA;IAC5B,IAAI,KAAK,MAAM;QACb,IAAI,EAAE,SAAS,KAAK,UAAU;YAC5B,MAAM,IAAI;QACZ;IACF;IAEA,OAAO;AACT;AAEA;;;;;;;;;;;;;;;;;;;;;;;CAuBC,GAED,aAAa,IAAI,GAAG,SAAS,KAAK,MAAM;IACtC,IAAI,UAAU,MAAM,KAAK,GAAG;QAC1B,OAAO,IAAI,CAAC,KAAK;IACnB;IACA,IAAI,WAAW,OAAO;QACpB,SAAS,IAAI,CAAC,cAAc;IAC9B;IAEA,IAAI,CAAC,KAAK,GAAG;IAEb,OAAO,IAAI,CAAC,KAAK;AACnB;AAGA;;CAEC,GAED,aAAa,cAAc,GAAG,CAAA,IAAK,KAAK;AACxC;;;;;;;;;CASC,GAED,aAAa,aAAa,GAAG,WAAW,aAAa;AAErD;;;;;;CAMC,GAED,aAAa,SAAS,CAAC,aAAa,GAAG,SAAS,KAAK;IACnD,OAAO,IAAI,CAAC,WAAW,CAAC,cAAc,CAAC;AACzC;AAEA;;;;;;CAMC,GAED,aAAa,SAAS,CAAC,IAAI,GAAG,SAAS,KAAK;IAC1C,IAAI;IACJ,IAAI,OAAO,IAAI,CAAC,aAAa,KAAK,YAAY;QAC5C,aAAa,IAAI,CAAC,aAAa;IACjC,OAAO,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,KAAK,YAAY;QACtD,aAAa,IAAI,CAAC,WAAW,CAAC,IAAI;IACpC,OAAO;QACL,aAAa,aAAa,IAAI;IAChC;IAEA,IAAI;QACF,OAAO,WAAW;IACpB,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,UAAU,UAAU,OAAO,IAAI,CAAC,IAAI,EAAE,OAAO,IAAI;IAC7D;AACF;AAEA;;CAEC,GAED,SAAS,aAAa,GAAG;IACvB,OAAO,IAAI,CAAC,IAAI,CAAC;AACnB;AAEA,MAAM,uBAAuB;IAC3B,GAAG,WAAW,SAAS,CAAC,oBAAoB;IAC5C,KAAK;IACL,MAAM;IACN,KAAK;IACL,MAAM;AACR;AAEA;;;;;;;;CAQC,GAED,OAAO,cAAc,CAAC,aAAa,SAAS,EAAE,wBAAwB;IACpE,YAAY;IACZ,OAAO;AACT;AAEA;;;;;;CAMC,GAED,aAAa,SAAS,CAAC,YAAY,GAAG,SAAS,aAAa,OAAO;IACjE,MAAM,aAAa,IAAI,CAAC,OAAO,CAAC,QAAQ,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK;IAC7E,OAAO,+BAA+B,UAAU,UAAU,SAAS,aAAa;AAClF;AAEA,aAAa,SAAS,CAAC,kBAAkB,GAAG,SAAS;IACnD,OAAO;AACT;AAEA;;CAEC,GAED,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 3863, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/int32.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('../error/cast');\nconst SchemaType = require('../schemaType');\nconst castInt32 = require('../cast/int32');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst handleBitwiseOperator = require('./operators/bitwise');\n\n/**\n * Int32 SchemaType constructor.\n *\n * @param {String} path\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaInt32(path, options) {\n  SchemaType.call(this, path, options, 'Int32');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaInt32.schemaName = 'Int32';\n\nSchemaInt32.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaInt32.prototype = Object.create(SchemaType.prototype);\nSchemaInt32.prototype.constructor = SchemaInt32;\n\n/*!\n * ignore\n */\n\nSchemaInt32._cast = castInt32;\n\n/**\n * Sets a default option for all Int32 instances.\n *\n * #### Example:\n *\n *     // Make all Int32 fields required by default\n *     mongoose.Schema.Int32.set('required', true);\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaInt32.set = SchemaType.set;\n\nSchemaInt32.setters = [];\n\n/**\n * Attaches a getter for all Int32 instances\n *\n * #### Example:\n *\n *     // Converts int32 to be a represent milliseconds upon access\n *     mongoose.Schema.Int32.get(v => v == null ? '0 ms' : v.toString() + ' ms');\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaInt32.get = SchemaType.get;\n\n/*!\n * ignore\n */\n\nSchemaInt32._defaultCaster = v => {\n  const INT32_MAX = 0x7FFFFFFF;\n  const INT32_MIN = -0x80000000;\n\n  if (v != null) {\n    if (typeof v !== 'number' || v !== (v | 0) || v < INT32_MIN || v > INT32_MAX) {\n      throw new Error();\n    }\n  }\n\n  return v;\n};\n\n/**\n * Get/set the function used to cast arbitrary values to 32-bit integers\n *\n * #### Example:\n *\n *     // Make Mongoose cast NaN to 0\n *     const defaultCast = mongoose.Schema.Types.Int32.cast();\n *     mongoose.Schema.Types.Int32.cast(v => {\n *       if (isNaN(v)) {\n *         return 0;\n *       }\n *       return defaultCast(v);\n *     });\n *\n *     // Or disable casting for Int32s entirely (only JS numbers within 32-bit integer bounds and null-ish values are permitted)\n *     mongoose.Schema.Int32.cast(false);\n *\n *\n * @param {Function} caster\n * @return {Function}\n * @function cast\n * @static\n * @api public\n */\n\nSchemaInt32.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n\n  this._cast = caster;\n\n  return this._cast;\n};\n\n\n/*!\n * ignore\n */\n\nSchemaInt32._checkRequired = v => v != null;\n/**\n * Override the function the required validator uses to check whether a value\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaInt32.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaInt32.prototype.checkRequired = function(value) {\n  return this.constructor._checkRequired(value);\n};\n\n/**\n * Casts to Int32\n *\n * @param {Object} value\n * @param {Object} model this value is optional\n * @api private\n */\n\nSchemaInt32.prototype.cast = function(value) {\n  let castInt32;\n  if (typeof this._castFunction === 'function') {\n    castInt32 = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castInt32 = this.constructor.cast();\n  } else {\n    castInt32 = SchemaInt32.cast();\n  }\n\n  try {\n    return castInt32(value);\n  } catch (error) {\n    throw new CastError('Int32', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$gt` is the function Mongoose calls to cast `$gt` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaInt32\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaInt32.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaInt32.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n\n    if (handler) {\n      return handler.call(this, val);\n    }\n\n    return this.applySetters(val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaInt32.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('number', 'int', options?.useBsonType, isRequired);\n};\n\nSchemaInt32.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'int';\n};\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaInt32;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4086, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/map.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst MongooseMap = require('../types/map');\nconst SchemaMapOptions = require('../options/schemaMapOptions');\nconst SchemaType = require('../schemaType');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\n\n/*!\n * ignore\n */\n\nclass SchemaMap extends SchemaType {\n  constructor(key, options) {\n    super(key, options, 'Map');\n    this.$isSchemaMap = true;\n  }\n\n  set(option, value) {\n    return SchemaType.set(option, value);\n  }\n\n  cast(val, doc, init, prev, options) {\n    if (val instanceof MongooseMap) {\n      return val;\n    }\n\n    const path = this.path;\n\n    if (init) {\n      const map = new MongooseMap({}, path, doc, this.$__schemaType, options);\n\n      // Use the map's path for passing to nested casts.\n      // If map's parent is a subdocument, use the relative path so nested casts get relative paths.\n      const mapPath = map.$__pathRelativeToParent != null ? map.$__pathRelativeToParent : map.$__path;\n\n      if (val instanceof global.Map) {\n        for (const key of val.keys()) {\n          let _val = val.get(key);\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { ...options, path: mapPath + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      } else {\n        for (const key of Object.keys(val)) {\n          let _val = val[key];\n          if (_val == null) {\n            _val = map.$__schemaType._castNullish(_val);\n          } else {\n            _val = map.$__schemaType.cast(_val, doc, true, null, { ...options, path: mapPath + '.' + key });\n          }\n          map.$init(key, _val);\n        }\n      }\n\n      return map;\n    }\n\n    return new MongooseMap(val, path, doc, this.$__schemaType, options);\n  }\n\n  clone() {\n    const schematype = super.clone();\n\n    if (this.$__schemaType != null) {\n      schematype.$__schemaType = this.$__schemaType.clone();\n    }\n    return schematype;\n  }\n\n  /**\n   * Returns the embedded schema type (i.e. the `.$*` path)\n   */\n  getEmbeddedSchemaType() {\n    return this.$__schemaType;\n  }\n\n  /**\n   * Returns this schema type's representation in a JSON schema.\n   *\n   * @param [options]\n   * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n   * @returns {Object} JSON schema properties\n   */\n\n  toJSONSchema(options) {\n    const useBsonType = options?.useBsonType;\n    const embeddedSchemaType = this.getEmbeddedSchemaType();\n\n    const isRequired = this.options.required && typeof this.options.required !== 'function';\n    const result = createJSONSchemaTypeDefinition('object', 'object', useBsonType, isRequired);\n    result.additionalProperties = embeddedSchemaType.toJSONSchema(options);\n\n    return result;\n  }\n\n  autoEncryptionType() {\n    return 'object';\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaMap.schemaName = 'Map';\n\nSchemaMap.prototype.OptionsConstructor = SchemaMapOptions;\n\nSchemaMap.defaultOptions = {};\n\nmodule.exports = SchemaMap;\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN;;CAEC,GAED,MAAM,kBAAkB;IACtB,YAAY,GAAG,EAAE,OAAO,CAAE;QACxB,KAAK,CAAC,KAAK,SAAS;QACpB,IAAI,CAAC,YAAY,GAAG;IACtB;IAEA,IAAI,MAAM,EAAE,KAAK,EAAE;QACjB,OAAO,WAAW,GAAG,CAAC,QAAQ;IAChC;IAEA,KAAK,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE;QAClC,IAAI,eAAe,aAAa;YAC9B,OAAO;QACT;QAEA,MAAM,OAAO,IAAI,CAAC,IAAI;QAEtB,IAAI,MAAM;YACR,MAAM,MAAM,IAAI,YAAY,CAAC,GAAG,MAAM,KAAK,IAAI,CAAC,aAAa,EAAE;YAE/D,kDAAkD;YAClD,8FAA8F;YAC9F,MAAM,UAAU,IAAI,uBAAuB,IAAI,OAAO,IAAI,uBAAuB,GAAG,IAAI,OAAO;YAE/F,IAAI,eAAe,yDAAO,GAAG,EAAE;gBAC7B,KAAK,MAAM,OAAO,IAAI,IAAI,GAAI;oBAC5B,IAAI,OAAO,IAAI,GAAG,CAAC;oBACnB,IAAI,QAAQ,MAAM;wBAChB,OAAO,IAAI,aAAa,CAAC,YAAY,CAAC;oBACxC,OAAO;wBACL,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC,MAAM,KAAK,MAAM,MAAM;4BAAE,GAAG,OAAO;4BAAE,MAAM,UAAU,MAAM;wBAAI;oBAC/F;oBACA,IAAI,KAAK,CAAC,KAAK;gBACjB;YACF,OAAO;gBACL,KAAK,MAAM,OAAO,OAAO,IAAI,CAAC,KAAM;oBAClC,IAAI,OAAO,GAAG,CAAC,IAAI;oBACnB,IAAI,QAAQ,MAAM;wBAChB,OAAO,IAAI,aAAa,CAAC,YAAY,CAAC;oBACxC,OAAO;wBACL,OAAO,IAAI,aAAa,CAAC,IAAI,CAAC,MAAM,KAAK,MAAM,MAAM;4BAAE,GAAG,OAAO;4BAAE,MAAM,UAAU,MAAM;wBAAI;oBAC/F;oBACA,IAAI,KAAK,CAAC,KAAK;gBACjB;YACF;YAEA,OAAO;QACT;QAEA,OAAO,IAAI,YAAY,KAAK,MAAM,KAAK,IAAI,CAAC,aAAa,EAAE;IAC7D;IAEA,QAAQ;QACN,MAAM,aAAa,KAAK,CAAC;QAEzB,IAAI,IAAI,CAAC,aAAa,IAAI,MAAM;YAC9B,WAAW,aAAa,GAAG,IAAI,CAAC,aAAa,CAAC,KAAK;QACrD;QACA,OAAO;IACT;IAEA;;GAEC,GACD,wBAAwB;QACtB,OAAO,IAAI,CAAC,aAAa;IAC3B;IAEA;;;;;;GAMC,GAED,aAAa,OAAO,EAAE;QACpB,MAAM,cAAc,SAAS;QAC7B,MAAM,qBAAqB,IAAI,CAAC,qBAAqB;QAErD,MAAM,aAAa,IAAI,CAAC,OAAO,CAAC,QAAQ,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK;QAC7E,MAAM,SAAS,+BAA+B,UAAU,UAAU,aAAa;QAC/E,OAAO,oBAAoB,GAAG,mBAAmB,YAAY,CAAC;QAE9D,OAAO;IACT;IAEA,qBAAqB;QACnB,OAAO;IACT;AACF;AAEA;;;;;CAKC,GACD,UAAU,UAAU,GAAG;AAEvB,UAAU,SAAS,CAAC,kBAAkB,GAAG;AAEzC,UAAU,cAAc,GAAG,CAAC;AAE5B,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4186, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/objectId.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst SchemaObjectIdOptions = require('../options/schemaObjectIdOptions');\nconst SchemaType = require('../schemaType');\nconst castObjectId = require('../cast/objectid');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst getConstructorName = require('../helpers/getConstructorName');\nconst oid = require('../types/objectid');\nconst isBsonType = require('../helpers/isBsonType');\nconst utils = require('../utils');\n\nconst CastError = SchemaType.CastError;\nlet Document;\n\n/**\n * ObjectId SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaObjectId(key, options) {\n  const isKeyHexStr = typeof key === 'string' && key.length === 24 && /^[a-f0-9]+$/i.test(key);\n  const suppressWarning = options && options.suppressWarning;\n  if ((isKeyHexStr || typeof key === 'undefined') && !suppressWarning) {\n    utils.warn('mongoose: To create a new ObjectId please try ' +\n      '`Mongoose.Types.ObjectId` instead of using ' +\n      '`Mongoose.Schema.ObjectId`. Set the `suppressWarning` option if ' +\n      'you\\'re trying to create a hex char path in your schema.');\n  }\n  SchemaType.call(this, key, options, 'ObjectId');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaObjectId.schemaName = 'ObjectId';\n\nSchemaObjectId.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaObjectId.prototype = Object.create(SchemaType.prototype);\nSchemaObjectId.prototype.constructor = SchemaObjectId;\nSchemaObjectId.prototype.OptionsConstructor = SchemaObjectIdOptions;\n\n/**\n * Attaches a getter for all ObjectId instances\n *\n * #### Example:\n *\n *     // Always convert to string when getting an ObjectId\n *     mongoose.ObjectId.get(v => v.toString());\n *\n *     const Model = mongoose.model('Test', new Schema({}));\n *     typeof (new Model({})._id); // 'string'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaObjectId.get = SchemaType.get;\n\n/**\n * Sets a default option for all ObjectId instances.\n *\n * #### Example:\n *\n *     // Make all object ids have option `required` equal to true.\n *     mongoose.Schema.ObjectId.set('required', true);\n *\n *     const Order = mongoose.model('Order', new Schema({ userId: ObjectId }));\n *     new Order({ }).validateSync().errors.userId.message; // Path `userId` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaObjectId.set = SchemaType.set;\n\nSchemaObjectId.setters = [];\n\n/**\n * Adds an auto-generated ObjectId default if turnOn is true.\n * @param {Boolean} turnOn auto generated ObjectId defaults\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaObjectId.prototype.auto = function(turnOn) {\n  if (turnOn) {\n    this.default(defaultId);\n    this.set(resetId);\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nSchemaObjectId._checkRequired = v => isBsonType(v, 'ObjectId');\n\n/*!\n * ignore\n */\n\nSchemaObjectId._cast = castObjectId;\n\n/**\n * Get/set the function used to cast arbitrary values to objectids.\n *\n * #### Example:\n *\n *     // Make Mongoose only try to cast length 24 strings. By default, any 12\n *     // char string is a valid ObjectId.\n *     const original = mongoose.ObjectId.cast();\n *     mongoose.ObjectId.cast(v => {\n *       assert.ok(typeof v !== 'string' || v.length === 24);\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.ObjectId.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function cast\n * @static\n * @api public\n */\n\nSchemaObjectId.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaObjectId._defaultCaster = v => {\n  if (!(isBsonType(v, 'ObjectId'))) {\n    throw new Error(v + ' is not an instance of ObjectId');\n  }\n  return v;\n};\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaObjectId.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaObjectId.prototype.checkRequired = function checkRequired(value, doc) {\n  if (SchemaType._isRef(this, value, doc, true)) {\n    return !!value;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaObjectId.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to ObjectId\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaObjectId.prototype.cast = function(value, doc, init, prev, options) {\n  if (!(isBsonType(value, 'ObjectId')) && SchemaType._isRef(this, value, doc, init)) {\n    // wait! we may need to cast this to a document\n    if ((getConstructorName(value) || '').toLowerCase() === 'objectid') {\n      return new oid(value.toHexString());\n    }\n\n    if (value == null || utils.isNonBuiltinObject(value)) {\n      return this._castRef(value, doc, init, options);\n    }\n  }\n\n  let castObjectId;\n  if (typeof this._castFunction === 'function') {\n    castObjectId = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castObjectId = this.constructor.cast();\n  } else {\n    castObjectId = SchemaObjectId.cast();\n  }\n\n  try {\n    return castObjectId(value);\n  } catch (error) {\n    throw new CastError('ObjectId', value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$in` is the function Mongoose calls to cast `$in` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaObjectId\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaObjectId.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/*!\n * ignore\n */\n\nfunction defaultId() {\n  return new oid();\n}\n\ndefaultId.$runBeforeSetters = true;\n\nfunction resetId(v) {\n  Document || (Document = require('../document'));\n\n  if (this instanceof Document) {\n    if (v === void 0) {\n      const _v = new oid();\n      return _v;\n    }\n  }\n\n  return v;\n}\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n * @api public\n */\n\nSchemaObjectId.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = (this.options.required && typeof this.options.required !== 'function') || this.path === '_id';\n  return createJSONSchemaTypeDefinition('string', 'objectId', options?.useBsonType, isRequired);\n};\n\nSchemaObjectId.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'objectId';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaObjectId;\n"],"names":[],"mappings":"AAAA;;CAEC,GAID,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AAEN,MAAM,YAAY,WAAW,SAAS;AACtC,IAAI;AAEJ;;;;;;;CAOC,GAED,SAAS,eAAe,GAAG,EAAE,OAAO;IAClC,MAAM,cAAc,OAAO,QAAQ,YAAY,IAAI,MAAM,KAAK,MAAM,eAAe,IAAI,CAAC;IACxF,MAAM,kBAAkB,WAAW,QAAQ,eAAe;IAC1D,IAAI,CAAC,eAAe,OAAO,QAAQ,WAAW,KAAK,CAAC,iBAAiB;QACnE,MAAM,IAAI,CAAC,mDACT,gDACA,qEACA;IACJ;IACA,WAAW,IAAI,CAAC,IAAI,EAAE,KAAK,SAAS;AACtC;AAEA;;;;;CAKC,GACD,eAAe,UAAU,GAAG;AAE5B,eAAe,cAAc,GAAG,CAAC;AAEjC;;CAEC,GACD,eAAe,SAAS,GAAG,OAAO,MAAM,CAAC,WAAW,SAAS;AAC7D,eAAe,SAAS,CAAC,WAAW,GAAG;AACvC,eAAe,SAAS,CAAC,kBAAkB,GAAG;AAE9C;;;;;;;;;;;;;;;;CAgBC,GAED,eAAe,GAAG,GAAG,WAAW,GAAG;AAEnC;;;;;;;;;;;;;;;;;CAiBC,GAED,eAAe,GAAG,GAAG,WAAW,GAAG;AAEnC,eAAe,OAAO,GAAG,EAAE;AAE3B;;;;;CAKC,GAED,eAAe,SAAS,CAAC,IAAI,GAAG,SAAS,MAAM;IAC7C,IAAI,QAAQ;QACV,IAAI,CAAC,OAAO,CAAC;QACb,IAAI,CAAC,GAAG,CAAC;IACX;IAEA,OAAO,IAAI;AACb;AAEA;;CAEC,GAED,eAAe,cAAc,GAAG,CAAA,IAAK,WAAW,GAAG;AAEnD;;CAEC,GAED,eAAe,KAAK,GAAG;AAEvB;;;;;;;;;;;;;;;;;;;;;CAqBC,GAED,eAAe,IAAI,GAAG,SAAS,KAAK,MAAM;IACxC,IAAI,UAAU,MAAM,KAAK,GAAG;QAC1B,OAAO,IAAI,CAAC,KAAK;IACnB;IACA,IAAI,WAAW,OAAO;QACpB,SAAS,IAAI,CAAC,cAAc;IAC9B;IACA,IAAI,CAAC,KAAK,GAAG;IAEb,OAAO,IAAI,CAAC,KAAK;AACnB;AAEA;;CAEC,GAED,eAAe,cAAc,GAAG,CAAA;IAC9B,IAAI,CAAE,WAAW,GAAG,aAAc;QAChC,MAAM,IAAI,MAAM,IAAI;IACtB;IACA,OAAO;AACT;AAEA;;;;;;;;;;;;;;;;;CAiBC,GAED,eAAe,aAAa,GAAG,WAAW,aAAa;AAEvD;;;;;;;CAOC,GAED,eAAe,SAAS,CAAC,aAAa,GAAG,SAAS,cAAc,KAAK,EAAE,GAAG;IACxE,IAAI,WAAW,MAAM,CAAC,IAAI,EAAE,OAAO,KAAK,OAAO;QAC7C,OAAO,CAAC,CAAC;IACX;IAEA,wEAAwE;IACxE,4DAA4D;IAC5D,MAAM,iBAAiB,OAAO,IAAI,CAAC,WAAW,CAAC,aAAa,KAAK,aAC/D,IAAI,CAAC,WAAW,CAAC,aAAa,KAC9B,eAAe,aAAa;IAE9B,OAAO,eAAe;AACxB;AAEA;;;;;;;CAOC,GAED,eAAe,SAAS,CAAC,IAAI,GAAG,SAAS,KAAK,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO;IACtE,IAAI,CAAE,WAAW,OAAO,eAAgB,WAAW,MAAM,CAAC,IAAI,EAAE,OAAO,KAAK,OAAO;QACjF,+CAA+C;QAC/C,IAAI,CAAC,mBAAmB,UAAU,EAAE,EAAE,WAAW,OAAO,YAAY;YAClE,OAAO,IAAI,IAAI,MAAM,WAAW;QAClC;QAEA,IAAI,SAAS,QAAQ,MAAM,kBAAkB,CAAC,QAAQ;YACpD,OAAO,IAAI,CAAC,QAAQ,CAAC,OAAO,KAAK,MAAM;QACzC;IACF;IAEA,IAAI;IACJ,IAAI,OAAO,IAAI,CAAC,aAAa,KAAK,YAAY;QAC5C,eAAe,IAAI,CAAC,aAAa;IACnC,OAAO,IAAI,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,KAAK,YAAY;QACtD,eAAe,IAAI,CAAC,WAAW,CAAC,IAAI;IACtC,OAAO;QACL,eAAe,eAAe,IAAI;IACpC;IAEA,IAAI;QACF,OAAO,aAAa;IACtB,EAAE,OAAO,OAAO;QACd,MAAM,IAAI,UAAU,YAAY,OAAO,IAAI,CAAC,IAAI,EAAE,OAAO,IAAI;IAC/D;AACF;AAEA;;CAEC,GAED,SAAS,aAAa,GAAG;IACvB,OAAO,IAAI,CAAC,IAAI,CAAC;AACnB;AAEA,MAAM,uBAAuB;IAC3B,GAAG,WAAW,SAAS,CAAC,oBAAoB;IAC5C,KAAK;IACL,MAAM;IACN,KAAK;IACL,MAAM;AACR;AAEA;;;;;;;;CAQC,GAED,OAAO,cAAc,CAAC,eAAe,SAAS,EAAE,wBAAwB;IACtE,YAAY;IACZ,OAAO;AACT;AAEA;;CAEC,GAED,SAAS;IACP,OAAO,IAAI;AACb;AAEA,UAAU,iBAAiB,GAAG;AAE9B,SAAS,QAAQ,CAAC;IAChB,YAAY,CAAC,gHAAiC;IAE9C,IAAI,IAAI,YAAY,UAAU;QAC5B,IAAI,MAAM,KAAK,GAAG;YAChB,MAAM,KAAK,IAAI;YACf,OAAO;QACT;IACF;IAEA,OAAO;AACT;AAEA;;;;;;;CAOC,GAED,eAAe,SAAS,CAAC,YAAY,GAAG,SAAS,aAAa,OAAO;IACnE,MAAM,aAAa,AAAC,IAAI,CAAC,OAAO,CAAC,QAAQ,IAAI,OAAO,IAAI,CAAC,OAAO,CAAC,QAAQ,KAAK,cAAe,IAAI,CAAC,IAAI,KAAK;IAC3G,OAAO,+BAA+B,UAAU,YAAY,SAAS,aAAa;AACpF;AAEA,eAAe,SAAS,CAAC,kBAAkB,GAAG,SAAS;IACrD,OAAO;AACT;AAEA;;CAEC,GAED,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4444, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/string.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst SchemaType = require('../schemaType');\nconst MongooseError = require('../error/index');\nconst SchemaStringOptions = require('../options/schemaStringOptions');\nconst castString = require('../cast/string');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst utils = require('../utils');\nconst isBsonType = require('../helpers/isBsonType');\n\nconst CastError = SchemaType.CastError;\n\n/**\n * String SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaString(key, options) {\n  this.enumValues = [];\n  this.regExp = null;\n  SchemaType.call(this, key, options, 'String');\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaString.schemaName = 'String';\n\nSchemaString.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaString.prototype = Object.create(SchemaType.prototype);\nSchemaString.prototype.constructor = SchemaString;\nObject.defineProperty(SchemaString.prototype, 'OptionsConstructor', {\n  configurable: false,\n  enumerable: false,\n  writable: false,\n  value: SchemaStringOptions\n});\n\n/*!\n * ignore\n */\n\nSchemaString._cast = castString;\n\n/**\n * Get/set the function used to cast arbitrary values to strings.\n *\n * #### Example:\n *\n *     // Throw an error if you pass in an object. Normally, Mongoose allows\n *     // objects with custom `toString()` functions.\n *     const original = mongoose.Schema.Types.String.cast();\n *     mongoose.Schema.Types.String.cast(v => {\n *       assert.ok(v == null || typeof v !== 'object');\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.Schema.Types.String.cast(false);\n *\n * @param {Function} caster\n * @return {Function}\n * @function cast\n * @static\n * @api public\n */\n\nSchemaString.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaString._defaultCaster = v => {\n  if (v != null && typeof v !== 'string') {\n    throw new Error();\n  }\n  return v;\n};\n\n/**\n * Attaches a getter for all String instances.\n *\n * #### Example:\n *\n *     // Make all numbers round down\n *     mongoose.Schema.String.get(v => v.toLowerCase());\n *\n *     const Model = mongoose.model('Test', new Schema({ test: String }));\n *     new Model({ test: 'FOO' }).test; // 'foo'\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaString.get = SchemaType.get;\n\n/**\n * Sets a default option for all String instances.\n *\n * #### Example:\n *\n *     // Make all strings have option `trim` equal to true.\n *     mongoose.Schema.String.set('trim', true);\n *\n *     const User = mongoose.model('User', new Schema({ name: String }));\n *     new User({ name: '   John Doe   ' }).name; // 'John Doe'\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaString.set = SchemaType.set;\n\nSchemaString.setters = [];\n\n/*!\n * ignore\n */\n\nSchemaString._checkRequired = v => (v instanceof String || typeof v === 'string') && v.length;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * #### Example:\n *\n *     // Allow empty strings to pass `required` check\n *     mongoose.Schema.Types.String.checkRequired(v => v != null);\n *\n *     const M = mongoose.model({ str: { type: String, required: true } });\n *     new M({ str: '' }).validateSync(); // `null`, validation passes!\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaString.checkRequired = SchemaType.checkRequired;\n\n/**\n * Adds an enum validator\n *\n * #### Example:\n *\n *     const states = ['opening', 'open', 'closing', 'closed']\n *     const s = new Schema({ state: { type: String, enum: states }})\n *     const M = db.model('M', s)\n *     const m = new M({ state: 'invalid' })\n *     await m.save()\n *       .catch((err) => console.error(err)); // ValidationError: `invalid` is not a valid enum value for path `state`.\n *     m.state = 'open';\n *     await m.save();\n *     // success\n *\n *     // or with custom error messages\n *     const enum = {\n *       values: ['opening', 'open', 'closing', 'closed'],\n *       message: 'enum validator failed for path `{PATH}` with value `{VALUE}`'\n *     }\n *     const s = new Schema({ state: { type: String, enum: enum })\n *     const M = db.model('M', s)\n *     const m = new M({ state: 'invalid' })\n *     await m.save()\n *       .catch((err) => console.error(err)); // ValidationError: enum validator failed for path `state` with value `invalid`\n *     m.state = 'open';\n *     await m.save();\n *     // success\n *\n * @param {...String|Object} [args] enumeration values\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @see Enums in JavaScript https://masteringjs.io/tutorials/fundamentals/enum\n * @api public\n */\n\nSchemaString.prototype.enum = function() {\n  if (this.enumValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.enumValidator;\n    }, this);\n    this.enumValidator = false;\n  }\n\n  if (arguments[0] === void 0 || arguments[0] === false) {\n    return this;\n  }\n\n  let values;\n  let errorMessage;\n\n  if (utils.isObject(arguments[0])) {\n    if (Array.isArray(arguments[0].values)) {\n      values = arguments[0].values;\n      errorMessage = arguments[0].message;\n    } else {\n      values = utils.object.vals(arguments[0]);\n      errorMessage = MongooseError.messages.String.enum;\n    }\n  } else {\n    values = arguments;\n    errorMessage = MongooseError.messages.String.enum;\n  }\n\n  for (const value of values) {\n    if (value !== undefined) {\n      this.enumValues.push(this.cast(value));\n    }\n  }\n\n  const vals = this.enumValues;\n  this.enumValidator = function(v) {\n    return null == v || ~vals.indexOf(v);\n  };\n  this.validators.push({\n    validator: this.enumValidator,\n    message: errorMessage,\n    type: 'enum',\n    enumValues: vals\n  });\n\n  return this;\n};\n\n/**\n * Adds a lowercase [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * #### Example:\n *\n *     const s = new Schema({ email: { type: String, lowercase: true }})\n *     const M = db.model('M', s);\n *     const m = new M({ email: 'SomeEmail@example.COM' });\n *     console.log(m.email) // someemail@example.com\n *     M.find({ email: 'SomeEmail@example.com' }); // Queries by 'someemail@example.com'\n *\n * Note that `lowercase` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Still queries for documents whose `email` matches the regular\n *     // expression /SomeEmail/. Mongoose does **not** convert the RegExp\n *     // to lowercase.\n *     M.find({ email: /SomeEmail/ });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.lowercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.toLowerCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds an uppercase [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * #### Example:\n *\n *     const s = new Schema({ caps: { type: String, uppercase: true }})\n *     const M = db.model('M', s);\n *     const m = new M({ caps: 'an example' });\n *     console.log(m.caps) // AN EXAMPLE\n *     M.find({ caps: 'an example' }) // Matches documents where caps = 'AN EXAMPLE'\n *\n * Note that `uppercase` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Mongoose does **not** convert the RegExp to uppercase.\n *     M.find({ email: /an example/ });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.uppercase = function(shouldApply) {\n  if (arguments.length > 0 && !shouldApply) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.toUpperCase();\n    }\n    return v;\n  });\n};\n\n/**\n * Adds a trim [setter](https://mongoosejs.com/docs/api/schematype.html#SchemaType.prototype.set()).\n *\n * The string value will be [trimmed](https://masteringjs.io/tutorials/fundamentals/trim-string) when set.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, trim: true }});\n *     const M = db.model('M', s);\n *     const string = ' some name ';\n *     console.log(string.length); // 11\n *     const m = new M({ name: string });\n *     console.log(m.name.length); // 9\n *\n *     // Equivalent to `findOne({ name: string.trim() })`\n *     M.findOne({ name: string });\n *\n * Note that `trim` does **not** affect regular expression queries:\n *\n * #### Example:\n *\n *     // Mongoose does **not** trim whitespace from the RegExp.\n *     M.find({ name: / some name / });\n *\n * @api public\n * @return {SchemaType} this\n */\n\nSchemaString.prototype.trim = function(shouldTrim) {\n  if (arguments.length > 0 && !shouldTrim) {\n    return this;\n  }\n  return this.set(v => {\n    if (typeof v !== 'string') {\n      v = this.cast(v);\n    }\n    if (v) {\n      return v.trim();\n    }\n    return v;\n  });\n};\n\n/**\n * Sets a minimum length validator.\n *\n * #### Example:\n *\n *     const schema = new Schema({ postalCode: { type: String, minLength: 5 })\n *     const Address = db.model('Address', schema)\n *     const address = new Address({ postalCode: '9512' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MINLENGTH} token which will be replaced with the minimum allowed length\n *     const minLength = [5, 'The value of path `{PATH}` (`{VALUE}`) is shorter than the minimum allowed length ({MINLENGTH}).'];\n *     const schema = new Schema({ postalCode: { type: String, minLength: minLength })\n *     const Address = mongoose.model('Address', schema);\n *     const address = new Address({ postalCode: '9512' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512`) is shorter than the minimum length (5).\n *     })\n *\n * @param {Number} value minimum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.minlength = function(value, message) {\n  if (this.minlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.minlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.minlength;\n    msg = msg.replace(/{MINLENGTH}/, value);\n    this.validators.push({\n      validator: this.minlengthValidator = function(v) {\n        return v === null || v.length >= value;\n      },\n      message: msg,\n      type: 'minlength',\n      minlength: value\n    });\n  }\n\n  return this;\n};\n\nSchemaString.prototype.minLength = SchemaString.prototype.minlength;\n\n/**\n * Sets a maximum length validator.\n *\n * #### Example:\n *\n *     const schema = new Schema({ postalCode: { type: String, maxlength: 9 })\n *     const Address = db.model('Address', schema)\n *     const address = new Address({ postalCode: '9512512345' })\n *     address.save(function (err) {\n *       console.error(err) // validator error\n *       address.postalCode = '95125';\n *       address.save() // success\n *     })\n *\n *     // custom error messages\n *     // We can also use the special {MAXLENGTH} token which will be replaced with the maximum allowed length\n *     const maxlength = [9, 'The value of path `{PATH}` (`{VALUE}`) exceeds the maximum allowed length ({MAXLENGTH}).'];\n *     const schema = new Schema({ postalCode: { type: String, maxlength: maxlength })\n *     const Address = mongoose.model('Address', schema);\n *     const address = new Address({ postalCode: '9512512345' });\n *     address.validate(function (err) {\n *       console.log(String(err)) // ValidationError: The value of path `postalCode` (`9512512345`) exceeds the maximum allowed length (9).\n *     })\n *\n * @param {Number} value maximum string length\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.maxlength = function(value, message) {\n  if (this.maxlengthValidator) {\n    this.validators = this.validators.filter(function(v) {\n      return v.validator !== this.maxlengthValidator;\n    }, this);\n  }\n\n  if (value !== null && value !== undefined) {\n    let msg = message || MongooseError.messages.String.maxlength;\n    msg = msg.replace(/{MAXLENGTH}/, value);\n    this.validators.push({\n      validator: this.maxlengthValidator = function(v) {\n        return v === null || v.length <= value;\n      },\n      message: msg,\n      type: 'maxlength',\n      maxlength: value\n    });\n  }\n\n  return this;\n};\n\nSchemaString.prototype.maxLength = SchemaString.prototype.maxlength;\n\n/**\n * Sets a regexp validator.\n *\n * Any value that does not pass `regExp`.test(val) will fail validation.\n *\n * #### Example:\n *\n *     const s = new Schema({ name: { type: String, match: /^a/ }})\n *     const M = db.model('M', s)\n *     const m = new M({ name: 'I am invalid' })\n *     m.validate(function (err) {\n *       console.error(String(err)) // \"ValidationError: Path `name` is invalid (I am invalid).\"\n *       m.name = 'apples'\n *       m.validate(function (err) {\n *         assert.ok(err) // success\n *       })\n *     })\n *\n *     // using a custom error message\n *     const match = [ /\\.html$/, \"That file doesn't end in .html ({VALUE})\" ];\n *     const s = new Schema({ file: { type: String, match: match }})\n *     const M = db.model('M', s);\n *     const m = new M({ file: 'invalid' });\n *     m.validate(function (err) {\n *       console.log(String(err)) // \"ValidationError: That file doesn't end in .html (invalid)\"\n *     })\n *\n * Empty strings, `undefined`, and `null` values always pass the match validator. If you require these values, enable the `required` validator also.\n *\n *     const s = new Schema({ name: { type: String, match: /^a/, required: true }})\n *\n * @param {RegExp} regExp regular expression to test against\n * @param {String} [message] optional custom error message\n * @return {SchemaType} this\n * @see Customized Error Messages https://mongoosejs.com/docs/api/error.html#Error.messages\n * @api public\n */\n\nSchemaString.prototype.match = function match(regExp, message) {\n  // yes, we allow multiple match validators\n\n  const msg = message || MongooseError.messages.String.match;\n\n  const matchValidator = function(v) {\n    if (!regExp) {\n      return false;\n    }\n\n    // In case RegExp happens to have `/g` flag set, we need to reset the\n    // `lastIndex`, otherwise `match` will intermittently fail.\n    regExp.lastIndex = 0;\n\n    const ret = ((v != null && v !== '')\n      ? regExp.test(v)\n      : true);\n    return ret;\n  };\n\n  this.validators.push({\n    validator: matchValidator,\n    message: msg,\n    type: 'regexp',\n    regexp: regExp\n  });\n  return this;\n};\n\n/**\n * Check if the given value satisfies the `required` validator. The value is\n * considered valid if it is a string (that is, not `null` or `undefined`) and\n * has positive length. The `required` validator **will** fail for empty\n * strings.\n *\n * @param {Any} value\n * @param {Document} doc\n * @return {Boolean}\n * @api public\n */\n\nSchemaString.prototype.checkRequired = function checkRequired(value, doc) {\n  if (typeof value === 'object' && SchemaType._isRef(this, value, doc, true)) {\n    return value != null;\n  }\n\n  // `require('util').inherits()` does **not** copy static properties, and\n  // plugins like mongoose-float use `inherits()` for pre-ES6.\n  const _checkRequired = typeof this.constructor.checkRequired === 'function' ?\n    this.constructor.checkRequired() :\n    SchemaString.checkRequired();\n\n  return _checkRequired(value);\n};\n\n/**\n * Casts to String\n *\n * @api private\n */\n\nSchemaString.prototype.cast = function(value, doc, init, prev, options) {\n  if (typeof value !== 'string' && SchemaType._isRef(this, value, doc, init)) {\n    return this._castRef(value, doc, init, options);\n  }\n\n  let castString;\n  if (typeof this._castFunction === 'function') {\n    castString = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castString = this.constructor.cast();\n  } else {\n    castString = SchemaString.cast();\n  }\n\n  try {\n    return castString(value);\n  } catch (error) {\n    throw new CastError('string', value, this.path, null, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val, context) {\n  return this.castForQuery(null, val, context);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val, context) {\n  const _this = this;\n  if (!Array.isArray(val)) {\n    return [this.castForQuery(null, val, context)];\n  }\n  return val.map(function(m) {\n    return _this.castForQuery(null, m, context);\n  });\n}\n\n/*!\n * ignore\n */\n\nfunction handleSingleNoSetters(val) {\n  if (val == null) {\n    return this._castNullish(val);\n  }\n\n  return this.cast(val, this);\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $all: handleArray,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $options: handleSingleNoSetters,\n  $regex: function handle$regex(val) {\n    if (Object.prototype.toString.call(val) === '[object RegExp]') {\n      return val;\n    }\n\n    return handleSingleNoSetters.call(this, val);\n  },\n  $not: handleSingle\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$exists` is the function Mongoose calls to cast `$exists` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaString\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaString.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} [val]\n * @api private\n */\n\nSchemaString.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler) {\n      throw new Error('Can\\'t use ' + $conditional + ' with String.');\n    }\n    return handler.call(this, val, context);\n  }\n\n  if (Object.prototype.toString.call(val) === '[object RegExp]' || isBsonType(val, 'BSONRegExp')) {\n    return val;\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaString.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('string', 'string', options?.useBsonType, isRequired);\n};\n\nSchemaString.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'string';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaString;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5066, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/uuid.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseBuffer = require('../types/buffer');\nconst SchemaType = require('../schemaType');\nconst CastError = SchemaType.CastError;\nconst castUUID = require('../cast/uuid');\nconst createJSONSchemaTypeDefinition = require('../helpers/createJSONSchemaTypeDefinition');\nconst utils = require('../utils');\nconst handleBitwiseOperator = require('./operators/bitwise');\n\nconst UUID_FORMAT = castUUID.UUID_FORMAT;\nconst Binary = MongooseBuffer.Binary;\n\n/**\n * Convert binary to a uuid string\n * @param {Buffer|Binary|String} uuidBin The value to process\n * @returns {String} The completed uuid-string\n * @api private\n */\nfunction binaryToString(uuidBin) {\n  // i(hasezoey) dont quite know why, but \"uuidBin\" may sometimes also be the already processed string\n  let hex;\n  if (typeof uuidBin !== 'string' && uuidBin != null) {\n    hex = uuidBin.toString('hex');\n    const uuidStr = hex.substring(0, 8) + '-' + hex.substring(8, 8 + 4) + '-' + hex.substring(12, 12 + 4) + '-' + hex.substring(16, 16 + 4) + '-' + hex.substring(20, 20 + 12);\n    return uuidStr;\n  }\n  return uuidBin;\n}\n\n/**\n * UUIDv1 SchemaType constructor.\n *\n * @param {String} key\n * @param {Object} options\n * @inherits SchemaType\n * @api public\n */\n\nfunction SchemaUUID(key, options) {\n  SchemaType.call(this, key, options, 'UUID');\n  this.getters.push(function(value) {\n    // For populated\n    if (value != null && value.$__ != null) {\n      return value;\n    }\n    if (Buffer.isBuffer(value)) {\n      return binaryToString(value);\n    } else if (value instanceof Binary) {\n      return binaryToString(value.buffer);\n    } else if (utils.isPOJO(value) && value.type === 'Buffer' && Array.isArray(value.data)) {\n      // Cloned buffers look like `{ type: 'Buffer', data: [5, 224, ...] }`\n      return binaryToString(Buffer.from(value.data));\n    }\n    return value;\n  });\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nSchemaUUID.schemaName = 'UUID';\n\nSchemaUUID.defaultOptions = {};\n\n/*!\n * Inherits from SchemaType.\n */\nSchemaUUID.prototype = Object.create(SchemaType.prototype);\nSchemaUUID.prototype.constructor = SchemaUUID;\n\n/*!\n * ignore\n */\n\nSchemaUUID._cast = castUUID;\n\n/**\n * Attaches a getter for all UUID instances.\n *\n * #### Example:\n *\n *     // Note that `v` is a string by default\n *     mongoose.Schema.UUID.get(v => v.toUpperCase());\n *\n *     const Model = mongoose.model('Test', new Schema({ test: 'UUID' }));\n *     new Model({ test: uuid.v4() }).test; // UUID with all uppercase\n *\n * @param {Function} getter\n * @return {this}\n * @function get\n * @static\n * @api public\n */\n\nSchemaUUID.get = SchemaType.get;\n\n/**\n * Sets a default option for all UUID instances.\n *\n * #### Example:\n *\n *     // Make all UUIDs have `required` of true by default.\n *     mongoose.Schema.UUID.set('required', true);\n *\n *     const User = mongoose.model('User', new Schema({ test: mongoose.UUID }));\n *     new User({ }).validateSync().errors.test.message; // Path `test` is required.\n *\n * @param {String} option The option you'd like to set the value for\n * @param {Any} value value for option\n * @return {undefined}\n * @function set\n * @static\n * @api public\n */\n\nSchemaUUID.set = SchemaType.set;\n\nSchemaUUID.setters = [];\n\n/**\n * Get/set the function used to cast arbitrary values to UUIDs.\n *\n * #### Example:\n *\n *     // Make Mongoose refuse to cast UUIDs with 0 length\n *     const original = mongoose.Schema.Types.UUID.cast();\n *     mongoose.UUID.cast(v => {\n *       assert.ok(typeof v === \"string\" && v.length > 0);\n *       return original(v);\n *     });\n *\n *     // Or disable casting entirely\n *     mongoose.UUID.cast(false);\n *\n * @param {Function} [caster]\n * @return {Function}\n * @function get\n * @static\n * @api public\n */\n\nSchemaUUID.cast = function cast(caster) {\n  if (arguments.length === 0) {\n    return this._cast;\n  }\n  if (caster === false) {\n    caster = this._defaultCaster;\n  }\n  this._cast = caster;\n\n  return this._cast;\n};\n\n/*!\n * ignore\n */\n\nSchemaUUID._checkRequired = v => v != null;\n\n/**\n * Override the function the required validator uses to check whether a string\n * passes the `required` check.\n *\n * @param {Function} fn\n * @return {Function}\n * @function checkRequired\n * @static\n * @api public\n */\n\nSchemaUUID.checkRequired = SchemaType.checkRequired;\n\n/**\n * Check if the given value satisfies a required validator.\n *\n * @param {Any} value\n * @return {Boolean}\n * @api public\n */\n\nSchemaUUID.prototype.checkRequired = function checkRequired(value) {\n  if (Buffer.isBuffer(value)) {\n    value = binaryToString(value);\n  }\n  return value != null && UUID_FORMAT.test(value);\n};\n\n/**\n * Casts to UUID\n *\n * @param {Object} value\n * @param {Object} doc\n * @param {Boolean} init whether this is an initialization cast\n * @api private\n */\n\nSchemaUUID.prototype.cast = function(value, doc, init, prev, options) {\n  if (utils.isNonBuiltinObject(value) &&\n      SchemaType._isRef(this, value, doc, init)) {\n    return this._castRef(value, doc, init, options);\n  }\n\n  let castFn;\n  if (typeof this._castFunction === 'function') {\n    castFn = this._castFunction;\n  } else if (typeof this.constructor.cast === 'function') {\n    castFn = this.constructor.cast();\n  } else {\n    castFn = SchemaUUID.cast();\n  }\n\n  try {\n    return castFn(value);\n  } catch (error) {\n    throw new CastError(SchemaUUID.schemaName, value, this.path, error, this);\n  }\n};\n\n/*!\n * ignore\n */\n\nfunction handleSingle(val) {\n  return this.cast(val);\n}\n\n/*!\n * ignore\n */\n\nfunction handleArray(val) {\n  return val.map((m) => {\n    return this.cast(m);\n  });\n}\n\nconst $conditionalHandlers = {\n  ...SchemaType.prototype.$conditionalHandlers,\n  $bitsAllClear: handleBitwiseOperator,\n  $bitsAnyClear: handleBitwiseOperator,\n  $bitsAllSet: handleBitwiseOperator,\n  $bitsAnySet: handleBitwiseOperator,\n  $all: handleArray,\n  $gt: handleSingle,\n  $gte: handleSingle,\n  $in: handleArray,\n  $lt: handleSingle,\n  $lte: handleSingle,\n  $ne: handleSingle,\n  $nin: handleArray\n};\n\n/**\n * Contains the handlers for different query operators for this schema type.\n * For example, `$conditionalHandlers.$exists` is the function Mongoose calls to cast `$exists` filter operators.\n *\n * @property $conditionalHandlers\n * @memberOf SchemaUUID\n * @instance\n * @api public\n */\n\nObject.defineProperty(SchemaUUID.prototype, '$conditionalHandlers', {\n  enumerable: false,\n  value: $conditionalHandlers\n});\n\n/**\n * Casts contents for queries.\n *\n * @param {String} $conditional\n * @param {any} val\n * @api private\n */\n\nSchemaUUID.prototype.castForQuery = function($conditional, val, context) {\n  let handler;\n  if ($conditional != null) {\n    handler = this.$conditionalHandlers[$conditional];\n    if (!handler)\n      throw new Error('Can\\'t use ' + $conditional + ' with UUID.');\n    return handler.call(this, val, context);\n  }\n\n  try {\n    return this.applySetters(val, context);\n  } catch (err) {\n    if (err instanceof CastError && err.path === this.path && this.$fullPath != null) {\n      err.path = this.$fullPath;\n    }\n    throw err;\n  }\n};\n\n/**\n * Returns this schema type's representation in a JSON schema.\n *\n * @param [options]\n * @param [options.useBsonType=false] If true, return a representation with `bsonType` for use with MongoDB's `$jsonSchema`.\n * @returns {Object} JSON schema properties\n */\n\nSchemaUUID.prototype.toJSONSchema = function toJSONSchema(options) {\n  const isRequired = this.options.required && typeof this.options.required !== 'function';\n  return createJSONSchemaTypeDefinition('string', 'binData', options?.useBsonType, isRequired);\n};\n\nSchemaUUID.prototype.autoEncryptionType = function autoEncryptionType() {\n  return 'binData';\n};\n\n/*!\n * Module exports.\n */\n\nmodule.exports = SchemaUUID;\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5328, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/union.js"],"sourcesContent":["'use strict';\n\n/*!\n * ignore\n */\n\nconst SchemaUnionOptions = require('../options/schemaUnionOptions');\nconst SchemaType = require('../schemaType');\n\nconst firstValueSymbol = Symbol('firstValue');\n\n/*!\n * ignore\n */\n\nclass Union extends SchemaType {\n  constructor(key, options, schemaOptions = {}) {\n    super(key, options, 'Union');\n    if (!options || !Array.isArray(options.of) || options.of.length === 0) {\n      throw new Error('Union schema type requires an array of types');\n    }\n    this.schemaTypes = options.of.map(obj => options.parentSchema.interpretAsType(key, obj, schemaOptions));\n  }\n\n  cast(val, doc, init, prev, options) {\n    let firstValue = firstValueSymbol;\n    let lastError;\n    // Loop through each schema type in the union. If one of the schematypes returns a value that is `=== val`, then\n    // use `val`. Otherwise, if one of the schematypes casted successfully, use the first successfully casted value.\n    // Finally, if none of the schematypes casted successfully, throw the error from the last schema type in the union.\n    // The `=== val` check is a workaround to ensure that the original value is returned if it matches one of the schema types,\n    // avoiding cases like where numbers are casted to strings or dates even if the schema type is a number.\n    for (let i = 0; i < this.schemaTypes.length; ++i) {\n      try {\n        const casted = this.schemaTypes[i].cast(val, doc, init, prev, options);\n        if (casted === val) {\n          return casted;\n        }\n        if (firstValue === firstValueSymbol) {\n          firstValue = casted;\n        }\n      } catch (error) {\n        lastError = error;\n      }\n    }\n    if (firstValue !== firstValueSymbol) {\n      return firstValue;\n    }\n    throw lastError;\n  }\n\n  // Setters also need to be aware of casting - we need to apply the setters of the entry in the union we choose.\n  applySetters(val, doc, init, prev, options) {\n    let firstValue = firstValueSymbol;\n    let lastError;\n    // Loop through each schema type in the union. If one of the schematypes returns a value that is `=== val`, then\n    // use `val`. Otherwise, if one of the schematypes casted successfully, use the first successfully casted value.\n    // Finally, if none of the schematypes casted successfully, throw the error from the last schema type in the union.\n    // The `=== val` check is a workaround to ensure that the original value is returned if it matches one of the schema types,\n    // avoiding cases like where numbers are casted to strings or dates even if the schema type is a number.\n    for (let i = 0; i < this.schemaTypes.length; ++i) {\n      try {\n        let castedVal = this.schemaTypes[i]._applySetters(val, doc, init, prev, options);\n        if (castedVal == null) {\n          castedVal = this.schemaTypes[i]._castNullish(castedVal);\n        } else {\n          castedVal = this.schemaTypes[i].cast(castedVal, doc, init, prev, options);\n        }\n        if (castedVal === val) {\n          return castedVal;\n        }\n        if (firstValue === firstValueSymbol) {\n          firstValue = castedVal;\n        }\n      } catch (error) {\n        lastError = error;\n      }\n    }\n    if (firstValue !== firstValueSymbol) {\n      return firstValue;\n    }\n    throw lastError;\n  }\n\n  clone() {\n    const schematype = super.clone();\n\n    schematype.schemaTypes = this.schemaTypes.map(schemaType => schemaType.clone());\n    return schematype;\n  }\n}\n\n/**\n * This schema type's name, to defend against minifiers that mangle\n * function names.\n *\n * @api public\n */\nUnion.schemaName = 'Union';\n\nUnion.defaultOptions = {};\n\nUnion.prototype.OptionsConstructor = SchemaUnionOptions;\n\nmodule.exports = Union;\n"],"names":[],"mappings":"AAEA;;CAEC,GAED,MAAM;AACN,MAAM;AAEN,MAAM,mBAAmB,OAAO;AAEhC;;CAEC,GAED,MAAM,cAAc;IAClB,YAAY,GAAG,EAAE,OAAO,EAAE,gBAAgB,CAAC,CAAC,CAAE;QAC5C,KAAK,CAAC,KAAK,SAAS;QACpB,IAAI,CAAC,WAAW,CAAC,MAAM,OAAO,CAAC,QAAQ,EAAE,KAAK,QAAQ,EAAE,CAAC,MAAM,KAAK,GAAG;YACrE,MAAM,IAAI,MAAM;QAClB;QACA,IAAI,CAAC,WAAW,GAAG,QAAQ,EAAE,CAAC,GAAG,CAAC,CAAA,MAAO,QAAQ,YAAY,CAAC,eAAe,CAAC,KAAK,KAAK;IAC1F;IAEA,KAAK,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE;QAClC,IAAI,aAAa;QACjB,IAAI;QACJ,gHAAgH;QAChH,gHAAgH;QAChH,mHAAmH;QACnH,2HAA2H;QAC3H,wGAAwG;QACxG,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,EAAE,EAAG;YAChD,IAAI;gBACF,MAAM,SAAS,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC,KAAK,KAAK,MAAM,MAAM;gBAC9D,IAAI,WAAW,KAAK;oBAClB,OAAO;gBACT;gBACA,IAAI,eAAe,kBAAkB;oBACnC,aAAa;gBACf;YACF,EAAE,OAAO,OAAO;gBACd,YAAY;YACd;QACF;QACA,IAAI,eAAe,kBAAkB;YACnC,OAAO;QACT;QACA,MAAM;IACR;IAEA,+GAA+G;IAC/G,aAAa,GAAG,EAAE,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,OAAO,EAAE;QAC1C,IAAI,aAAa;QACjB,IAAI;QACJ,gHAAgH;QAChH,gHAAgH;QAChH,mHAAmH;QACnH,2HAA2H;QAC3H,wGAAwG;QACxG,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE,EAAE,EAAG;YAChD,IAAI;gBACF,IAAI,YAAY,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,aAAa,CAAC,KAAK,KAAK,MAAM,MAAM;gBACxE,IAAI,aAAa,MAAM;oBACrB,YAAY,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,YAAY,CAAC;gBAC/C,OAAO;oBACL,YAAY,IAAI,CAAC,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC,WAAW,KAAK,MAAM,MAAM;gBACnE;gBACA,IAAI,cAAc,KAAK;oBACrB,OAAO;gBACT;gBACA,IAAI,eAAe,kBAAkB;oBACnC,aAAa;gBACf;YACF,EAAE,OAAO,OAAO;gBACd,YAAY;YACd;QACF;QACA,IAAI,eAAe,kBAAkB;YACnC,OAAO;QACT;QACA,MAAM;IACR;IAEA,QAAQ;QACN,MAAM,aAAa,KAAK,CAAC;QAEzB,WAAW,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAA,aAAc,WAAW,KAAK;QAC5E,OAAO;IACT;AACF;AAEA;;;;;CAKC,GACD,MAAM,UAAU,GAAG;AAEnB,MAAM,cAAc,GAAG,CAAC;AAExB,MAAM,SAAS,CAAC,kBAAkB,GAAG;AAErC,OAAO,OAAO,GAAG","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 5420, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Nazmul/OneDrive/Documents/trust-market/backend/node_modules/mongoose/lib/schema/index.js"],"sourcesContent":["\n/*!\n * Module exports.\n */\n\n'use strict';\n\nexports.Array = require('./array');\nexports.BigInt = require('./bigint');\nexports.Boolean = require('./boolean');\nexports.Buffer = require('./buffer');\nexports.Date = require('./date');\nexports.Decimal128 = exports.Decimal = require('./decimal128');\nexports.DocumentArray = require('./documentArray');\nexports.Double = require('./double');\nexports.Int32 = require('./int32');\nexports.Map = require('./map');\nexports.Mixed = require('./mixed');\nexports.Number = require('./number');\nexports.ObjectId = require('./objectId');\nexports.String = require('./string');\nexports.Subdocument = require('./subdocument');\nexports.UUID = require('./uuid');\nexports.Union = require('./union');\n\n// alias\n\nexports.Oid = exports.ObjectId;\nexports.Object = exports.Mixed;\nexports.Bool = exports.Boolean;\nexports.ObjectID = exports.ObjectId;\n"],"names":[],"mappings":"AACA;;CAEC,GAID,QAAQ,KAAK;AACb,QAAQ,MAAM;AACd,QAAQ,OAAO;AACf,QAAQ,MAAM;AACd,QAAQ,IAAI;AACZ,QAAQ,UAAU,GAAG,QAAQ,OAAO;AACpC,QAAQ,aAAa;AACrB,QAAQ,MAAM;AACd,QAAQ,KAAK;AACb,QAAQ,GAAG;AACX,QAAQ,KAAK;AACb,QAAQ,MAAM;AACd,QAAQ,QAAQ;AAChB,QAAQ,MAAM;AACd,QAAQ,WAAW;AACnB,QAAQ,IAAI;AACZ,QAAQ,KAAK;AAEb,QAAQ;AAER,QAAQ,GAAG,GAAG,QAAQ,QAAQ;AAC9B,QAAQ,MAAM,GAAG,QAAQ,KAAK;AAC9B,QAAQ,IAAI,GAAG,QAAQ,OAAO;AAC9B,QAAQ,QAAQ,GAAG,QAAQ,QAAQ","ignoreList":[0],"debugId":null}}]
}